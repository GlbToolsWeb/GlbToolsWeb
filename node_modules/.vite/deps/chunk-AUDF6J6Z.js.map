{
  "version": 3,
  "sources": ["../../property-graph/src/event-dispatcher.ts", "../../property-graph/src/graph-edge.ts", "../../property-graph/src/graph.ts", "../../property-graph/src/refs.ts", "../../property-graph/src/graph-node.ts", "../../@gltf-transform/core/src/constants.ts", "../../@gltf-transform/core/src/utils/buffer-utils.ts", "../../@gltf-transform/core/src/utils/color-utils.ts", "../../@gltf-transform/core/src/utils/image-utils.ts", "../../@gltf-transform/core/src/utils/file-utils.ts", "../../node_modules/gl-matrix/esm/common.js", "../../node_modules/gl-matrix/esm/vec3.js", "../../@gltf-transform/core/src/utils/get-bounds.ts", "../../@gltf-transform/core/src/utils/http-utils.ts", "../../@gltf-transform/core/src/utils/is-plain-object.ts", "../../@gltf-transform/core/src/utils/logger.ts", "../../node_modules/gl-matrix/esm/mat4.js", "../../@gltf-transform/core/src/utils/math-utils.ts", "../../@gltf-transform/core/src/utils/property-utils.ts", "../../@gltf-transform/core/src/utils/uuid.ts", "../../@gltf-transform/core/src/properties/property.ts", "../../@gltf-transform/core/src/properties/extensible-property.ts", "../../@gltf-transform/core/src/properties/accessor.ts", "../../@gltf-transform/core/src/properties/animation.ts", "../../@gltf-transform/core/src/properties/animation-channel.ts", "../../@gltf-transform/core/src/properties/animation-sampler.ts", "../../@gltf-transform/core/src/properties/buffer.ts", "../../@gltf-transform/core/src/properties/camera.ts", "../../@gltf-transform/core/src/properties/extension-property.ts", "../../@gltf-transform/core/src/properties/texture-info.ts", "../../@gltf-transform/core/src/properties/material.ts", "../../@gltf-transform/core/src/properties/mesh.ts", "../../@gltf-transform/core/src/properties/node.ts", "../../@gltf-transform/core/src/properties/primitive.ts", "../../@gltf-transform/core/src/properties/primitive-target.ts", "../../@gltf-transform/core/src/properties/scene.ts", "../../@gltf-transform/core/src/properties/skin.ts", "../../@gltf-transform/core/src/properties/texture.ts", "../../@gltf-transform/core/src/properties/root.ts", "../../@gltf-transform/core/src/document.ts", "../../@gltf-transform/core/src/extension.ts", "../../@gltf-transform/core/src/io/reader-context.ts", "../../@gltf-transform/core/src/io/reader.ts", "../../@gltf-transform/core/src/io/writer-context.ts", "../../@gltf-transform/core/src/io/writer.ts", "../../@gltf-transform/core/src/io/platform-io.ts", "../../@gltf-transform/core/src/io/deno-io.ts", "../../@gltf-transform/core/src/io/node-io.ts", "../../@gltf-transform/core/src/io/web-io.ts"],
  "sourcesContent": ["import type { Graph } from './graph.js';\nimport type { GraphNode } from './graph-node.js';\nimport type { GraphEdge } from './graph-edge.js';\n\nexport interface BaseEvent {\n\ttype: string;\n\t[attachment: string]: unknown;\n}\n\nexport interface GraphEvent extends BaseEvent {\n\ttarget: Graph<GraphNode>;\n}\n\nexport interface GraphNodeEvent extends BaseEvent {\n\ttarget: GraphNode;\n}\n\nexport interface GraphEdgeEvent extends BaseEvent {\n\ttarget: GraphEdge<GraphNode, GraphNode>;\n}\n\nexport type EventListener<E> = (event: E) => void;\n\nexport class EventDispatcher<T extends BaseEvent> {\n\tprivate _listeners: Record<string, EventListener<T>[]> = {};\n\n\taddEventListener(type: string, listener: EventListener<T>): this {\n\t\tconst listeners = this._listeners;\n\n\t\tif (listeners[type] === undefined) {\n\t\t\tlisteners[type] = [] as EventListener<T>[];\n\t\t}\n\n\t\tif (listeners[type].indexOf(listener) === -1) {\n\t\t\tlisteners[type].push(listener);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tremoveEventListener(type: string, listener: EventListener<T>): this {\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[type];\n\n\t\tif (listenerArray !== undefined) {\n\t\t\tconst index = listenerArray.indexOf(listener);\n\n\t\t\tif (index !== -1) {\n\t\t\t\tlistenerArray.splice(index, 1);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tdispatchEvent(event: T): this {\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[event.type];\n\n\t\tif (listenerArray !== undefined) {\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice(0);\n\n\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\tarray[i].call(this, event as T);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tdispose(): void {\n\t\tfor (const key in this._listeners) {\n\t\t\tdelete this._listeners[key];\n\t\t}\n\t}\n}\n", "import { GraphNode } from './graph-node.js';\n\n/**\n * Represents a connection between two {@link GraphNode} resources in a {@link Graph}.\n *\n * The left node is considered the owner, and the right node the resource. The\n * owner is responsible for being able find and remove a reference to a resource, given\n * that link. The resource does not hold a reference to the link or to the owner,\n * although that reverse lookup can be done on the graph.\n */\nexport class GraphEdge<Parent extends GraphNode, Child extends GraphNode> {\n\tprivate _disposed = false;\n\n\tconstructor(\n\t\tprivate readonly _name: string,\n\t\tprivate readonly _parent: Parent,\n\t\tprivate _child: Child,\n\t\tprivate _attributes: Record<string, unknown> = {},\n\t) {\n\t\tif (!_parent.isOnGraph(_child)) {\n\t\t\tthrow new Error('Cannot connect disconnected graphs.');\n\t\t}\n\t}\n\n\t/** Name (attribute name from parent {@link GraphNode}). */\n\tgetName(): string {\n\t\treturn this._name;\n\t}\n\n\t/** Owner node. */\n\tgetParent(): Parent {\n\t\treturn this._parent;\n\t}\n\n\t/** Resource node. */\n\tgetChild(): Child {\n\t\treturn this._child;\n\t}\n\n\t/**\n\t * Sets the child node.\n\t *\n\t * @internal Only {@link Graph} implementations may safely call this method directly. Use\n\t * \t{@link Property.swap} or {@link Graph.swapChild} instead.\n\t */\n\tsetChild(child: Child): this {\n\t\tthis._child = child;\n\t\treturn this;\n\t}\n\n\t/** Attributes of the graph node relationship. */\n\tgetAttributes(): Record<string, unknown> {\n\t\treturn this._attributes;\n\t}\n\n\t/** Destroys a (currently intact) edge, updating both the graph and the owner. */\n\tdispose(): void {\n\t\tif (this._disposed) return;\n\t\t// @ts-expect-error GraphEdge doesn't know types of parent GraphNode.\n\t\tthis._parent._destroyRef(this);\n\t\tthis._disposed = true;\n\t}\n\n\t/** Whether this link has been destroyed. */\n\tisDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n}\n", "import { EventDispatcher, GraphEdgeEvent, GraphEvent, GraphNodeEvent } from './event-dispatcher.js';\nimport { GraphEdge } from './graph-edge.js';\nimport { GraphNode } from './graph-node.js';\n\n/**\n * A graph manages a network of {@link GraphNode} nodes, connected\n * by {@link @Link} edges.\n */\nexport class Graph<T extends GraphNode> extends EventDispatcher<GraphEvent | GraphNodeEvent | GraphEdgeEvent> {\n\tprivate _emptySet: Set<GraphEdge<T, T>> = new Set();\n\n\tprivate _edges: Set<GraphEdge<T, T>> = new Set();\n\tprivate _parentEdges: Map<T, Set<GraphEdge<T, T>>> = new Map();\n\tprivate _childEdges: Map<T, Set<GraphEdge<T, T>>> = new Map();\n\n\t/** Returns a list of all parent->child edges on this graph. */\n\tpublic listEdges(): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._edges);\n\t}\n\n\t/** Returns a list of all edges on the graph having the given node as their child. */\n\tpublic listParentEdges(node: T): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._childEdges.get(node) || this._emptySet);\n\t}\n\n\t/** Returns a list of parent nodes for the given child node. */\n\tpublic listParents(node: T): T[] {\n\t\tconst parentSet = new Set<T>();\n\t\tfor (const edge of this.listParentEdges(node)) {\n\t\t\tparentSet.add(edge.getParent());\n\t\t}\n\t\treturn Array.from(parentSet);\n\t}\n\n\t/** Returns a list of all edges on the graph having the given node as their parent. */\n\tpublic listChildEdges(node: T): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._parentEdges.get(node) || this._emptySet);\n\t}\n\n\t/** Returns a list of child nodes for the given parent node. */\n\tpublic listChildren(node: T): T[] {\n\t\tconst childSet = new Set<T>();\n\t\tfor (const edge of this.listChildEdges(node)) {\n\t\t\tchildSet.add(edge.getChild());\n\t\t}\n\t\treturn Array.from(childSet);\n\t}\n\n\tpublic disconnectParents(node: T, filter?: (n: T) => boolean): this {\n\t\tfor (const edge of this.listParentEdges(node)) {\n\t\t\tif (!filter || filter(edge.getParent())) {\n\t\t\t\tedge.dispose();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Internal.\n\t */\n\n\t/**\n\t * Creates a {@link GraphEdge} connecting two {@link GraphNode} instances. Edge is returned\n\t * for the caller to store.\n\t * @param a Owner\n\t * @param b Resource\n\t * @hidden\n\t * @internal\n\t */\n\tpublic _createEdge<A extends T, B extends T>(\n\t\tname: string,\n\t\ta: A,\n\t\tb: B,\n\t\tattributes?: Record<string, unknown>,\n\t): GraphEdge<A, B> {\n\t\tconst edge = new GraphEdge(name, a, b, attributes);\n\t\tthis._edges.add(edge);\n\n\t\tconst parent = edge.getParent();\n\t\tif (!this._parentEdges.has(parent)) this._parentEdges.set(parent, new Set());\n\t\tthis._parentEdges.get(parent)!.add(edge);\n\n\t\tconst child = edge.getChild();\n\t\tif (!this._childEdges.has(child)) this._childEdges.set(child, new Set());\n\t\tthis._childEdges.get(child)!.add(edge);\n\n\t\treturn edge;\n\t}\n\n\t/**\n\t * Detaches a {@link GraphEdge} from the {@link Graph}. Before calling this\n\t * method, ensure that the GraphEdge has first been detached from any\n\t * associated {@link GraphNode} attributes.\n\t * @hidden\n\t * @internal\n\t */\n\tpublic _destroyEdge(edge: GraphEdge<T, T>): this {\n\t\tthis._edges.delete(edge);\n\t\tthis._parentEdges.get(edge.getParent())!.delete(edge);\n\t\tthis._childEdges.get(edge.getChild())!.delete(edge);\n\t\treturn this;\n\t}\n}\n", "import { GraphEdge } from './graph-edge.js';\nimport { GraphNode } from './graph-node.js';\n\nexport type Ref<T extends GraphNode = GraphNode> = GraphEdge<GraphNode, T>;\n\n/**\n * An ordered collection of {@link Ref Refs}, allowing duplicates. Removing\n * a Ref is an O(n) operation — use {@link RefSet} for faster removal, if\n * duplicates are not required.\n */\nexport class RefList<T extends GraphNode = GraphNode> {\n\tlist: Ref<T>[] = [];\n\tconstructor(refs?: Ref<T>[]) {\n\t\tif (refs) {\n\t\t\tfor (const ref of refs) {\n\t\t\t\tthis.list.push(ref);\n\t\t\t}\n\t\t}\n\t}\n\tadd(ref: Ref<T>): void {\n\t\tthis.list.push(ref);\n\t}\n\tremove(ref: Ref<T>): void {\n\t\tconst index = this.list.indexOf(ref);\n\t\tif (index >= 0) this.list.splice(index, 1);\n\t}\n\tremoveChild(child: T): Ref<T>[] {\n\t\tconst refs = [] as Ref<T>[];\n\t\tfor (const ref of this.list) {\n\t\t\tif (ref.getChild() === child) {\n\t\t\t\trefs.push(ref);\n\t\t\t}\n\t\t}\n\t\tfor (const ref of refs) {\n\t\t\tthis.remove(ref);\n\t\t}\n\t\treturn refs;\n\t}\n\tlistRefsByChild(child: T): Ref<T>[] {\n\t\tconst refs = [] as Ref<T>[];\n\t\tfor (const ref of this.list) {\n\t\t\tif (ref.getChild() === child) {\n\t\t\t\trefs.push(ref);\n\t\t\t}\n\t\t}\n\t\treturn refs;\n\t}\n\tvalues(): Ref<T>[] {\n\t\treturn this.list;\n\t}\n}\n\n/**\n * An ordered collection of {@link Ref Refs}, without duplicates. Adding or\n * removing a Ref is typically O(1) or O(log(n)), and faster than\n * {@link RefList}. If support for duplicates is required, use {@link RefList}.\n */\nexport class RefSet<T extends GraphNode = GraphNode> {\n\tset = new Set<Ref<T>>();\n\tmap = new Map<T, Ref<T>>();\n\tconstructor(refs?: Ref<T>[]) {\n\t\tif (refs) {\n\t\t\tfor (const ref of refs) {\n\t\t\t\tthis.add(ref);\n\t\t\t}\n\t\t}\n\t}\n\tadd(ref: Ref<T>): void {\n\t\tconst child = ref.getChild();\n\t\tthis.removeChild(child);\n\n\t\tthis.set.add(ref);\n\t\tthis.map.set(child, ref);\n\t}\n\tremove(ref: Ref<T>): void {\n\t\tthis.set.delete(ref);\n\t\tthis.map.delete(ref.getChild());\n\t}\n\tremoveChild(child: T): Ref<T> | null {\n\t\tconst ref = this.map.get(child) || null;\n\t\tif (ref) this.remove(ref);\n\t\treturn ref;\n\t}\n\tgetRefByChild(child: T): Ref<T> | null {\n\t\treturn this.map.get(child) || null;\n\t}\n\tvalues(): Ref<T>[] {\n\t\treturn Array.from(this.set);\n\t}\n}\n\n/**\n * Map (or dictionary) from string keys to {@link Ref Refs}.\n */\nexport class RefMap<T extends GraphNode = GraphNode> {\n\tmap: { [key: string]: Ref<T> } = {};\n\tconstructor(map?: Record<string, Ref<T>>) {\n\t\tif (map) {\n\t\t\tObject.assign(this.map, map);\n\t\t}\n\t}\n\tset(key: string, child: Ref<T>): void {\n\t\tthis.map[key] = child;\n\t}\n\tdelete(key: string): void {\n\t\tdelete this.map[key];\n\t}\n\tget(key: string): Ref<T> | null {\n\t\treturn this.map[key] || null;\n\t}\n\tkeys(): string[] {\n\t\treturn Object.keys(this.map);\n\t}\n\tvalues(): Ref<T>[] {\n\t\treturn Object.values(this.map);\n\t}\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n\tLiteralKeys,\n\tNullable,\n\tRefCollectionValue,\n\tRefKeys,\n\tRefListKeys,\n\tRefMapKeys,\n\tRefMapValue,\n\tRefSetKeys,\n} from './constants.js';\nimport { BaseEvent, EventDispatcher, GraphNodeEvent } from './event-dispatcher.js';\nimport { Graph } from './graph.js';\nimport { GraphEdge } from './graph-edge.js';\nimport { Ref, RefList, RefMap, RefSet } from './refs.js';\n\n// References:\n// - https://stackoverflow.com/a/70163679/1314762\n// - https://stackoverflow.com/a/70201805/1314762\n\ntype GraphNodeAttributesInternal<Parent extends GraphNode, Attributes extends object> = {\n\t[Key in keyof Attributes]: Attributes[Key] extends GraphNode\n\t\t? GraphEdge<Parent, Attributes[Key]>\n\t\t: Attributes[Key] extends GraphNode[]\n\t\t\t? GraphEdge<Parent, Attributes[Key][number]>[]\n\t\t\t: Attributes[Key] extends { [key: string]: GraphNode }\n\t\t\t\t? Record<string, GraphEdge<Parent, Attributes[Key][string]>>\n\t\t\t\t: Attributes[Key];\n};\n\nexport const $attributes = Symbol('attributes');\nexport const $immutableKeys = Symbol('immutableKeys');\n\n/**\n * Represents a node in a {@link Graph}.\n */\nexport abstract class GraphNode<Attributes extends object = object> extends EventDispatcher<GraphNodeEvent> {\n\tprivate _disposed = false;\n\n\t/**\n\t * Internal graph used to search and maintain references.\n\t * @hidden\n\t */\n\tprotected readonly graph: Graph<GraphNode>;\n\n\t/**\n\t * Attributes (literal values and GraphNode references) associated with this instance. For each\n\t * GraphNode reference, the attributes stores a {@link GraphEdge}. List and Map references are\n\t * stored as arrays and dictionaries of edges.\n\t * @internal\n\t */\n\tprotected readonly [$attributes]: GraphNodeAttributesInternal<this, Attributes>;\n\n\t/**\n\t * Attributes included with `getDefaultAttributes` are considered immutable, and cannot be\n\t * modifed by `.setRef()`, `.copy()`, or other GraphNode methods. Both the edges and the\n\t * properties will be disposed with the parent GraphNode.\n\t *\n\t * Currently, only single-edge references (getRef/setRef) are supported as immutables.\n\t *\n\t * @internal\n\t */\n\tprotected readonly [$immutableKeys]: Set<string>;\n\n\tconstructor(graph: Graph<GraphNode>) {\n\t\tsuper();\n\t\tthis.graph = graph;\n\t\tthis[$immutableKeys] = new Set();\n\t\tthis[$attributes] = this._createAttributes();\n\t}\n\n\t/**\n\t * Returns default attributes for the graph node. Subclasses having any attributes (either\n\t * literal values or references to other graph nodes) must override this method. Literal\n\t * attributes should be given their default values, if any. References should generally be\n\t * initialized as empty (Ref → null, RefList → [], RefMap → {}) and then modified by setters.\n\t *\n\t * Any single-edge references (setRef) returned by this method will be considered immutable,\n\t * to be owned by and disposed with the parent node. Multi-edge references (addRef, removeRef,\n\t * setRefMap) cannot be returned as default attributes.\n\t */\n\tprotected getDefaults(): Nullable<Attributes> {\n\t\treturn {} as Nullable<Attributes>;\n\t}\n\n\t/**\n\t * Constructs and returns an object used to store a graph nodes attributes. Compared to the\n\t * default Attributes interface, this has two distinctions:\n\t *\n\t * 1. Slots for GraphNode<T> objects are replaced with slots for GraphEdge<this, GraphNode<T>>\n\t * 2. GraphNode<T> objects provided as defaults are considered immutable\n\t *\n\t * @internal\n\t */\n\tprivate _createAttributes(): GraphNodeAttributesInternal<this, Attributes> {\n\t\tconst defaultAttributes = this.getDefaults();\n\t\tconst attributes = {} as GraphNodeAttributesInternal<this, Attributes>;\n\t\tfor (const key in defaultAttributes) {\n\t\t\tconst value = defaultAttributes[key] as any;\n\t\t\t// TODO(design): With Ref, RefList, and RefMap types, should users\n\t\t\t// be able to pass them all here? Listeners must be added.\n\t\t\tif (value instanceof GraphNode) {\n\t\t\t\tconst ref = this.graph._createEdge(key, this, value);\n\t\t\t\tthis[$immutableKeys].add(key);\n\t\t\t\tattributes[key] = ref as any;\n\t\t\t} else {\n\t\t\t\tattributes[key] = value as any;\n\t\t\t}\n\t\t}\n\t\treturn attributes;\n\t}\n\n\t/** @internal Returns true if two nodes are on the same {@link Graph}. */\n\tpublic isOnGraph(other: GraphNode): boolean {\n\t\treturn this.graph === other.graph;\n\t}\n\n\t/** Returns true if the node has been permanently removed from the graph. */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Removes both inbound references to and outbound references from this object. At the end\n\t * of the process the object holds no references, and nothing holds references to it. A\n\t * disposed object is not reusable.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._disposed) return;\n\t\tthis.graph.listChildEdges(this).forEach((edge) => edge.dispose());\n\t\tthis.graph.disconnectParents(this);\n\t\tthis._disposed = true;\n\t\tthis.dispatchEvent({ type: 'dispose' });\n\t}\n\n\t/**\n\t * Removes all inbound references to this object. At the end of the process the object is\n\t * considered 'detached': it may hold references to child resources, but nothing holds\n\t * references to it. A detached object may be re-attached.\n\t */\n\tpublic detach(): this {\n\t\tthis.graph.disconnectParents(this);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Transfers this object's references from the old node to the new one. The old node is fully\n\t * detached from this parent at the end of the process.\n\t *\n\t * @hidden\n\t */\n\tpublic swap(prevValue: GraphNode, nextValue: GraphNode): this {\n\t\tfor (const attribute in this[$attributes]) {\n\t\t\tconst value = this[$attributes][attribute] as Ref | RefList | RefSet | RefMap;\n\t\t\tif (value instanceof GraphEdge) {\n\t\t\t\tconst ref = value as Ref;\n\t\t\t\tif (ref.getChild() === prevValue) {\n\t\t\t\t\tthis.setRef(attribute as any, nextValue, ref.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (value instanceof RefList) {\n\t\t\t\tfor (const ref of value.listRefsByChild(prevValue)) {\n\t\t\t\t\tconst refAttributes = ref.getAttributes();\n\t\t\t\t\tthis.removeRef(attribute as any, prevValue as any);\n\t\t\t\t\tthis.addRef(attribute as any, nextValue as any, refAttributes);\n\t\t\t\t}\n\t\t\t} else if (value instanceof RefSet) {\n\t\t\t\tconst ref = value.getRefByChild(prevValue);\n\t\t\t\tif (ref) {\n\t\t\t\t\tconst refAttributes = ref.getAttributes();\n\t\t\t\t\tthis.removeRef(attribute as any, prevValue as any);\n\t\t\t\t\tthis.addRef(attribute as any, nextValue as any, refAttributes);\n\t\t\t\t}\n\t\t\t} else if (value instanceof RefMap) {\n\t\t\t\tfor (const key of value.keys()) {\n\t\t\t\t\tconst ref = value.get(key)!;\n\t\t\t\t\tif (ref.getChild() === prevValue) {\n\t\t\t\t\t\tthis.setRefMap(attribute as any, key, nextValue as any, ref.getAttributes());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Literal attributes.\n\t */\n\n\t/** @hidden */\n\tprotected get<K extends LiteralKeys<Attributes>>(attribute: K): Attributes[K] {\n\t\treturn this[$attributes][attribute] as Attributes[K];\n\t}\n\n\t/** @hidden */\n\tprotected set<K extends LiteralKeys<Attributes>>(attribute: K, value: Attributes[K]): this {\n\t\t(this[$attributes][attribute] as Attributes[K]) = value;\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/**********************************************************************************************\n\t * Ref: 1:1 graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected getRef<K extends RefKeys<Attributes>>(attribute: K): (GraphNode & Attributes[K]) | null {\n\t\tconst ref = this[$attributes][attribute] as Ref;\n\t\treturn ref ? (ref.getChild() as GraphNode & Attributes[K]) : null;\n\t}\n\n\t/** @hidden */\n\tprotected setRef<K extends RefKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: (GraphNode & Attributes[K]) | null,\n\t\tattributes?: Record<string, unknown>,\n\t): this {\n\t\tif (this[$immutableKeys].has(attribute as string)) {\n\t\t\tthrow new Error(`Cannot overwrite immutable attribute, \"${attribute as string}\".`);\n\t\t}\n\n\t\tconst prevRef = this[$attributes][attribute] as Ref;\n\t\tif (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n\t\tif (!value) return this;\n\n\t\tconst ref = this.graph._createEdge(attribute as string, this, value, attributes);\n\t\t(this[$attributes][attribute] as Ref) = ref;\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/**********************************************************************************************\n\t * RefList: 1:many graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected listRefs<K extends RefListKeys<Attributes> | RefSetKeys<Attributes>>(\n\t\tattribute: K,\n\t): RefCollectionValue<Attributes[K]>[] {\n\t\tconst refs = this.assertRefList(attribute);\n\t\treturn refs.values().map((ref) => ref.getChild()) as RefCollectionValue<Attributes[K]>[];\n\t}\n\n\t/** @hidden */\n\tprotected addRef<K extends RefListKeys<Attributes> | RefSetKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: RefCollectionValue<Attributes[K]>,\n\t\tattributes?: Record<string, unknown>,\n\t): this {\n\t\tconst ref = this.graph._createEdge(attribute as string, this, value, attributes);\n\t\tconst refs = this.assertRefList(attribute);\n\t\trefs.add(ref);\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/** @hidden */\n\tprotected removeRef<K extends RefListKeys<Attributes> | RefSetKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: RefCollectionValue<Attributes[K]>,\n\t): this {\n\t\tconst refs = this.assertRefList(attribute);\n\n\t\tif (refs instanceof RefList) {\n\t\t\tfor (const ref of refs.listRefsByChild(value)) {\n\t\t\t\tref.dispose();\n\t\t\t}\n\t\t} else {\n\t\t\tconst ref = refs.getRefByChild(value);\n\t\t\tif (ref) ref.dispose();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tprivate assertRefList<K extends RefListKeys<Attributes> | RefSetKeys<Attributes>>(attribute: K): RefList | RefSet {\n\t\tconst refs = this[$attributes][attribute];\n\n\t\tif (refs instanceof RefList || refs instanceof RefSet) {\n\t\t\treturn refs;\n\t\t}\n\n\t\t// TODO(v3) Remove warning.\n\t\tthrow new Error(`Expected RefList or RefSet for attribute \"${attribute as string}\"`);\n\t}\n\n\t/**********************************************************************************************\n\t * RefMap: Named 1:many (map) graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected listRefMapKeys<K extends RefMapKeys<Attributes>>(attribute: K): string[] {\n\t\treturn this.assertRefMap(attribute).keys();\n\t}\n\n\t/** @hidden */\n\tprotected listRefMapValues<K extends RefMapKeys<Attributes>, V extends RefMapValue<Attributes[K]>>(\n\t\tattribute: K,\n\t): V[] {\n\t\treturn this.assertRefMap(attribute)\n\t\t\t.values()\n\t\t\t.map((ref: any) => ref.getChild());\n\t}\n\n\t/** @hidden */\n\tprotected getRefMap<K extends RefMapKeys<Attributes>, V extends RefMapValue<Attributes[K]>>(\n\t\tattribute: K,\n\t\tkey: string,\n\t): V | null {\n\t\tconst refMap = this.assertRefMap(attribute);\n\t\tconst ref = refMap.get(key as string);\n\t\treturn ref ? (ref.getChild() as V) : null;\n\t}\n\n\t/** @hidden */\n\tprotected setRefMap<K extends RefMapKeys<Attributes>, V extends RefMapValue<Attributes[K]>>(\n\t\tattribute: K,\n\t\tkey: string,\n\t\tvalue: V | null,\n\t\tmetadata?: Record<string, unknown>,\n\t): this {\n\t\tconst refMap = this.assertRefMap(attribute);\n\n\t\tconst prevRef = refMap.get(key as string);\n\t\tif (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n\t\tif (!value) return this;\n\n\t\tmetadata = Object.assign(metadata || {}, { key: key });\n\t\tconst ref = this.graph._createEdge(attribute as string, this, value, { ...metadata, key });\n\t\trefMap.set(key as string, ref);\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute, key });\n\t}\n\n\t/** @hidden */\n\tprivate assertRefMap<K extends RefMapKeys<Attributes>>(attribute: K): RefMap {\n\t\tconst map = this[$attributes][attribute];\n\n\t\tif (map instanceof RefMap) {\n\t\t\treturn map;\n\t\t}\n\n\t\t// TODO(v3) Remove warning.\n\t\tthrow new Error(`Expected RefMap for attribute \"${attribute as string}\"`);\n\t}\n\n\t/**********************************************************************************************\n\t * Events.\n\t */\n\n\t/**\n\t * Dispatches an event on the GraphNode, and on the associated\n\t * Graph. Event types on the graph are prefixed, `\"node:[type]\"`.\n\t */\n\tdispatchEvent(event: BaseEvent): this {\n\t\tsuper.dispatchEvent({ ...event, target: this });\n\t\tthis.graph.dispatchEvent({ ...event, target: this, type: `node:${event.type}` });\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Internal.\n\t */\n\n\t/** @hidden */\n\t_destroyRef<\n\t\tK extends RefKeys<Attributes> | RefListKeys<Attributes> | RefSetKeys<Attributes> | RefMapKeys<Attributes>,\n\t>(ref: GraphEdge<this, GraphNode & Attributes[K]>): void {\n\t\tconst attribute = ref.getName() as K;\n\t\tif (this[$attributes][attribute] === ref) {\n\t\t\t(this[$attributes][attribute as RefKeys<Attributes>] as Ref | null) = null;\n\t\t\t// TODO(design): See _createAttributes().\n\t\t\tif (this[$immutableKeys].has(attribute as string)) ref.getChild().dispose();\n\t\t} else if (this[$attributes][attribute] instanceof RefList) {\n\t\t\t(this[$attributes][attribute as RefListKeys<Attributes>] as RefList).remove(ref);\n\t\t} else if (this[$attributes][attribute] instanceof RefSet) {\n\t\t\t(this[$attributes][attribute as RefSetKeys<Attributes>] as RefSet).remove(ref);\n\t\t} else if (this[$attributes][attribute] instanceof RefMap) {\n\t\t\tconst refMap = this[$attributes][attribute as RefMapKeys<Attributes>] as RefMap;\n\t\t\tfor (const key of refMap.keys()) {\n\t\t\t\tif (refMap.get(key) === ref) {\n\t\t\t\t\trefMap.delete(key);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tthis.graph._destroyEdge(ref);\n\t\tthis.dispatchEvent({ type: 'change', attribute });\n\t}\n}\n", "// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\n/**\n * Current version of the package.\n * @hidden\n */\nexport const VERSION: string = `v${PACKAGE_VERSION}`;\n\n/** @internal */\nexport const NAME = '@gltf-transform/core';\n\n/**\n * Interface allowing Accessor setter/getter methods to be used interchangeably with gl-matrix\n * arrays or with three.js math objects' fromArray/toArray methods. For example, THREE.Vector2,\n * THREE.Vector3, THREE.Vector4, THREE.Quaternion, THREE.Matrix3, THREE.Matrix4, and THREE.Color.\n *\n * @internal\n */\nexport interface ArrayProxy {\n\t/** Sets the value of the object from an array of values. */\n\tfromArray(array: number[]): ArrayProxy;\n\t/** Writes the value of the object into the given array. */\n\ttoArray(array: number[]): number[];\n}\n\n/**\n * TypeScript utility for nullable types.\n * @hidden\n */\nexport type Nullable<T> = { [P in keyof T]: T[P] | null };\n\n/**\n * 2-dimensional vector.\n * @hidden\n */\nexport type vec2 = [number, number];\n\n/**\n * 3-dimensional vector.\n * @hidden\n */\nexport type vec3 = [number, number, number];\n\n/**\n * 4-dimensional vector, e.g. RGBA or a quaternion.\n * @hidden\n */\nexport type vec4 = [number, number, number, number];\n\n// biome-ignore format: Readability.\n/**\n * 3x3 matrix, e.g. an affine transform of a 2D vector.\n * @hidden\n */\nexport type mat3 = [\n\tnumber, number, number,\n\tnumber, number, number,\n\tnumber, number, number,\n];\n\n// biome-ignore format: Readability.\n/**\n * 4x4 matrix, e.g. an affine transform of a 3D vector.\n * @hidden\n */\nexport type mat4 = [\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n];\n\n/** @hidden */\nexport type bbox = { min: vec3; max: vec3 };\n\n/** @hidden */\nexport const GLB_BUFFER = '@glb.bin';\n\n/**\n * Abstraction representing any one of the typed array classes supported by glTF and JavaScript.\n * @hidden\n */\nexport type TypedArray = Float32Array | Uint32Array | Uint16Array | Uint8Array | Int16Array | Int8Array;\n\n/**\n * Abstraction representing the typed array constructors supported by glTF and JavaScript.\n * @hidden\n */\nexport type TypedArrayConstructor =\n\t| Float32ArrayConstructor\n\t| Uint32ArrayConstructor\n\t| Uint16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Int8ArrayConstructor;\n\n/** String IDs for core {@link Property} types. */\nexport enum PropertyType {\n\tACCESSOR = 'Accessor',\n\tANIMATION = 'Animation',\n\tANIMATION_CHANNEL = 'AnimationChannel',\n\tANIMATION_SAMPLER = 'AnimationSampler',\n\tBUFFER = 'Buffer',\n\tCAMERA = 'Camera',\n\tMATERIAL = 'Material',\n\tMESH = 'Mesh',\n\tPRIMITIVE = 'Primitive',\n\tPRIMITIVE_TARGET = 'PrimitiveTarget',\n\tNODE = 'Node',\n\tROOT = 'Root',\n\tSCENE = 'Scene',\n\tSKIN = 'Skin',\n\tTEXTURE = 'Texture',\n\tTEXTURE_INFO = 'TextureInfo',\n}\n\n/** Vertex layout method. */\nexport enum VertexLayout {\n\t/**\n\t * Stores vertex attributes in a single buffer view per mesh primitive. Interleaving vertex\n\t * data may improve performance by reducing page-thrashing in GPU memory.\n\t */\n\tINTERLEAVED = 'interleaved',\n\n\t/**\n\t * Stores each vertex attribute in a separate buffer view. May decrease performance by causing\n\t * page-thrashing in GPU memory. Some 3D engines may prefer this layout, e.g. for simplicity.\n\t */\n\tSEPARATE = 'separate',\n}\n\n/** Accessor usage. */\nexport enum BufferViewUsage {\n\tARRAY_BUFFER = 'ARRAY_BUFFER',\n\tELEMENT_ARRAY_BUFFER = 'ELEMENT_ARRAY_BUFFER',\n\tINVERSE_BIND_MATRICES = 'INVERSE_BIND_MATRICES',\n\tOTHER = 'OTHER',\n\tSPARSE = 'SPARSE',\n}\n\n/** Texture channels. */\nexport enum TextureChannel {\n\tR = 0x1000,\n\tG = 0x0100,\n\tB = 0x0010,\n\tA = 0x0001,\n}\n\nexport enum Format {\n\tGLTF = 'GLTF',\n\tGLB = 'GLB',\n}\n\nexport const ComponentTypeToTypedArray: Record<string, TypedArrayConstructor> = {\n\t'5120': Int8Array,\n\t'5121': Uint8Array,\n\t'5122': Int16Array,\n\t'5123': Uint16Array,\n\t'5125': Uint32Array,\n\t'5126': Float32Array,\n};\n", "import type { TypedArray } from '../constants.js';\n\n/**\n * *Common utilities for working with Uint8Array and Buffer objects.*\n *\n * @category Utilities\n */\nexport class BufferUtils {\n\t/** Creates a byte array from a Data URI. */\n\tstatic createBufferFromDataURI(dataURI: string): Uint8Array {\n\t\tif (typeof Buffer === 'undefined') {\n\t\t\t// Browser.\n\t\t\tconst byteString = atob(dataURI.split(',')[1]);\n\t\t\tconst ia = new Uint8Array(byteString.length);\n\t\t\tfor (let i = 0; i < byteString.length; i++) {\n\t\t\t\tia[i] = byteString.charCodeAt(i);\n\t\t\t}\n\t\t\treturn ia;\n\t\t} else {\n\t\t\t// Node.js.\n\t\t\tconst data = dataURI.split(',')[1];\n\t\t\tconst isBase64 = dataURI.indexOf('base64') >= 0;\n\t\t\treturn Buffer.from(data, isBase64 ? 'base64' : 'utf8');\n\t\t}\n\t}\n\n\t/** Encodes text to a byte array. */\n\tstatic encodeText(text: string): Uint8Array {\n\t\treturn new TextEncoder().encode(text);\n\t}\n\n\t/** Decodes a byte array to text. */\n\tstatic decodeText(array: Uint8Array): string {\n\t\treturn new TextDecoder().decode(array);\n\t}\n\n\t/**\n\t * Concatenates N byte arrays.\n\t */\n\tstatic concat(arrays: Uint8Array[]): Uint8Array {\n\t\tlet totalByteLength = 0;\n\t\tfor (const array of arrays) {\n\t\t\ttotalByteLength += array.byteLength;\n\t\t}\n\n\t\tconst result = new Uint8Array(totalByteLength);\n\t\tlet byteOffset = 0;\n\n\t\tfor (const array of arrays) {\n\t\t\tresult.set(array, byteOffset);\n\t\t\tbyteOffset += array.byteLength;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Pads a Uint8Array to the next 4-byte boundary.\n\t *\n\t * Reference: [glTF → Data Alignment](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment)\n\t */\n\tstatic pad(srcArray: Uint8Array, paddingByte = 0): Uint8Array {\n\t\tconst paddedLength = this.padNumber(srcArray.byteLength);\n\t\tif (paddedLength === srcArray.byteLength) return srcArray;\n\n\t\tconst dstArray = new Uint8Array(paddedLength);\n\t\tdstArray.set(srcArray);\n\n\t\tif (paddingByte !== 0) {\n\t\t\tfor (let i = srcArray.byteLength; i < paddedLength; i++) {\n\t\t\t\tdstArray[i] = paddingByte;\n\t\t\t}\n\t\t}\n\n\t\treturn dstArray;\n\t}\n\n\t/** Pads a number to 4-byte boundaries. */\n\tstatic padNumber(v: number): number {\n\t\treturn Math.ceil(v / 4) * 4;\n\t}\n\n\t/** Returns true if given byte array instances are equal. */\n\tstatic equals(a: Uint8Array, b: Uint8Array): boolean {\n\t\tif (a === b) return true;\n\n\t\tif (a.byteLength !== b.byteLength) return false;\n\n\t\tlet i = a.byteLength;\n\t\twhile (i--) {\n\t\t\tif (a[i] !== b[i]) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns a Uint8Array view of a typed array, with the same underlying ArrayBuffer.\n\t *\n\t * A shorthand for:\n\t *\n\t * ```js\n\t * const buffer = new Uint8Array(\n\t * \tarray.buffer,\n\t * \tarray.byteOffset + byteOffset,\n\t * \tMath.min(array.byteLength, byteLength)\n\t * );\n\t * ```\n\t *\n\t */\n\tstatic toView(a: TypedArray, byteOffset = 0, byteLength: number = Infinity): Uint8Array {\n\t\treturn new Uint8Array(a.buffer, a.byteOffset + byteOffset, Math.min(a.byteLength, byteLength));\n\t}\n\n\t/** @internal */\n\tstatic assertView(view: null): null;\n\tstatic assertView(view: Uint8Array): Uint8Array;\n\tstatic assertView(view: Uint8Array | null): Uint8Array | null;\n\tstatic assertView(view: Uint8Array | null): Uint8Array | null {\n\t\tif (view && !ArrayBuffer.isView(view)) {\n\t\t\tthrow new Error(`Method requires Uint8Array parameter; received \"${typeof view}\".`);\n\t\t}\n\t\treturn view as Uint8Array;\n\t}\n}\n", "import type { vec3, vec4 } from '../constants.js';\n\n/**\n * *Common utilities for working with colors in vec3, vec4, or hexadecimal form.*\n *\n * Provides methods to convert linear components (vec3, vec4) to sRGB hex values. All colors in\n * the glTF specification, excluding color textures, are linear. Hexadecimal values, in sRGB\n * colorspace, are accessible through helper functions in the API as a convenience.\n *\n * ```typescript\n * // Hex (sRGB) to factor (linear).\n * const factor = ColorUtils.hexToFactor(0xFFCCCC, []);\n *\n * // Factor (linear) to hex (sRGB).\n * const hex = ColorUtils.factorToHex([1, .25, .25])\n * ```\n *\n * @category Utilities\n */\nexport class ColorUtils {\n\t/**\n\t * Converts sRGB hexadecimal to linear components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic hexToFactor<T = vec3 | vec4>(hex: number, target: T): T {\n\t\thex = Math.floor(hex);\n\t\tconst _target = target as unknown as vec3;\n\t\t_target[0] = ((hex >> 16) & 255) / 255;\n\t\t_target[1] = ((hex >> 8) & 255) / 255;\n\t\t_target[2] = (hex & 255) / 255;\n\t\treturn this.convertSRGBToLinear<T>(target, target);\n\t}\n\n\t/**\n\t * Converts linear components to sRGB hexadecimal.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic factorToHex<T = vec3 | vec4>(factor: T): number {\n\t\tconst target = [...(factor as unknown as number[])] as unknown as T;\n\t\tconst [r, g, b] = this.convertLinearToSRGB(factor, target) as unknown as number[];\n\t\treturn ((r * 255) << 16) ^ ((g * 255) << 8) ^ ((b * 255) << 0);\n\t}\n\n\t/**\n\t * Converts sRGB components to linear components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic convertSRGBToLinear<T = vec3 | vec4>(source: T, target: T): T {\n\t\tconst _source = source as unknown as vec3;\n\t\tconst _target = target as unknown as vec3;\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t_target[i] =\n\t\t\t\t_source[i] < 0.04045\n\t\t\t\t\t? _source[i] * 0.0773993808\n\t\t\t\t\t: Math.pow(_source[i] * 0.9478672986 + 0.0521327014, 2.4);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Converts linear components to sRGB components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic convertLinearToSRGB<T = vec3 | vec4>(source: T, target: T): T {\n\t\tconst _source = source as unknown as vec3;\n\t\tconst _target = target as unknown as vec3;\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t_target[i] = _source[i] < 0.0031308 ? _source[i] * 12.92 : 1.055 * Math.pow(_source[i], 0.41666) - 0.055;\n\t\t}\n\t\treturn target;\n\t}\n}\n", "import type { vec2 } from '../constants.js';\nimport { BufferUtils } from './buffer-utils.js';\n\n/** Implements support for an image format in the {@link ImageUtils} class. */\nexport interface ImageUtilsFormat {\n\tmatch(buffer: Uint8Array): boolean;\n\tgetSize(buffer: Uint8Array): vec2 | null;\n\tgetChannels(buffer: Uint8Array): number | null;\n\tgetVRAMByteLength?(buffer: Uint8Array): number | null;\n}\n\n/** JPEG image support. */\nclass JPEGImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn array.length >= 3 && array[0] === 255 && array[1] === 216 && array[2] === 255;\n\t}\n\tgetSize(array: Uint8Array): vec2 {\n\t\t// Skip 4 chars, they are for signature\n\t\tlet view = new DataView(array.buffer, array.byteOffset + 4);\n\n\t\tlet i: number, next: number;\n\t\twhile (view.byteLength) {\n\t\t\t// read length of the next block\n\t\t\ti = view.getUint16(0, false);\n\t\t\t// i = buffer.readUInt16BE(0);\n\n\t\t\t// ensure correct format\n\t\t\tvalidateJPEGBuffer(view, i);\n\n\t\t\t// 0xFFC0 is baseline standard(SOF)\n\t\t\t// 0xFFC1 is baseline optimized(SOF)\n\t\t\t// 0xFFC2 is progressive(SOF2)\n\t\t\tnext = view.getUint8(i + 1);\n\t\t\tif (next === 0xc0 || next === 0xc1 || next === 0xc2) {\n\t\t\t\treturn [view.getUint16(i + 7, false), view.getUint16(i + 5, false)];\n\t\t\t}\n\n\t\t\t// move to the next block\n\t\t\tview = new DataView(array.buffer, view.byteOffset + i + 2);\n\t\t}\n\n\t\tthrow new TypeError('Invalid JPG, no size found');\n\t}\n\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 3;\n\t}\n}\n\n/**\n * PNG image support.\n *\n * PNG signature: 'PNG\\r\\n\\x1a\\n'\n * PNG image header chunk name: 'IHDR'\n */\nclass PNGImageUtils implements ImageUtilsFormat {\n\t// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\n\tstatic PNG_FRIED_CHUNK_NAME = 'CgBI';\n\tmatch(array: Uint8Array): boolean {\n\t\treturn (\n\t\t\tarray.length >= 8 &&\n\t\t\tarray[0] === 0x89 &&\n\t\t\tarray[1] === 0x50 &&\n\t\t\tarray[2] === 0x4e &&\n\t\t\tarray[3] === 0x47 &&\n\t\t\tarray[4] === 0x0d &&\n\t\t\tarray[5] === 0x0a &&\n\t\t\tarray[6] === 0x1a &&\n\t\t\tarray[7] === 0x0a\n\t\t);\n\t}\n\tgetSize(array: Uint8Array): vec2 {\n\t\tconst view = new DataView(array.buffer, array.byteOffset);\n\t\tconst magic = BufferUtils.decodeText(array.slice(12, 16));\n\t\tif (magic === PNGImageUtils.PNG_FRIED_CHUNK_NAME) {\n\t\t\treturn [view.getUint32(32, false), view.getUint32(36, false)];\n\t\t}\n\t\treturn [view.getUint32(16, false), view.getUint32(20, false)];\n\t}\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 4;\n\t}\n}\n\n/**\n * *Common utilities for working with image data.*\n *\n * @category Utilities\n */\nexport class ImageUtils {\n\tstatic impls: Record<string, ImageUtilsFormat> = {\n\t\t'image/jpeg': new JPEGImageUtils(),\n\t\t'image/png': new PNGImageUtils(),\n\t};\n\n\t/** Registers support for a new image format; useful for certain extensions. */\n\tpublic static registerFormat(mimeType: string, impl: ImageUtilsFormat): void {\n\t\tthis.impls[mimeType] = impl;\n\t}\n\n\t/**\n\t * Returns detected MIME type of the given image buffer. Note that for image\n\t * formats with support provided by extensions, the extension must be\n\t * registered with an I/O class before it can be detected by ImageUtils.\n\t */\n\tpublic static getMimeType(buffer: Uint8Array): string | null {\n\t\tfor (const mimeType in this.impls) {\n\t\t\tif (this.impls[mimeType].match(buffer)) {\n\t\t\t\treturn mimeType;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Returns the dimensions of the image. */\n\tpublic static getSize(buffer: Uint8Array, mimeType: string): vec2 | null {\n\t\tif (!this.impls[mimeType]) return null;\n\t\treturn this.impls[mimeType].getSize(buffer);\n\t}\n\n\t/**\n\t * Returns a conservative estimate of the number of channels in the image. For some image\n\t * formats, the method may return 4 indicating the possibility of an alpha channel, without\n\t * the ability to guarantee that an alpha channel is present.\n\t */\n\tpublic static getChannels(buffer: Uint8Array, mimeType: string): number | null {\n\t\tif (!this.impls[mimeType]) return null;\n\t\treturn this.impls[mimeType].getChannels(buffer);\n\t}\n\n\t/** Returns a conservative estimate of the GPU memory required by this image. */\n\tpublic static getVRAMByteLength(buffer: Uint8Array, mimeType: string): number | null {\n\t\tif (!this.impls[mimeType]) return null;\n\n\t\tif (this.impls[mimeType].getVRAMByteLength) {\n\t\t\treturn this.impls[mimeType].getVRAMByteLength!(buffer);\n\t\t}\n\n\t\tlet uncompressedBytes = 0;\n\t\tconst channels = 4; // See https://github.com/donmccurdy/glTF-Transform/issues/151.\n\t\tconst resolution = this.getSize(buffer, mimeType);\n\t\tif (!resolution) return null;\n\n\t\twhile (resolution[0] > 1 || resolution[1] > 1) {\n\t\t\tuncompressedBytes += resolution[0] * resolution[1] * channels;\n\t\t\tresolution[0] = Math.max(Math.floor(resolution[0] / 2), 1);\n\t\t\tresolution[1] = Math.max(Math.floor(resolution[1] / 2), 1);\n\t\t}\n\t\tuncompressedBytes += 1 * 1 * channels;\n\t\treturn uncompressedBytes;\n\t}\n\n\t/** Returns the preferred file extension for the given MIME type. */\n\tpublic static mimeTypeToExtension(mimeType: string): string {\n\t\tif (mimeType === 'image/jpeg') return 'jpg';\n\t\treturn mimeType.split('/').pop()!;\n\t}\n\n\t/** Returns the MIME type for the given file extension. */\n\tpublic static extensionToMimeType(extension: string): string {\n\t\tif (extension === 'jpg') return 'image/jpeg';\n\t\tif (!extension) return '';\n\t\treturn `image/${extension}`;\n\t}\n}\n\nfunction validateJPEGBuffer(view: DataView, i: number): DataView {\n\t// index should be within buffer limits\n\tif (i > view.byteLength) {\n\t\tthrow new TypeError('Corrupt JPG, exceeded buffer limits');\n\t}\n\t// Every JPEG block must begin with a 0xFF\n\tif (view.getUint8(i) !== 0xff) {\n\t\tthrow new TypeError('Invalid JPG, marker table corrupted');\n\t}\n\n\treturn view;\n}\n", "import { ImageUtils } from './image-utils.js';\n\n/**\n * *Utility class for working with file systems and URI paths.*\n *\n * @category Utilities\n */\nexport class FileUtils {\n\t/**\n\t * Extracts the basename from a file path, e.g. \"folder/model.glb\" -> \"model\".\n\t * See: {@link HTTPUtils.basename}\n\t */\n\tstatic basename(uri: string): string {\n\t\tconst fileName = uri.split(/[\\\\/]/).pop()!;\n\t\treturn fileName.substring(0, fileName.lastIndexOf('.'));\n\t}\n\n\t/**\n\t * Extracts the extension from a file path, e.g. \"folder/model.glb\" -> \"glb\".\n\t * See: {@link HTTPUtils.extension}\n\t */\n\tstatic extension(uri: string): string {\n\t\tif (uri.startsWith('data:image/')) {\n\t\t\tconst mimeType = uri.match(/data:(image\\/\\w+)/)![1];\n\t\t\treturn ImageUtils.mimeTypeToExtension(mimeType);\n\t\t} else if (uri.startsWith('data:model/gltf+json')) {\n\t\t\treturn 'gltf';\n\t\t} else if (uri.startsWith('data:model/gltf-binary')) {\n\t\t\treturn 'glb';\n\t\t} else if (uri.startsWith('data:application/')) {\n\t\t\treturn 'bin';\n\t\t}\n\t\treturn uri.split(/[\\\\/]/).pop()!.split(/[.]/).pop()!;\n\t}\n}\n", "/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};", "import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();", "import { transformMat4 } from 'gl-matrix/vec3';\nimport { type bbox, type mat4, PropertyType, type vec3 } from '../constants.js';\nimport type { Mesh, Node, Scene } from '../properties/index.js';\n\n/** @hidden Implemented in /core for use by /extensions, publicly exported from /functions. */\nexport function getBounds(node: Node | Scene): bbox {\n\tconst resultBounds = createBounds();\n\tconst parents = node.propertyType === PropertyType.NODE ? [node] : node.listChildren();\n\n\tfor (const parent of parents) {\n\t\tparent.traverse((node) => {\n\t\t\tconst mesh = node.getMesh();\n\t\t\tif (!mesh) return;\n\n\t\t\t// Compute mesh bounds and update result.\n\t\t\tconst meshBounds = getMeshBounds(mesh, node.getWorldMatrix());\n\t\t\tif (meshBounds.min.every(isFinite) && meshBounds.max.every(isFinite)) {\n\t\t\t\texpandBounds(meshBounds.min, resultBounds);\n\t\t\t\texpandBounds(meshBounds.max, resultBounds);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn resultBounds;\n}\n\n/** Computes mesh bounds in world space. */\nfunction getMeshBounds(mesh: Mesh, worldMatrix: mat4): bbox {\n\tconst meshBounds = createBounds();\n\n\t// We can't transform a local AABB into world space and still have a tight AABB in world space,\n\t// so we need to compute the world AABB vertex by vertex here.\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst position = prim.getAttribute('POSITION');\n\t\tconst indices = prim.getIndices();\n\t\tif (!position) continue;\n\n\t\tlet localPos: vec3 = [0, 0, 0];\n\t\tlet worldPos: vec3 = [0, 0, 0];\n\t\tfor (let i = 0, il = indices ? indices.getCount() : position.getCount(); i < il; i++) {\n\t\t\tconst index = indices ? indices.getScalar(i) : i;\n\t\t\tlocalPos = position.getElement(index, localPos) as vec3;\n\t\t\tworldPos = transformMat4(worldPos, localPos, worldMatrix) as vec3;\n\t\t\texpandBounds(worldPos, meshBounds);\n\t\t}\n\t}\n\n\treturn meshBounds;\n}\n\n/** Expands bounds of target by given source. */\nfunction expandBounds(point: vec3, target: bbox): void {\n\tfor (let i = 0; i < 3; i++) {\n\t\ttarget.min[i] = Math.min(point[i], target.min[i]);\n\t\ttarget.max[i] = Math.max(point[i], target.max[i]);\n\t}\n}\n\n/** Creates new bounds with min=Infinity, max=-Infinity. */\nfunction createBounds(): bbox {\n\treturn {\n\t\tmin: [Infinity, Infinity, Infinity] as vec3,\n\t\tmax: [-Infinity, -Infinity, -Infinity] as vec3,\n\t};\n}\n", "import { FileUtils } from './file-utils.js';\n\n// Need a placeholder domain to construct a URL from a relative path. We only\n// access `url.pathname`, so the domain doesn't matter.\nconst NULL_DOMAIN = 'https://null.example';\n\n/**\n * *Utility class for working with URLs.*\n *\n * @category Utilities\n */\nexport class HTTPUtils {\n\tstatic readonly DEFAULT_INIT: RequestInit = {};\n\tstatic readonly PROTOCOL_REGEXP: RegExp = /^[a-zA-Z]+:\\/\\//;\n\n\tstatic dirname(path: string): string {\n\t\tconst index = path.lastIndexOf('/');\n\t\tif (index === -1) return './';\n\t\treturn path.substring(0, index + 1);\n\t}\n\n\t/**\n\t * Extracts the basename from a URL, e.g. \"folder/model.glb\" -> \"model\".\n\t * See: {@link FileUtils.basename}\n\t */\n\tstatic basename(uri: string): string {\n\t\treturn FileUtils.basename(new URL(uri, NULL_DOMAIN).pathname);\n\t}\n\n\t/**\n\t * Extracts the extension from a URL, e.g. \"folder/model.glb\" -> \"glb\".\n\t * See: {@link FileUtils.extension}\n\t */\n\tstatic extension(uri: string): string {\n\t\treturn FileUtils.extension(new URL(uri, NULL_DOMAIN).pathname);\n\t}\n\n\tstatic resolve(base: string, path: string): string {\n\t\tif (!this.isRelativePath(path)) return path;\n\n\t\tconst stack = base.split('/');\n\t\tconst parts = path.split('/');\n\t\tstack.pop();\n\t\tfor (let i = 0; i < parts.length; i++) {\n\t\t\tif (parts[i] === '.') continue;\n\t\t\tif (parts[i] === '..') {\n\t\t\t\tstack.pop();\n\t\t\t} else {\n\t\t\t\tstack.push(parts[i]);\n\t\t\t}\n\t\t}\n\t\treturn stack.join('/');\n\t}\n\n\t/**\n\t * Returns true for URLs containing a protocol, and false for both\n\t * absolute and relative paths.\n\t */\n\tstatic isAbsoluteURL(path: string): boolean {\n\t\treturn this.PROTOCOL_REGEXP.test(path);\n\t}\n\n\t/**\n\t * Returns true for paths that are declared relative to some unknown base\n\t * path. For example, \"foo/bar/\" is relative both \"/foo/bar/\" is not.\n\t */\n\tstatic isRelativePath(path: string): boolean {\n\t\treturn !/^(?:[a-zA-Z]+:)?\\//.test(path);\n\t}\n}\n", "// Reference: https://github.com/jonschlinkert/is-plain-object\n\nfunction isObject(o: unknown): o is object {\n\treturn Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport function isPlainObject(o: unknown): o is object {\n\tif (isObject(o) === false) return false;\n\n\t// If has modified constructor\n\tconst ctor = o.constructor;\n\tif (ctor === undefined) return true;\n\n\t// If has modified prototype\n\tconst prot = ctor.prototype;\n\tif (isObject(prot) === false) return false;\n\n\t// If constructor does not have an Object-specific method\n\tif (Object.hasOwn(prot, 'isPrototypeOf') === false) {\n\t\treturn false;\n\t}\n\n\t// Most likely a plain Object\n\treturn true;\n}\n", "/** Logger verbosity thresholds. */\nexport enum Verbosity {\n\t/** No events are logged. */\n\tSILENT = 4,\n\n\t/** Only error events are logged. */\n\tERROR = 3,\n\n\t/** Only error and warn events are logged. */\n\tWARN = 2,\n\n\t/** Only error, warn, and info events are logged. (DEFAULT) */\n\tINFO = 1,\n\n\t/** All events are logged. */\n\tDEBUG = 0,\n}\n\nexport interface ILogger {\n\tdebug(text: string): void;\n\tinfo(text: string): void;\n\twarn(text: string): void;\n\terror(text: string): void;\n}\n\n/**\n * *Logger utility class.*\n *\n * @category Utilities\n */\nexport class Logger implements ILogger {\n\t/** Logger verbosity thresholds. */\n\tstatic Verbosity: typeof Verbosity = Verbosity;\n\n\t/** Default logger instance. */\n\tpublic static DEFAULT_INSTANCE: Logger = new Logger(Logger.Verbosity.INFO);\n\n\t/** Constructs a new Logger instance. */\n\tconstructor(private readonly verbosity: number) {}\n\n\t/** Logs an event at level {@link Logger.Verbosity.DEBUG}. */\n\tdebug(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.DEBUG) {\n\t\t\tconsole.debug(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.INFO}. */\n\tinfo(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.INFO) {\n\t\t\tconsole.info(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.WARN}. */\n\twarn(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.WARN) {\n\t\t\tconsole.warn(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.ERROR}. */\n\terror(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.ERROR) {\n\t\t\tconsole.error(text);\n\t\t}\n\t}\n}\n", "import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;", "import { determinant, getRotation } from 'gl-matrix/mat4';\nimport { length } from 'gl-matrix/vec3';\nimport type { mat4, vec3, vec4 } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\n\n/** @hidden */\nexport class MathUtils {\n\tpublic static identity(v: number): number {\n\t\treturn v;\n\t}\n\n\tpublic static eq(a: number[], b: number[], tolerance = 10e-6): boolean {\n\t\tif (a.length !== b.length) return false;\n\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (Math.abs(a[i] - b[i]) > tolerance) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic static clamp(value: number, min: number, max: number): number {\n\t\tif (value < min) return min;\n\t\tif (value > max) return max;\n\t\treturn value;\n\t}\n\n\t// TODO(perf): Compare performance if we replace the switch with individual functions.\n\tpublic static decodeNormalizedInt(i: number, componentType: GLTF.AccessorComponentType): number {\n\t\t// Hardcode enums from accessor.ts to avoid a circular dependency.\n\t\tswitch (componentType) {\n\t\t\tcase 5126: // FLOAT\n\t\t\t\treturn i;\n\t\t\tcase 5123: // UNSIGNED_SHORT\n\t\t\t\treturn i / 65535.0;\n\t\t\tcase 5121: // UNSIGNED_BYTE\n\t\t\t\treturn i / 255.0;\n\t\t\tcase 5122: // SHORT\n\t\t\t\treturn Math.max(i / 32767.0, -1.0);\n\t\t\tcase 5120: // BYTE\n\t\t\t\treturn Math.max(i / 127.0, -1.0);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid component type.');\n\t\t}\n\t}\n\n\t// TODO(perf): Compare performance if we replace the switch with individual functions.\n\tpublic static encodeNormalizedInt(f: number, componentType: GLTF.AccessorComponentType): number {\n\t\t// Hardcode enums from accessor.ts to avoid a circular dependency.\n\t\tswitch (componentType) {\n\t\t\tcase 5126: // FLOAT\n\t\t\t\treturn f;\n\t\t\tcase 5123: // UNSIGNED_SHORT\n\t\t\t\treturn Math.round(MathUtils.clamp(f, 0, 1) * 65535.0);\n\t\t\tcase 5121: // UNSIGNED_BYTE\n\t\t\t\treturn Math.round(MathUtils.clamp(f, 0, 1) * 255.0);\n\t\t\tcase 5122: // SHORT\n\t\t\t\treturn Math.round(MathUtils.clamp(f, -1, 1) * 32767.0);\n\t\t\tcase 5120: // BYTE\n\t\t\t\treturn Math.round(MathUtils.clamp(f, -1, 1) * 127.0);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid component type.');\n\t\t}\n\t}\n\n\t/**\n\t * Decompose a mat4 to TRS properties.\n\t *\n\t * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n\t * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n\t *\n\t * @param srcMat Matrix element, to be decomposed to TRS properties.\n\t * @param dstTranslation Translation element, to be overwritten.\n\t * @param dstRotation Rotation element, to be overwritten.\n\t * @param dstScale Scale element, to be overwritten.\n\t */\n\tpublic static decompose(srcMat: mat4, dstTranslation: vec3, dstRotation: vec4, dstScale: vec3): void {\n\t\tlet sx = length([srcMat[0], srcMat[1], srcMat[2]]);\n\t\tconst sy = length([srcMat[4], srcMat[5], srcMat[6]]);\n\t\tconst sz = length([srcMat[8], srcMat[9], srcMat[10]]);\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = determinant(srcMat);\n\t\tif (det < 0) sx = -sx;\n\n\t\tdstTranslation[0] = srcMat[12];\n\t\tdstTranslation[1] = srcMat[13];\n\t\tdstTranslation[2] = srcMat[14];\n\n\t\t// scale the rotation part\n\t\tconst _m1 = srcMat.slice();\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1[0] *= invSX;\n\t\t_m1[1] *= invSX;\n\t\t_m1[2] *= invSX;\n\n\t\t_m1[4] *= invSY;\n\t\t_m1[5] *= invSY;\n\t\t_m1[6] *= invSY;\n\n\t\t_m1[8] *= invSZ;\n\t\t_m1[9] *= invSZ;\n\t\t_m1[10] *= invSZ;\n\n\t\tgetRotation(dstRotation, _m1 as mat4);\n\n\t\tdstScale[0] = sx;\n\t\tdstScale[1] = sy;\n\t\tdstScale[2] = sz;\n\t}\n\n\t/**\n\t * Compose TRS properties to a mat4.\n\t *\n\t * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n\t * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n\t *\n\t * @param srcTranslation Translation element of matrix.\n\t * @param srcRotation Rotation element of matrix.\n\t * @param srcScale Scale element of matrix.\n\t * @param dstMat Matrix element, to be modified and returned.\n\t * @returns dstMat, overwritten to mat4 equivalent of given TRS properties.\n\t */\n\tpublic static compose(srcTranslation: vec3, srcRotation: vec4, srcScale: vec3, dstMat: mat4): mat4 {\n\t\tconst te = dstMat;\n\n\t\tconst x = srcRotation[0],\n\t\t\ty = srcRotation[1],\n\t\t\tz = srcRotation[2],\n\t\t\tw = srcRotation[3];\n\t\tconst x2 = x + x,\n\t\t\ty2 = y + y,\n\t\t\tz2 = z + z;\n\t\tconst xx = x * x2,\n\t\t\txy = x * y2,\n\t\t\txz = x * z2;\n\t\tconst yy = y * y2,\n\t\t\tyz = y * z2,\n\t\t\tzz = z * z2;\n\t\tconst wx = w * x2,\n\t\t\twy = w * y2,\n\t\t\twz = w * z2;\n\n\t\tconst sx = srcScale[0],\n\t\t\tsy = srcScale[1],\n\t\t\tsz = srcScale[2];\n\n\t\tte[0] = (1 - (yy + zz)) * sx;\n\t\tte[1] = (xy + wz) * sx;\n\t\tte[2] = (xz - wy) * sx;\n\t\tte[3] = 0;\n\n\t\tte[4] = (xy - wz) * sy;\n\t\tte[5] = (1 - (xx + zz)) * sy;\n\t\tte[6] = (yz + wx) * sy;\n\t\tte[7] = 0;\n\n\t\tte[8] = (xz + wy) * sz;\n\t\tte[9] = (yz - wx) * sz;\n\t\tte[10] = (1 - (xx + yy)) * sz;\n\t\tte[11] = 0;\n\n\t\tte[12] = srcTranslation[0];\n\t\tte[13] = srcTranslation[1];\n\t\tte[14] = srcTranslation[2];\n\t\tte[15] = 1;\n\n\t\treturn te;\n\t}\n}\n", "import type { Ref, RefList, RefMap, RefSet } from 'property-graph';\nimport type { BufferViewUsage } from '../constants.js';\nimport type { Property } from '../properties/index.js';\nimport { isPlainObject } from './is-plain-object.js';\n\nexport type UnknownRef = Ref<Property> | RefList<Property> | RefSet<Property> | RefMap<Property>;\n\nexport function equalsRef(refA: Ref<Property>, refB: Ref<Property>): boolean {\n\tif (!!refA !== !!refB) return false;\n\n\tconst a = refA.getChild()!;\n\tconst b = refB.getChild()!;\n\n\treturn a === b || a.equals(b);\n}\n\nexport function equalsRefSet<\n\tA extends RefList<Property> | RefSet<Property>,\n\tB extends RefList<Property> | RefSet<Property>,\n>(refSetA: A, refSetB: B): boolean {\n\tif (!!refSetA !== !!refSetB) return false;\n\tconst refValuesA = refSetA.values();\n\tconst refValuesB = refSetB.values();\n\tif (refValuesA.length !== refValuesB.length) return false;\n\n\tfor (let i = 0; i < refValuesA.length; i++) {\n\t\tconst a = refValuesA[i];\n\t\tconst b = refValuesB[i];\n\n\t\tif (a.getChild() === b.getChild()) continue;\n\n\t\tif (!a.getChild().equals(b.getChild())) return false;\n\t}\n\n\treturn true;\n}\n\nexport function equalsRefMap(refMapA: RefMap<Property>, refMapB: RefMap<Property>): boolean {\n\tif (!!refMapA !== !!refMapB) return false;\n\n\tconst keysA = refMapA.keys();\n\tconst keysB = refMapB.keys();\n\tif (keysA.length !== keysB.length) return false;\n\n\tfor (const key of keysA) {\n\t\tconst refA = refMapA.get(key)!;\n\t\tconst refB = refMapB.get(key)!;\n\t\tif (!!refA !== !!refB) return false;\n\n\t\tconst a = refA.getChild();\n\t\tconst b = refB.getChild();\n\t\tif (a === b) continue;\n\n\t\tif (!a.equals(b)) return false;\n\t}\n\n\treturn true;\n}\n\nexport function equalsArray(a: ArrayLike<unknown> | null, b: ArrayLike<unknown> | null): boolean {\n\tif (a === b) return true;\n\n\tif (!!a !== !!b || !a || !b) return false;\n\n\tif (a.length !== b.length) return false;\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) return false;\n\t}\n\n\treturn true;\n}\n\nexport function equalsObject(_a: unknown, _b: unknown): boolean {\n\tif (_a === _b) return true;\n\tif (!!_a !== !!_b) return false;\n\tif (!isPlainObject(_a) || !isPlainObject(_b)) {\n\t\treturn _a === _b;\n\t}\n\n\tconst a = _a as Record<string, unknown>;\n\tconst b = _b as Record<string, unknown>;\n\n\tlet numKeysA = 0;\n\tlet numKeysB = 0;\n\n\tlet key: string;\n\n\tfor (key in a) numKeysA++;\n\tfor (key in b) numKeysB++;\n\tif (numKeysA !== numKeysB) return false;\n\n\tfor (key in a) {\n\t\tconst valueA = a[key];\n\t\tconst valueB = b[key];\n\t\tif (isArray(valueA) && isArray(valueB)) {\n\t\t\tif (!equalsArray(valueA as [], valueB as [])) return false;\n\t\t} else if (isPlainObject(valueA) && isPlainObject(valueB)) {\n\t\t\tif (!equalsObject(valueA, valueB)) return false;\n\t\t} else {\n\t\t\tif (valueA !== valueB) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport type RefAttributes = Record<string, unknown>;\n\nexport interface AccessorRefAttributes extends RefAttributes {\n\t/** Usage role of an accessor reference. */\n\tusage: BufferViewUsage | string;\n}\n\nexport interface TextureRefAttributes extends RefAttributes {\n\t/** Bitmask for {@link TextureChannel TextureChannels} used by a texture reference. */\n\tchannels: number;\n\t/**\n\t * Specifies that the texture contains color data (base color, emissive, …),\n\t * rather than non-color data (normal maps, metallic roughness, …). Used\n\t * when tuning texture compression settings.\n\t */\n\tisColor?: boolean;\n}\n\nexport function isArray(value: unknown): boolean {\n\treturn Array.isArray(value) || ArrayBuffer.isView(value);\n}\n", "const ALPHABET = '23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ';\nconst UNIQUE_RETRIES = 999;\nconst ID_LENGTH = 6;\n\nconst previousIDs = new Set();\n\nconst generateOne = function (): string {\n\tlet rtn = '';\n\tfor (let i = 0; i < ID_LENGTH; i++) {\n\t\trtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));\n\t}\n\treturn rtn;\n};\n\n/**\n * Short ID generator.\n *\n * Generated IDs are short, easy to type, and unique for the duration of the program's execution.\n * Uniqueness across multiple program executions, or on other devices, is not guaranteed. Based on\n * [Short ID Generation in JavaScript](https://tomspencer.dev/blog/2014/11/16/short-id-generation-in-javascript/),\n * with alterations.\n *\n * @category Utilities\n * @hidden\n */\nexport const uuid = function (): string {\n\tfor (let retries = 0; retries < UNIQUE_RETRIES; retries++) {\n\t\tconst id = generateOne();\n\t\tif (!previousIDs.has(id)) {\n\t\t\tpreviousIDs.add(id);\n\t\t\treturn id;\n\t\t}\n\t}\n\treturn '';\n};\n", "import {\n\t$attributes,\n\t$immutableKeys,\n\ttype Graph,\n\tGraphEdge,\n\tGraphNode,\n\ttype Literal,\n\ttype LiteralKeys,\n\ttype Ref,\n\tRefList,\n\tRefMap,\n\tRefSet,\n} from 'property-graph';\nimport type { Nullable } from '../constants.js';\nimport type { UnknownRef } from '../utils/index.js';\nimport {\n\tequalsArray,\n\tequalsObject,\n\tequalsRef,\n\tequalsRefMap,\n\tequalsRefSet,\n\tisArray,\n\tisPlainObject,\n} from '../utils/index.js';\n\nexport type PropertyResolver<T extends Property> = (p: T) => T;\nexport const COPY_IDENTITY = <T extends Property>(t: T): T => t;\n\nexport interface IProperty {\n\tname: string;\n\textras: Record<string, unknown>;\n}\n\nconst EMPTY_SET = new Set<string>();\n\n/**\n * *Properties represent distinct resources in a glTF asset, referenced by other properties.*\n *\n * For example, each material and texture is a property, with material properties holding\n * references to the textures. All properties are created with factory methods on the\n * {@link Document} in which they should be constructed. Properties are destroyed by calling\n * {@link Property.dispose}().\n *\n * Usage:\n *\n * ```ts\n * const texture = doc.createTexture('myTexture');\n * doc.listTextures(); // → [texture x 1]\n *\n * // Attach a texture to a material.\n * material.setBaseColorTexture(texture);\n * material.getBaseColortexture(); // → texture\n *\n * // Detaching a texture removes any references to it, except from the doc.\n * texture.detach();\n * material.getBaseColorTexture(); // → null\n * doc.listTextures(); // → [texture x 1]\n *\n * // Disposing a texture removes all references to it, and its own references.\n * texture.dispose();\n * doc.listTextures(); // → []\n * ```\n *\n * Reference:\n * - [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nexport abstract class Property<T extends IProperty = IProperty> extends GraphNode<T> {\n\t/** Property type. */\n\tpublic abstract readonly propertyType: string;\n\n\t/**\n\t * Internal graph used to search and maintain references.\n\t * @override\n\t * @hidden\n\t */\n\tprotected declare readonly graph: Graph<Property>;\n\n\t/** @hidden */\n\tconstructor(graph: Graph<Property>, name = '') {\n\t\tsuper(graph);\n\t\t(this as Property)[$attributes]['name'] = name;\n\t\tthis.init();\n\t\tthis.dispatchEvent({ type: 'create' });\n\t}\n\n\t/**\n\t * Initializes instance data for a subclass. Because subclass constructors run after the\n\t * constructor of the parent class, and 'create' events dispatched by the parent class\n\t * assume the instance is fully initialized, it's best to do any initialization here.\n\t * @hidden\n\t */\n\tprotected abstract init(): void;\n\n\t/**\n\t * Returns the Graph associated with this Property. For internal use.\n\t * @hidden\n\t * @experimental\n\t */\n\tpublic getGraph(): Graph<Property> {\n\t\treturn this.graph;\n\t}\n\n\t/**\n\t * Returns default attributes for the property. Empty lists and maps should be initialized\n\t * to empty arrays and objects. Always invoke `super.getDefaults()` and extend the result.\n\t */\n\tprotected getDefaults(): Nullable<T> {\n\t\treturn Object.assign(super.getDefaults(), { name: '', extras: {} });\n\t}\n\n\t/** @hidden */\n\tprotected set<K extends LiteralKeys<T>>(attribute: K, value: T[K]): this {\n\t\tif (Array.isArray(value)) value = value.slice() as T[K]; // copy vector, quat, color …\n\t\treturn super.set(attribute, value);\n\t}\n\n\t/**********************************************************************************************\n\t * Name.\n\t */\n\n\t/**\n\t * Returns the name of this property. While names are not required to be unique, this is\n\t * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n\t * a property, prefer to use Extras.\n\t */\n\tpublic getName(): string {\n\t\treturn (this as Property).get('name');\n\t}\n\n\t/**\n\t * Sets the name of this property. While names are not required to be unique, this is\n\t * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n\t * a property, prefer to use Extras.\n\t */\n\tpublic setName(name: string): this {\n\t\treturn (this as Property).set('name', name) as this;\n\t}\n\n\t/**********************************************************************************************\n\t * Extras.\n\t */\n\n\t/**\n\t * Returns a reference to the Extras object, containing application-specific data for this\n\t * Property. Extras should be an Object, not a primitive value, for best portability.\n\t */\n\tpublic getExtras(): Record<string, unknown> {\n\t\treturn (this as Property).get('extras');\n\t}\n\n\t/**\n\t * Updates the Extras object, containing application-specific data for this Property. Extras\n\t * should be an Object, not a primitive value, for best portability.\n\t */\n\tpublic setExtras(extras: Record<string, unknown>): this {\n\t\treturn (this as Property).set('extras', extras) as this;\n\t}\n\n\t/**********************************************************************************************\n\t * Graph state.\n\t */\n\n\t/**\n\t * Makes a copy of this property, with the same resources (by reference) as the original.\n\t */\n\tpublic clone(): this {\n\t\tconst PropertyClass = this.constructor as new (g: Graph<Property>) => this;\n\t\treturn new PropertyClass(this.graph).copy(this, COPY_IDENTITY);\n\t}\n\n\t/**\n\t * Copies all data from another property to this one. Child properties are copied by reference,\n\t * unless a 'resolve' function is given to override that.\n\t * @param other Property to copy references from.\n\t * @param resolve Function to resolve each Property being transferred. Default is identity.\n\t */\n\tpublic copy(other: this, resolve: PropertyResolver<Property> = COPY_IDENTITY): this {\n\t\t// Remove previous references.\n\t\tfor (const key in this[$attributes]) {\n\t\t\tconst value = this[$attributes][key] as GraphEdge<Property, Property> | RefList | RefSet | RefMap;\n\t\t\tif (value instanceof GraphEdge) {\n\t\t\t\tif (!this[$immutableKeys].has(key)) {\n\t\t\t\t\tvalue.dispose();\n\t\t\t\t}\n\t\t\t} else if (value instanceof RefList || value instanceof RefSet) {\n\t\t\t\tfor (const ref of value.values()) {\n\t\t\t\t\tref.dispose();\n\t\t\t\t}\n\t\t\t} else if (value instanceof RefMap) {\n\t\t\t\tfor (const ref of value.values()) {\n\t\t\t\t\tref.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add new references.\n\t\tfor (const key in other[$attributes]) {\n\t\t\tconst thisValue = this[$attributes][key];\n\t\t\tconst otherValue = other[$attributes][key];\n\t\t\tif (otherValue instanceof GraphEdge) {\n\t\t\t\tif (this[$immutableKeys].has(key)) {\n\t\t\t\t\tconst ref = thisValue as unknown as Ref<Property>;\n\t\t\t\t\tref.getChild().copy(resolve(otherValue.getChild()), resolve);\n\t\t\t\t} else {\n\t\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: TODO\n\t\t\t\t\tthis.setRef(key as any, resolve(otherValue.getChild()), otherValue.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (otherValue instanceof RefSet || otherValue instanceof RefList) {\n\t\t\t\tfor (const ref of otherValue.values()) {\n\t\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: TODO\n\t\t\t\t\tthis.addRef(key as any, resolve(ref.getChild()) as any, ref.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (otherValue instanceof RefMap) {\n\t\t\t\tfor (const subkey of otherValue.keys()) {\n\t\t\t\t\tconst ref = otherValue.get(subkey)!;\n\t\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: TODO\n\t\t\t\t\tthis.setRefMap(key as any, subkey, resolve(ref.getChild()) as any, ref.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (isPlainObject(otherValue)) {\n\t\t\t\tthis[$attributes][key] = JSON.parse(JSON.stringify(otherValue));\n\t\t\t} else if (\n\t\t\t\tArray.isArray(otherValue) ||\n\t\t\t\totherValue instanceof ArrayBuffer ||\n\t\t\t\tArrayBuffer.isView(otherValue)\n\t\t\t) {\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: TODO\n\t\t\t\tthis[$attributes][key] = (otherValue as unknown as Uint8Array).slice() as any;\n\t\t\t} else {\n\t\t\t\tthis[$attributes][key] = otherValue;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns true if two properties are deeply equivalent, recursively comparing the attributes\n\t * of the properties. Optionally, a 'skip' set may be included, specifying attributes whose\n\t * values should not be considered in the comparison.\n\t *\n\t * Example: Two {@link Primitive Primitives} are equivalent if they have accessors and\n\t * materials with equivalent content — but not necessarily the same specific accessors\n\t * and materials.\n\t */\n\tpublic equals(other: this, skip: Set<string> = EMPTY_SET): boolean {\n\t\tif (this === other) return true;\n\t\tif (this.propertyType !== other.propertyType) return false;\n\n\t\tfor (const key in this[$attributes]) {\n\t\t\tif (skip.has(key)) continue;\n\n\t\t\tconst a = this[$attributes][key] as UnknownRef | Literal;\n\t\t\tconst b = other[$attributes][key] as UnknownRef | Literal;\n\n\t\t\tif (a instanceof GraphEdge || b instanceof GraphEdge) {\n\t\t\t\tif (!equalsRef(a as Ref<Property>, b as Ref<Property>)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (a instanceof RefSet || b instanceof RefSet || a instanceof RefList || b instanceof RefList) {\n\t\t\t\tif (!equalsRefSet(a as RefSet<Property>, b as RefSet<Property>)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (a instanceof RefMap || b instanceof RefMap) {\n\t\t\t\tif (!equalsRefMap(a as RefMap<Property>, b as RefMap<Property>)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (isPlainObject(a) || isPlainObject(b)) {\n\t\t\t\tif (!equalsObject(a, b)) return false;\n\t\t\t} else if (isArray(a) || isArray(b)) {\n\t\t\t\tif (!equalsArray(a as unknown as [], b as unknown as [])) return false;\n\t\t\t} else {\n\t\t\t\t// Literal.\n\t\t\t\tif (a !== b) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic detach(): this {\n\t\t// Detaching should keep properties in the same Document, and attached to its root.\n\t\tthis.graph.disconnectParents(this, (n: Property) => n.propertyType !== 'Root');\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a list of all properties that hold a reference to this property. For example, a\n\t * material may hold references to various textures, but a texture does not hold references\n\t * to the materials that use it.\n\t *\n\t * It is often necessary to filter the results for a particular type: some resources, like\n\t * {@link Accessor}s, may be referenced by different types of properties. Most properties\n\t * include the {@link Root} as a parent, which is usually not of interest.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * const materials = texture\n\t * \t.listParents()\n\t * \t.filter((p) => p instanceof Material)\n\t * ```\n\t */\n\tpublic listParents(): Property[] {\n\t\treturn this.graph.listParents(this);\n\t}\n}\n", "import { RefMap } from 'property-graph';\nimport type { Nullable } from '../constants.js';\nimport type { ExtensionProperty } from './extension-property.js';\nimport { type IProperty, Property } from './property.js';\n\nexport interface IExtensibleProperty extends IProperty {\n\textensions: RefMap<ExtensionProperty>;\n}\n\n/**\n * *A {@link Property} that can have {@link ExtensionProperty} instances attached.*\n *\n * Most properties are extensible. See the {@link Extension} documentation for information about\n * how to use extensions.\n *\n * @category Properties\n */\nexport abstract class ExtensibleProperty<T extends IExtensibleProperty = IExtensibleProperty> extends Property<T> {\n\tprotected getDefaults(): Nullable<T> {\n\t\treturn Object.assign(super.getDefaults(), { extensions: new RefMap<ExtensionProperty>() });\n\t}\n\n\t/** Returns an {@link ExtensionProperty} attached to this Property, if any. */\n\tpublic getExtension<Prop extends ExtensionProperty>(name: string): Prop | null {\n\t\treturn (this as ExtensibleProperty).getRefMap('extensions', name) as Prop;\n\t}\n\n\t/**\n\t * Attaches the given {@link ExtensionProperty} to this Property. For a given extension, only\n\t * one ExtensionProperty may be attached to any one Property at a time.\n\t */\n\tpublic setExtension<Prop extends ExtensionProperty>(name: string, extensionProperty: Prop | null): this {\n\t\tif (extensionProperty) extensionProperty._validateParent(this as ExtensibleProperty);\n\t\treturn (this as ExtensibleProperty).setRefMap('extensions', name, extensionProperty) as this;\n\t}\n\n\t/** Lists all {@link ExtensionProperty} instances attached to this Property. */\n\tpublic listExtensions(): ExtensionProperty[] {\n\t\treturn (this as ExtensibleProperty).listRefMapValues('extensions');\n\t}\n}\n", "import { type Nullable, PropertyType, type TypedArray } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { MathUtils } from '../utils/index.js';\nimport type { Buffer } from './buffer.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\n\ninterface IAccessor extends IExtensibleProperty {\n\tarray: TypedArray | null;\n\ttype: GLTF.AccessorType;\n\tcomponentType: GLTF.AccessorComponentType;\n\tnormalized: boolean;\n\tsparse: boolean;\n\tbuffer: Buffer;\n}\n\n/**\n * *Accessors store lists of numeric, vector, or matrix elements in a typed array.*\n *\n * All large data for {@link Mesh}, {@link Skin}, and {@link Animation} properties is stored in\n * {@link Accessor}s, organized into one or more {@link Buffer}s. Each accessor provides data in\n * typed arrays, with two abstractions:\n *\n * *Elements* are the logical divisions of the data into useful types: `\"SCALAR\"`, `\"VEC2\"`,\n * `\"VEC3\"`, `\"VEC4\"`, `\"MAT3\"`, or `\"MAT4\"`. The element type can be determined with the\n * {@link Accessor.getType getType}() method, and the number of elements in the accessor determine its\n * {@link Accessor.getCount getCount}(). The number of components in an element — e.g. 9 for `\"MAT3\"` — are its\n * {@link Accessor.getElementSize getElementSize}(). See {@link Accessor.Type}.\n *\n * *Components* are the numeric values within an element — e.g. `.x` and `.y` for `\"VEC2\"`. Various\n * component types are available: `BYTE`, `UNSIGNED_BYTE`, `SHORT`, `UNSIGNED_SHORT`,\n * `UNSIGNED_INT`, and `FLOAT`. The component type can be determined with the\n * {@link Accessor.getComponentType getComponentType} method, and the number of bytes in each component determine its\n * {@link Accessor.getComponentSize getComponentSize}. See {@link Accessor.ComponentType}.\n *\n * Usage:\n *\n * ```typescript\n * const accessor = doc.createAccessor('myData')\n * \t.setArray(new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]))\n * \t.setType(Accessor.Type.VEC3)\n * \t.setBuffer(doc.getRoot().listBuffers()[0]);\n *\n * accessor.getCount();        // → 4\n * accessor.getElementSize();  // → 3\n * accessor.getByteLength();   // → 48\n * accessor.getElement(1, []); // → [4, 5, 6]\n *\n * accessor.setElement(0, [10, 20, 30]);\n * ```\n *\n * Data access through the {@link Accessor.getElement getElement} and {@link Accessor.setElement setElement}\n * methods reads or overwrites the content of the underlying typed array. These methods use\n * element arrays intended to be compatible with the [gl-matrix](https://github.com/toji/gl-matrix)\n * library, or with the `toArray`/`fromArray` methods of libraries like three.js and babylon.js.\n *\n * Each Accessor must be assigned to a {@link Buffer}, which determines where the accessor's data\n * is stored in the final file. Assigning Accessors to different Buffers allows the data to be\n * written to different `.bin` files.\n *\n * glTF Transform does not expose many details of sparse, normalized, or interleaved accessors\n * through its API. It reads files using those techniques, presents a simplified view of the data\n * for editing, and attempts to write data back out with optimizations. For example, vertex\n * attributes will typically be interleaved by default, regardless of the input file.\n *\n * References:\n * - [glTF → Accessors](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nexport class Accessor extends ExtensibleProperty<IAccessor> {\n\tpublic declare propertyType: PropertyType.ACCESSOR;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Element type contained by the accessor (SCALAR, VEC2, ...). */\n\tpublic static Type: Record<string, GLTF.AccessorType> = {\n\t\t/** Scalar, having 1 value per element. */\n\t\tSCALAR: 'SCALAR',\n\t\t/** 2-component vector, having 2 components per element. */\n\t\tVEC2: 'VEC2',\n\t\t/** 3-component vector, having 3 components per element. */\n\t\tVEC3: 'VEC3',\n\t\t/** 4-component vector, having 4 components per element. */\n\t\tVEC4: 'VEC4',\n\t\t/** 2x2 matrix, having 4 components per element. */\n\t\tMAT2: 'MAT2',\n\t\t/** 3x3 matrix, having 9 components per element. */\n\t\tMAT3: 'MAT3',\n\t\t/** 4x3 matrix, having 16 components per element. */\n\t\tMAT4: 'MAT4',\n\t};\n\n\t/** Data type of the values composing each element in the accessor. */\n\tpublic static ComponentType: Record<string, GLTF.AccessorComponentType> = {\n\t\t/**\n\t\t * 1-byte signed integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array Int8Array}.\n\t\t */\n\t\tBYTE: 5120,\n\t\t/**\n\t\t * 1-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array Uint8Array}.\n\t\t */\n\t\tUNSIGNED_BYTE: 5121,\n\t\t/**\n\t\t * 2-byte signed integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array Int16Array}.\n\t\t */\n\t\tSHORT: 5122,\n\t\t/**\n\t\t * 2-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.\n\t\t */\n\t\tUNSIGNED_SHORT: 5123,\n\t\t/**\n\t\t * 4-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array Uint32Array}.\n\t\t */\n\t\tUNSIGNED_INT: 5125,\n\t\t/**\n\t\t * 4-byte floating point number, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array Float32Array}.\n\t\t */\n\t\tFLOAT: 5126,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ACCESSOR;\n\t}\n\n\tprotected getDefaults(): Nullable<IAccessor> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tarray: null,\n\t\t\ttype: Accessor.Type.SCALAR,\n\t\t\tcomponentType: Accessor.ComponentType.FLOAT,\n\t\t\tnormalized: false,\n\t\t\tsparse: false,\n\t\t\tbuffer: null,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Static.\n\t */\n\n\t/** Returns size of a given element type, in components. */\n\tpublic static getElementSize(type: GLTF.AccessorType): number {\n\t\tswitch (type) {\n\t\t\tcase Accessor.Type.SCALAR:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.Type.VEC2:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.Type.VEC3:\n\t\t\t\treturn 3;\n\t\t\tcase Accessor.Type.VEC4:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.Type.MAT2:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.Type.MAT3:\n\t\t\t\treturn 9;\n\t\t\tcase Accessor.Type.MAT4:\n\t\t\t\treturn 16;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unexpected type: ' + type);\n\t\t}\n\t}\n\n\t/** Returns size of a given component type, in bytes. */\n\tpublic static getComponentSize(componentType: GLTF.AccessorComponentType): number {\n\t\tswitch (componentType) {\n\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\treturn 4;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unexpected component type: ' + componentType);\n\t\t}\n\t}\n\n\t/**********************************************************************************************\n\t * Min/max bounds.\n\t */\n\n\t/**\n\t * Minimum value of each component in this attribute. Unlike in a final glTF file, values\n\t * returned by this method will reflect the minimum accounting for {@link .normalized}\n\t * state.\n\t */\n\tpublic getMinNormalized(target: number[]): number[] {\n\t\tconst normalized = this.getNormalized();\n\t\tconst elementSize = this.getElementSize();\n\t\tconst componentType = this.getComponentType();\n\n\t\tthis.getMin(target);\n\n\t\tif (normalized) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\ttarget[j] = MathUtils.decodeNormalizedInt(target[j], componentType);\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Minimum value of each component in this attribute. Values returned by this method do not\n\t * reflect normalization: use {@link .getMinNormalized} in that case.\n\t */\n\tpublic getMin(target: number[]): number[] {\n\t\tconst array = this.getArray()!;\n\t\tconst count = this.getCount();\n\t\tconst elementSize = this.getElementSize();\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = Infinity;\n\n\t\tfor (let i = 0; i < count * elementSize; i += elementSize) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\tconst value = array[i + j];\n\t\t\t\tif (Number.isFinite(value)) {\n\t\t\t\t\ttarget[j] = Math.min(target[j], value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Maximum value of each component in this attribute. Unlike in a final glTF file, values\n\t * returned by this method will reflect the minimum accounting for {@link .normalized}\n\t * state.\n\t */\n\tpublic getMaxNormalized(target: number[]): number[] {\n\t\tconst normalized = this.getNormalized();\n\t\tconst elementSize = this.getElementSize();\n\t\tconst componentType = this.getComponentType();\n\n\t\tthis.getMax(target);\n\n\t\tif (normalized) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\ttarget[j] = MathUtils.decodeNormalizedInt(target[j], componentType);\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Maximum value of each component in this attribute. Values returned by this method do not\n\t * reflect normalization: use {@link .getMinNormalized} in that case.\n\t */\n\tpublic getMax(target: number[]): number[] {\n\t\tconst array = this.get('array');\n\t\tconst count = this.getCount();\n\t\tconst elementSize = this.getElementSize();\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = -Infinity;\n\n\t\tfor (let i = 0; i < count * elementSize; i += elementSize) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\tconst value = array![i + j];\n\t\t\t\tif (Number.isFinite(value)) {\n\t\t\t\t\ttarget[j] = Math.max(target[j], value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**********************************************************************************************\n\t * Layout.\n\t */\n\n\t/**\n\t * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,\n\t * will have a count of 10.\n\t */\n\tpublic getCount(): number {\n\t\tconst array = this.get('array');\n\t\treturn array ? array.length / this.getElementSize() : 0;\n\t}\n\n\t/** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */\n\tpublic getType(): GLTF.AccessorType {\n\t\treturn this.get('type');\n\t}\n\n\t/**\n\t * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a\n\t * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.\n\t */\n\tpublic setType(type: GLTF.AccessorType): Accessor {\n\t\treturn this.set('type', type);\n\t}\n\n\t/**\n\t * Number of components in each element of the accessor. For example, the element size of a\n\t * `VEC2` accessor is 2. This value is determined automatically based on array length and\n\t * accessor type, specified with {@link Accessor.setType setType()}.\n\t */\n\t// biome-ignore lint/suspicious/useAdjacentOverloadSignatures: Static vs. non-static.\n\tpublic getElementSize(): number {\n\t\treturn Accessor.getElementSize(this.get('type'));\n\t}\n\n\t/**\n\t * Size of each component (a value in the raw array), in bytes. For example, the\n\t * `componentSize` of data backed by a `float32` array is 4 bytes.\n\t */\n\tpublic getComponentSize(): number {\n\t\treturn this.get('array')!.BYTES_PER_ELEMENT;\n\t}\n\n\t/**\n\t * Component type (float32, uint16, etc.). This value is determined automatically, and can only\n\t * be modified by replacing the underlying array.\n\t */\n\tpublic getComponentType(): GLTF.AccessorComponentType {\n\t\treturn this.get('componentType');\n\t}\n\n\t/**********************************************************************************************\n\t * Normalization.\n\t */\n\n\t/**\n\t * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n\t * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n\t * This property is defined only for accessors that contain vertex attributes or animation\n\t * output data.\n\t */\n\tpublic getNormalized(): boolean {\n\t\treturn this.get('normalized');\n\t}\n\n\t/**\n\t * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n\t * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n\t * This property is defined only for accessors that contain vertex attributes or animation\n\t * output data.\n\t */\n\tpublic setNormalized(normalized: boolean): this {\n\t\treturn this.set('normalized', normalized);\n\t}\n\n\t/**********************************************************************************************\n\t * Data access.\n\t */\n\n\t/**\n\t * Returns the scalar element value at the given index. For\n\t * {@link Accessor.getNormalized normalized} integer accessors, values are\n\t * decoded and returned in floating-point form.\n\t */\n\tpublic getScalar(index: number): number {\n\t\tconst elementSize = this.getElementSize();\n\t\tconst componentType = this.getComponentType();\n\t\tconst array = this.getArray()!;\n\n\t\tif (this.getNormalized()) {\n\t\t\treturn MathUtils.decodeNormalizedInt(array[index * elementSize], componentType);\n\t\t}\n\n\t\treturn array[index * elementSize];\n\t}\n\n\t/**\n\t * Assigns the scalar element value at the given index. For\n\t * {@link Accessor.getNormalized normalized} integer accessors, \"value\" should be\n\t * given in floating-point form — it will be integer-encoded before writing\n\t * to the underlying array.\n\t */\n\tpublic setScalar(index: number, x: number): this {\n\t\tconst elementSize = this.getElementSize();\n\t\tconst componentType = this.getComponentType();\n\t\tconst array = this.getArray()!;\n\n\t\tif (this.getNormalized()) {\n\t\t\tarray[index * elementSize] = MathUtils.encodeNormalizedInt(x, componentType);\n\t\t} else {\n\t\t\tarray[index * elementSize] = x;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the vector or matrix element value at the given index. For\n\t * {@link Accessor.getNormalized normalized} integer accessors, values are\n\t * decoded and returned in floating-point form.\n\t *\n\t * Example:\n\t *\n\t * ```javascript\n\t * import { add } from 'gl-matrix/add';\n\t *\n\t * const element = [];\n\t * const offset = [1, 1, 1];\n\t *\n\t * for (let i = 0; i < accessor.getCount(); i++) {\n\t * \taccessor.getElement(i, element);\n\t * \tadd(element, element, offset);\n\t * \taccessor.setElement(i, element);\n\t * }\n\t * ```\n\t */\n\tpublic getElement<T extends number[]>(index: number, target: T): T {\n\t\tconst normalized = this.getNormalized();\n\t\tconst elementSize = this.getElementSize();\n\t\tconst componentType = this.getComponentType();\n\t\tconst array = this.getArray()!;\n\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tif (normalized) {\n\t\t\t\ttarget[i] = MathUtils.decodeNormalizedInt(array[index * elementSize + i], componentType);\n\t\t\t} else {\n\t\t\t\ttarget[i] = array[index * elementSize + i];\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Assigns the vector or matrix element value at the given index. For\n\t * {@link Accessor.getNormalized normalized} integer accessors, \"value\" should be\n\t * given in floating-point form — it will be integer-encoded before writing\n\t * to the underlying array.\n\t *\n\t * Example:\n\t *\n\t * ```javascript\n\t * import { add } from 'gl-matrix/add';\n\t *\n\t * const element = [];\n\t * const offset = [1, 1, 1];\n\t *\n\t * for (let i = 0; i < accessor.getCount(); i++) {\n\t * \taccessor.getElement(i, element);\n\t * \tadd(element, element, offset);\n\t * \taccessor.setElement(i, element);\n\t * }\n\t * ```\n\t */\n\tpublic setElement(index: number, value: number[]): this {\n\t\tconst normalized = this.getNormalized();\n\t\tconst elementSize = this.getElementSize();\n\t\tconst componentType = this.getComponentType();\n\t\tconst array = this.getArray()!;\n\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tif (normalized) {\n\t\t\t\tarray[index * elementSize + i] = MathUtils.encodeNormalizedInt(value[i], componentType);\n\t\t\t} else {\n\t\t\t\tarray[index * elementSize + i] = value[i];\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Raw data storage.\n\t */\n\n\t/**\n\t * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse\n\t * accessors store only values that differ from base values. When loaded in glTF Transform (or most\n\t * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always\n\t * uses zeroes for the base values when writing files.\n\t * @experimental\n\t */\n\tpublic getSparse(): boolean {\n\t\treturn this.get('sparse');\n\t}\n\n\t/**\n\t * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse\n\t * accessors store only values that differ from base values. When loaded in glTF Transform (or most\n\t * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always\n\t * uses zeroes for the base values when writing files.\n\t * @experimental\n\t */\n\tpublic setSparse(sparse: boolean): this {\n\t\treturn this.set('sparse', sparse);\n\t}\n\n\t/** Returns the {@link Buffer} into which this accessor will be organized. */\n\tpublic getBuffer(): Buffer | null {\n\t\treturn this.getRef('buffer');\n\t}\n\n\t/** Assigns the {@link Buffer} into which this accessor will be organized. */\n\tpublic setBuffer(buffer: Buffer | null): this {\n\t\treturn this.setRef('buffer', buffer);\n\t}\n\n\t/** Returns the raw typed array underlying this accessor. */\n\tpublic getArray(): TypedArray | null {\n\t\treturn this.get('array');\n\t}\n\n\t/** Assigns the raw typed array underlying this accessor. */\n\tpublic setArray(array: TypedArray | null): this {\n\t\tthis.set('componentType', array ? arrayToComponentType(array) : Accessor.ComponentType.FLOAT);\n\t\tthis.set('array', array);\n\t\treturn this;\n\t}\n\n\t/** Returns the total bytelength of this accessor, exclusive of padding. */\n\tpublic getByteLength(): number {\n\t\tconst array = this.get('array');\n\t\treturn array ? array.byteLength : 0;\n\t}\n}\n\n/**************************************************************************************************\n * Accessor utilities.\n */\n\n/** @internal */\nfunction arrayToComponentType(array: TypedArray): GLTF.AccessorComponentType {\n\tswitch (array.constructor) {\n\t\tcase Float32Array:\n\t\t\treturn Accessor.ComponentType.FLOAT;\n\t\tcase Uint32Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_INT;\n\t\tcase Uint16Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_SHORT;\n\t\tcase Uint8Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_BYTE;\n\t\tcase Int16Array:\n\t\t\treturn Accessor.ComponentType.SHORT;\n\t\tcase Int8Array:\n\t\t\treturn Accessor.ComponentType.BYTE;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown accessor componentType.');\n\t}\n}\n", "import { RefSet } from 'property-graph';\nimport { type Nullable, PropertyType } from '../constants.js';\nimport type { AnimationChannel } from './animation-channel.js';\nimport type { AnimationSampler } from './animation-sampler.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\n\ninterface IAnimation extends IExtensibleProperty {\n\tchannels: RefSet<AnimationChannel>;\n\tsamplers: RefSet<AnimationSampler>;\n}\n\n/**\n * *Reusable collections of {@link AnimationChannel}s, together representing a discrete animation\n * clip.*\n *\n * One Animation represents one playable unit in an animation system. Each may contain channels\n * affecting multiple paths (`translation`, `rotation`, `scale`, or `weights`) on multiple\n * {@link Node}s. An Animation's channels must be played together, and do not have any meaning in\n * isolation.\n *\n * Multiple Animations _may_ be played together: for example, one character's _Walk_ animation\n * might play while another character's _Run_ animation plays. Or a single character might have\n * both an _Idle_ and a _Talk_ animation playing at the same time. However, glTF does not define\n * any particular relationship between top-level Animations, or any particular playback behavior\n * like looping or sequences of Animations. General-purpose viewers typically autoplay the first\n * animation and provide UI controls for choosing another. Game engines may have significantly\n * more advanced methods of playing and blending animations.\n *\n * For example, a very simple skinned {@link Mesh} might have two Animations, _Idle_ and _Walk_.\n * Each of those Animations might affect the rotations of two bones, _LegL_ and _LegR_, where the\n * keyframes for each target-path pair are stored in {@link AnimationChannel} instances. In  total,\n * this model would contain two Animations and Four {@link AnimationChannel}s.\n *\n * Usage:\n *\n * ```ts\n * const animation = doc.createAnimation('machineRun')\n * \t.addChannel(rotateCog1)\n * \t.addChannel(rotateCog2)\n * \t.addChannel(rotateCog3);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nexport class Animation extends ExtensibleProperty<IAnimation> {\n\tpublic declare propertyType: PropertyType.ANIMATION;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ANIMATION;\n\t}\n\n\tprotected getDefaults(): Nullable<IAnimation> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tchannels: new RefSet<AnimationChannel>(),\n\t\t\tsamplers: new RefSet<AnimationSampler>(),\n\t\t});\n\t}\n\n\t/** Adds an {@link AnimationChannel} to this Animation. */\n\tpublic addChannel(channel: AnimationChannel): this {\n\t\treturn this.addRef('channels', channel);\n\t}\n\n\t/** Removes an {@link AnimationChannel} from this Animation. */\n\tpublic removeChannel(channel: AnimationChannel): this {\n\t\treturn this.removeRef('channels', channel);\n\t}\n\n\t/** Lists {@link AnimationChannel}s in this Animation. */\n\tpublic listChannels(): AnimationChannel[] {\n\t\treturn this.listRefs('channels');\n\t}\n\n\t/** Adds an {@link AnimationSampler} to this Animation. */\n\tpublic addSampler(sampler: AnimationSampler): this {\n\t\treturn this.addRef('samplers', sampler);\n\t}\n\n\t/** Removes an {@link AnimationSampler} from this Animation. */\n\tpublic removeSampler(sampler: AnimationSampler): this {\n\t\treturn this.removeRef('samplers', sampler);\n\t}\n\n\t/** Lists {@link AnimationSampler}s in this Animation. */\n\tpublic listSamplers(): AnimationSampler[] {\n\t\treturn this.listRefs('samplers');\n\t}\n}\n", "import { type Nullable, PropertyType } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport type { AnimationSampler } from './animation-sampler.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\nimport type { Node } from './node.js';\n\ninterface IAnimationChannel extends IExtensibleProperty {\n\ttargetPath: GLTF.AnimationChannelTargetPath | null;\n\ttargetNode: Node;\n\tsampler: AnimationSampler;\n}\n\n/**\n * *A target-path pair within a larger {@link Animation}, which refers to an\n * {@link AnimationSampler} storing the keyframe data for that pair.*\n *\n * A _target_ is always a {@link Node}, in the core glTF spec. A _path_ is any property of that\n * Node that can be affected by animation: `translation`, `rotation`, `scale`, or `weights`. An\n * {@link Animation} affecting the positions and rotations of several {@link Node}s would contain\n * one channel for each Node-position or Node-rotation pair. The keyframe data for an\n * AnimationChannel is stored in an {@link AnimationSampler}, which must be attached to the same\n * {@link Animation}.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.getRoot()\n * \t.listNodes()\n * \t.find((node) => node.getName() === 'Cog');\n *\n * const channel = doc.createAnimationChannel('cogRotation')\n * \t.setTargetPath('rotation')\n * \t.setTargetNode(node)\n * \t.setSampler(rotateSampler);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nexport class AnimationChannel extends ExtensibleProperty<IAnimationChannel> {\n\tpublic declare propertyType: PropertyType.ANIMATION_CHANNEL;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Name of the property to be modified by an animation channel. */\n\tpublic static TargetPath: Record<string, GLTF.AnimationChannelTargetPath> = {\n\t\t/** Channel targets {@link Node.setTranslation}. */\n\t\tTRANSLATION: 'translation',\n\t\t/** Channel targets {@link Node.setRotation}. */\n\t\tROTATION: 'rotation',\n\t\t/** Channel targets {@link Node.setScale}. */\n\t\tSCALE: 'scale',\n\t\t/** Channel targets {@link Node.setWeights}, affecting {@link PrimitiveTarget} weights. */\n\t\tWEIGHTS: 'weights',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ANIMATION_CHANNEL;\n\t}\n\n\tprotected getDefaults(): Nullable<IAnimationChannel> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\ttargetPath: null,\n\t\t\ttargetNode: null,\n\t\t\tsampler: null,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Properties.\n\t */\n\n\t/**\n\t * Path (property) animated on the target {@link Node}. Supported values include:\n\t * `translation`, `rotation`, `scale`, or `weights`.\n\t */\n\tpublic getTargetPath(): GLTF.AnimationChannelTargetPath | null {\n\t\treturn this.get('targetPath');\n\t}\n\n\t/**\n\t * Path (property) animated on the target {@link Node}. Supported values include:\n\t * `translation`, `rotation`, `scale`, or `weights`.\n\t */\n\tpublic setTargetPath(targetPath: GLTF.AnimationChannelTargetPath): this {\n\t\treturn this.set('targetPath', targetPath);\n\t}\n\n\t/** Target {@link Node} animated by the channel. */\n\tpublic getTargetNode(): Node | null {\n\t\treturn this.getRef('targetNode');\n\t}\n\n\t/** Target {@link Node} animated by the channel. */\n\tpublic setTargetNode(targetNode: Node | null): this {\n\t\treturn this.setRef('targetNode', targetNode);\n\t}\n\n\t/**\n\t * Keyframe data input/output values for the channel. Must be attached to the same\n\t * {@link Animation}.\n\t */\n\tpublic getSampler(): AnimationSampler | null {\n\t\treturn this.getRef('sampler');\n\t}\n\n\t/**\n\t * Keyframe data input/output values for the channel. Must be attached to the same\n\t * {@link Animation}.\n\t */\n\tpublic setSampler(sampler: AnimationSampler | null): this {\n\t\treturn this.setRef('sampler', sampler);\n\t}\n}\n", "import { BufferViewUsage, type Nullable, PropertyType } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport type { Accessor } from './accessor.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\n\ninterface IAnimationSampler extends IExtensibleProperty {\n\tinterpolation: GLTF.AnimationSamplerInterpolation;\n\tinput: Accessor;\n\toutput: Accessor;\n}\n\n/**\n * *Reusable collection of keyframes affecting particular property of an object.*\n *\n * Each AnimationSampler refers to an input and an output {@link Accessor}. Input contains times\n * (in seconds) for each keyframe. Output contains values (of any {@link Accessor.Type}) for the\n * animated property at each keyframe. Samplers using `CUBICSPLINE` interpolation will also contain\n * in/out tangents in the output, with the layout:\n *\n * in<sub>1</sub>, value<sub>1</sub>, out<sub>1</sub>,\n * in<sub>2</sub>, value<sub>2</sub>, out<sub>2</sub>,\n * in<sub>3</sub>, value<sub>3</sub>, out<sub>3</sub>, ...\n *\n * Usage:\n *\n * ```ts\n * // Create accessor containing input times, in seconds.\n * const input = doc.createAccessor('bounceTimes')\n * \t.setArray(new Float32Array([0, 1, 2]))\n * \t.setType(Accessor.Type.SCALAR);\n *\n * // Create accessor containing output values, in local units.\n * const output = doc.createAccessor('bounceValues')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0, // y = 0\n * \t\t0, 1, 0, // y = 1\n * \t\t0, 0, 0, // y = 0\n * \t]))\n * \t.setType(Accessor.Type.VEC3);\n *\n * // Create sampler.\n * const sampler = doc.createAnimationSampler('bounce')\n * \t.setInput(input)\n * \t.setOutput(output)\n * \t.setInterpolation('LINEAR');\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nexport class AnimationSampler extends ExtensibleProperty<IAnimationSampler> {\n\tpublic declare propertyType: PropertyType.ANIMATION_SAMPLER;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Interpolation method. */\n\tpublic static Interpolation: Record<string, GLTF.AnimationSamplerInterpolation> = {\n\t\t/** Animated values are linearly interpolated between keyframes. */\n\t\tLINEAR: 'LINEAR',\n\t\t/** Animated values remain constant from one keyframe until the next keyframe. */\n\t\tSTEP: 'STEP',\n\t\t/** Animated values are interpolated according to given cubic spline tangents. */\n\t\tCUBICSPLINE: 'CUBICSPLINE',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ANIMATION_SAMPLER;\n\t}\n\n\tprotected getDefaultAttributes(): Nullable<IAnimationSampler> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tinterpolation: AnimationSampler.Interpolation.LINEAR,\n\t\t\tinput: null,\n\t\t\toutput: null,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Static.\n\t */\n\n\t/** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n\tpublic getInterpolation(): GLTF.AnimationSamplerInterpolation {\n\t\treturn this.get('interpolation');\n\t}\n\n\t/** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n\tpublic setInterpolation(interpolation: GLTF.AnimationSamplerInterpolation): this {\n\t\treturn this.set('interpolation', interpolation);\n\t}\n\n\t/** Times for each keyframe, in seconds. */\n\tpublic getInput(): Accessor | null {\n\t\treturn this.getRef('input');\n\t}\n\n\t/** Times for each keyframe, in seconds. */\n\tpublic setInput(input: Accessor | null): this {\n\t\treturn this.setRef('input', input, { usage: BufferViewUsage.OTHER });\n\t}\n\n\t/**\n\t * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n\t * tangents.\n\t */\n\tpublic getOutput(): Accessor | null {\n\t\treturn this.getRef('output');\n\t}\n\n\t/**\n\t * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n\t * tangents.\n\t */\n\tpublic setOutput(output: Accessor | null): this {\n\t\treturn this.setRef('output', output, { usage: BufferViewUsage.OTHER });\n\t}\n}\n", "import { type Nullable, PropertyType } from '../constants.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\n\ninterface IBuffer extends IExtensibleProperty {\n\turi: string;\n}\n\n/**\n * *Buffers are low-level storage units for binary data.*\n *\n * glTF 2.0 has three concepts relevant to binary storage: accessors, buffer views, and buffers.\n * In glTF Transform, an {@link Accessor} is referenced by any property that requires numeric typed\n * array data. Meshes, Primitives, and Animations all reference Accessors. Buffers define how that\n * data is organized into transmitted file(s). A `.glb` file has only a single Buffer, and when\n * exporting to `.glb` your resources should be grouped accordingly. A `.gltf` file may reference\n * one or more `.bin` files — each `.bin` is a Buffer — and grouping Accessors under different\n * Buffers allow you to specify that structure.\n *\n * For engines that can dynamically load portions of a glTF file, splitting data into separate\n * buffers can allow you to avoid loading data until it is needed. For example, you might put\n * binary data for specific meshes into a different `.bin` buffer, or put each animation's binary\n * payload into its own `.bin`.\n *\n * Buffer Views define how Accessors are organized within a given Buffer. glTF Transform creates an\n * efficient Buffer View layout automatically at export: there is no Buffer View property exposed\n * by the glTF Transform API, simplifying data management.\n *\n * Usage:\n *\n * ```ts\n * // Create two buffers with custom filenames.\n * const buffer1 = doc.createBuffer('buffer1')\n * \t.setURI('part1.bin');\n * const buffer2 = doc.createBuffer('buffer2')\n * \t.setURI('part2.bin');\n *\n * // Assign the attributes of two meshes to different buffers. If the meshes\n * // had indices or morph target attributes, you would also want to relocate\n * // those accessors.\n * mesh1\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer1)));\n * mesh2\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer2)));\n *\n * // Write to disk. Each mesh's binary data will be in a separate binary file;\n * // any remaining accessors will be in a third (default) buffer.\n * await new NodeIO().write('scene.gltf', doc);\n * // → scene.gltf, part1.bin, part2.bin\n * ```\n *\n * References:\n * - [glTF → Buffers and Buffer Views](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#buffers-and-buffer-views)\n * - [glTF → Accessors](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nexport class Buffer extends ExtensibleProperty<IBuffer> {\n\tpublic declare propertyType: PropertyType.BUFFER;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.BUFFER;\n\t}\n\n\tprotected getDefaults(): Nullable<IBuffer> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { uri: '' });\n\t}\n\n\t/**\n\t * Returns the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n\t * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n\t * is possible for custom applications, but will limit the compatibility of the asset with most\n\t * tools.\n\t *\n\t * Buffers commonly use the extension `.bin`, though this is not required.\n\t */\n\tpublic getURI(): string {\n\t\treturn this.get('uri');\n\t}\n\n\t/**\n\t * Sets the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n\t * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n\t * is possible for custom applications, but will limit the compatibility of the asset with most\n\t * tools.\n\t *\n\t * Buffers commonly use the extension `.bin`, though this is not required.\n\t */\n\tpublic setURI(uri: string): this {\n\t\treturn this.set('uri', uri);\n\t}\n}\n", "import { type Nullable, PropertyType } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\n\ninterface ICamera extends IExtensibleProperty {\n\ttype: GLTF.CameraType;\n\tznear: number;\n\tzfar: number;\n\taspectRatio: number | null;\n\tyfov: number;\n\txmag: number;\n\tymag: number;\n}\n\n/**\n * *Cameras are perspectives through which the {@link Scene} may be viewed.*\n *\n * Projection can be perspective or orthographic. Cameras are contained in nodes and thus can be\n * transformed. The camera is defined such that the local +X axis is to the right, the lens looks\n * towards the local -Z axis, and the top of the camera is aligned with the local +Y axis. If no\n * transformation is specified, the location of the camera is at the origin.\n *\n * Usage:\n *\n * ```typescript\n * const camera = doc.createCamera('myCamera')\n * \t.setType(GLTF.CameraType.PERSPECTIVE)\n * \t.setZNear(0.1)\n * \t.setZFar(100)\n * \t.setYFov(Math.PI / 4)\n * \t.setAspectRatio(1.5);\n *\n * node.setCamera(camera);\n * ```\n *\n * References:\n * - [glTF → Cameras](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#cameras)\n *\n * @category Properties\n */\nexport class Camera extends ExtensibleProperty<ICamera> {\n\tpublic declare propertyType: PropertyType.CAMERA;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\tpublic static Type: Record<string, GLTF.CameraType> = {\n\t\t/** A perspective camera representing a perspective projection matrix. */\n\t\tPERSPECTIVE: 'perspective',\n\t\t/** An orthographic camera representing an orthographic projection matrix. */\n\t\tORTHOGRAPHIC: 'orthographic',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.CAMERA;\n\t}\n\n\tprotected getDefaults(): Nullable<ICamera> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\t// Common.\n\t\t\ttype: Camera.Type.PERSPECTIVE,\n\t\t\tznear: 0.1,\n\t\t\tzfar: 100,\n\t\t\t// Perspective.\n\t\t\taspectRatio: null,\n\t\t\tyfov: (Math.PI * 2 * 50) / 360, // 50º\n\t\t\t// Orthographic.\n\t\t\txmag: 1,\n\t\t\tymag: 1,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Common.\n\t */\n\n\t/** Specifies if the camera uses a perspective or orthographic projection. */\n\tpublic getType(): GLTF.CameraType {\n\t\treturn this.get('type');\n\t}\n\n\t/** Specifies if the camera uses a perspective or orthographic projection. */\n\tpublic setType(type: GLTF.CameraType): this {\n\t\treturn this.set('type', type);\n\t}\n\n\t/** Floating-point distance to the near clipping plane. */\n\tpublic getZNear(): number {\n\t\treturn this.get('znear');\n\t}\n\n\t/** Floating-point distance to the near clipping plane. */\n\tpublic setZNear(znear: number): this {\n\t\treturn this.set('znear', znear);\n\t}\n\n\t/**\n\t * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n\t * znear. If zfar is undefined, runtime must use infinite projection matrix.\n\t */\n\tpublic getZFar(): number {\n\t\treturn this.get('zfar');\n\t}\n\n\t/**\n\t * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n\t * znear. If zfar is undefined, runtime must use infinite projection matrix.\n\t */\n\tpublic setZFar(zfar: number): this {\n\t\treturn this.set('zfar', zfar);\n\t}\n\n\t/**********************************************************************************************\n\t * Perspective.\n\t */\n\n\t/**\n\t * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n\t * canvas is used.\n\t */\n\tpublic getAspectRatio(): number | null {\n\t\treturn this.get('aspectRatio');\n\t}\n\n\t/**\n\t * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n\t * canvas is used.\n\t */\n\tpublic setAspectRatio(aspectRatio: number | null): this {\n\t\treturn this.set('aspectRatio', aspectRatio);\n\t}\n\n\t/** Floating-point vertical field of view in radians. */\n\tpublic getYFov(): number {\n\t\treturn this.get('yfov');\n\t}\n\n\t/** Floating-point vertical field of view in radians. */\n\tpublic setYFov(yfov: number): this {\n\t\treturn this.set('yfov', yfov);\n\t}\n\n\t/**********************************************************************************************\n\t * Orthographic.\n\t */\n\n\t/**\n\t * Floating-point horizontal magnification of the view, and half the view's width\n\t * in world units.\n\t */\n\tpublic getXMag(): number {\n\t\treturn this.get('xmag');\n\t}\n\n\t/**\n\t * Floating-point horizontal magnification of the view, and half the view's width\n\t * in world units.\n\t */\n\tpublic setXMag(xmag: number): this {\n\t\treturn this.set('xmag', xmag);\n\t}\n\n\t/**\n\t * Floating-point vertical magnification of the view, and half the view's height\n\t * in world units.\n\t */\n\tpublic getYMag(): number {\n\t\treturn this.get('ymag');\n\t}\n\n\t/**\n\t * Floating-point vertical magnification of the view, and half the view's height\n\t * in world units.\n\t */\n\tpublic setYMag(ymag: number): this {\n\t\treturn this.set('ymag', ymag);\n\t}\n}\n", "import type { ExtensibleProperty } from './extensible-property.js';\nimport { type IProperty, Property } from './property.js';\n\n/**\n * *Base class for all {@link Property} types that can be attached by an {@link Extension}.*\n *\n * After an {@link Extension} is attached to a glTF {@link Document}, the Extension may be used to\n * construct ExtensionProperty instances, to be referenced throughout the document as prescribed by\n * the Extension. For example, the `KHR_materials_clearcoat` Extension defines a `Clearcoat`\n * ExtensionProperty, which is referenced by {@link Material} Properties in the Document, and may\n * contain references to {@link Texture} properties of its own.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#specifying-extensions)\n *\n * @category Properties\n */\nexport abstract class ExtensionProperty<T extends IProperty = IProperty> extends Property<T> {\n\tpublic static EXTENSION_NAME: string;\n\tpublic abstract readonly extensionName: string;\n\n\t/** List of supported {@link Property} types. */\n\tpublic abstract readonly parentTypes: string[];\n\n\t/** @hidden */\n\tpublic _validateParent(parent: ExtensibleProperty): void {\n\t\tif (!this.parentTypes.includes(parent.propertyType)) {\n\t\t\tthrow new Error(`Parent \"${parent.propertyType}\" invalid for child \"${this.propertyType}\".`);\n\t\t}\n\t}\n}\n", "import { type Nullable, PropertyType } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\n\ninterface ITextureInfo extends IExtensibleProperty {\n\ttexCoord: number;\n\n\t// Sampler properties are also attached to TextureInfo, for simplicity.\n\tmagFilter: GLTF.TextureMagFilter | null;\n\tminFilter: GLTF.TextureMinFilter | null;\n\twrapS: GLTF.TextureWrapMode;\n\twrapT: GLTF.TextureWrapMode;\n}\n\n/**\n * *Settings associated with a particular use of a {@link Texture}.*\n *\n * Different materials may reuse the same texture but with different texture coordinates,\n * minFilter/magFilter, or wrapS/wrapT settings. The TextureInfo class contains settings\n * derived from both the \"TextureInfo\" and \"Sampler\" properties in the glTF specification,\n * consolidated here for simplicity.\n *\n * TextureInfo properties cannot be directly created. For any material texture slot, such as\n * baseColorTexture, there will be a corresponding method to obtain the TextureInfo for that slot.\n * For example, see {@link Material.getBaseColorTextureInfo}.\n *\n * References:\n * - [glTF → Texture Info](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#reference-textureinfo)\n *\n * @category Properties\n */\nexport class TextureInfo extends ExtensibleProperty<ITextureInfo> {\n\tpublic declare propertyType: PropertyType.TEXTURE_INFO;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** UV wrapping mode. Values correspond to WebGL enums. */\n\tpublic static WrapMode: Record<string, GLTF.TextureWrapMode> = {\n\t\t/** */\n\t\tCLAMP_TO_EDGE: 33071,\n\t\t/** */\n\t\tMIRRORED_REPEAT: 33648,\n\t\t/** */\n\t\tREPEAT: 10497,\n\t};\n\n\t/** Magnification filter. Values correspond to WebGL enums. */\n\tpublic static MagFilter: Record<string, GLTF.TextureMagFilter> = {\n\t\t/** */\n\t\tNEAREST: 9728,\n\t\t/** */\n\t\tLINEAR: 9729,\n\t};\n\n\t/** Minification filter. Values correspond to WebGL enums. */\n\tpublic static MinFilter: Record<string, GLTF.TextureMinFilter> = {\n\t\t/** */\n\t\tNEAREST: 9728,\n\t\t/** */\n\t\tLINEAR: 9729,\n\t\t/** */\n\t\tNEAREST_MIPMAP_NEAREST: 9984,\n\t\t/** */\n\t\tLINEAR_MIPMAP_NEAREST: 9985,\n\t\t/** */\n\t\tNEAREST_MIPMAP_LINEAR: 9986,\n\t\t/** */\n\t\tLINEAR_MIPMAP_LINEAR: 9987,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.TEXTURE_INFO;\n\t}\n\n\tprotected getDefaults(): Nullable<ITextureInfo> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\ttexCoord: 0,\n\t\t\tmagFilter: null,\n\t\t\tminFilter: null,\n\t\t\twrapS: TextureInfo.WrapMode.REPEAT,\n\t\t\twrapT: TextureInfo.WrapMode.REPEAT,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Texture coordinates.\n\t */\n\n\t/** Returns the texture coordinate (UV set) index for the texture. */\n\tpublic getTexCoord(): number {\n\t\treturn this.get('texCoord');\n\t}\n\n\t/** Sets the texture coordinate (UV set) index for the texture. */\n\tpublic setTexCoord(texCoord: number): this {\n\t\treturn this.set('texCoord', texCoord);\n\t}\n\n\t/**********************************************************************************************\n\t * Min/mag filter.\n\t */\n\n\t/** Returns the magnification filter applied to the texture. */\n\tpublic getMagFilter(): GLTF.TextureMagFilter | null {\n\t\treturn this.get('magFilter');\n\t}\n\n\t/** Sets the magnification filter applied to the texture. */\n\tpublic setMagFilter(magFilter: GLTF.TextureMagFilter | null): this {\n\t\treturn this.set('magFilter', magFilter);\n\t}\n\n\t/** Sets the minification filter applied to the texture. */\n\tpublic getMinFilter(): GLTF.TextureMinFilter | null {\n\t\treturn this.get('minFilter');\n\t}\n\n\t/** Returns the minification filter applied to the texture. */\n\tpublic setMinFilter(minFilter: GLTF.TextureMinFilter | null): this {\n\t\treturn this.set('minFilter', minFilter);\n\t}\n\n\t/**********************************************************************************************\n\t * UV wrapping.\n\t */\n\n\t/** Returns the S (U) wrapping mode for UVs used by the texture. */\n\tpublic getWrapS(): GLTF.TextureWrapMode {\n\t\treturn this.get('wrapS');\n\t}\n\n\t/** Sets the S (U) wrapping mode for UVs used by the texture. */\n\tpublic setWrapS(wrapS: GLTF.TextureWrapMode): this {\n\t\treturn this.set('wrapS', wrapS);\n\t}\n\n\t/** Returns the T (V) wrapping mode for UVs used by the texture. */\n\tpublic getWrapT(): GLTF.TextureWrapMode {\n\t\treturn this.get('wrapT');\n\t}\n\n\t/** Sets the T (V) wrapping mode for UVs used by the texture. */\n\tpublic setWrapT(wrapT: GLTF.TextureWrapMode): this {\n\t\treturn this.set('wrapT', wrapT);\n\t}\n}\n", "import { type Nullable, PropertyType, TextureChannel, type vec3, type vec4 } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\nimport type { Texture } from './texture.js';\nimport { TextureInfo } from './texture-info.js';\n\nconst { R, G, B, A } = TextureChannel;\n\ninterface IMaterial extends IExtensibleProperty {\n\talphaMode: GLTF.MaterialAlphaMode;\n\talphaCutoff: number;\n\tdoubleSided: boolean;\n\tbaseColorFactor: vec4;\n\tbaseColorTexture: Texture;\n\tbaseColorTextureInfo: TextureInfo;\n\temissiveFactor: vec3;\n\temissiveTexture: Texture;\n\temissiveTextureInfo: TextureInfo;\n\tnormalScale: number;\n\tnormalTexture: Texture;\n\tnormalTextureInfo: TextureInfo;\n\tocclusionStrength: number;\n\tocclusionTexture: Texture;\n\tocclusionTextureInfo: TextureInfo;\n\troughnessFactor: number;\n\tmetallicFactor: number;\n\tmetallicRoughnessTexture: Texture;\n\tmetallicRoughnessTextureInfo: TextureInfo;\n}\n\n/**\n * *Materials describe a surface's appearance and response to light.*\n *\n * Each {@link Primitive} within a {@link Mesh} may be assigned a single Material. The number of\n * GPU draw calls typically increases with both the numbers of Primitives and of Materials in an\n * asset; Materials should be reused wherever possible. Techniques like texture atlasing and vertex\n * colors allow objects to have varied appearances while technically sharing a single Material.\n *\n * Material properties are modified by both scalars (like `baseColorFactor`) and textures (like\n * `baseColorTexture`). When both are available, factors are considered linear multipliers against\n * textures of the same name. In the case of base color, vertex colors (`COLOR_0` attributes) are\n * also multiplied.\n *\n * Textures containing color data (`baseColorTexture`, `emissiveTexture`) are sRGB. All other\n * textures are linear. Like other resources, textures should be reused when possible.\n *\n * Usage:\n *\n * ```typescript\n * const material = doc.createMaterial('myMaterial')\n * \t.setBaseColorFactor([1, 0.5, 0.5, 1]) // RGBA\n * \t.setOcclusionTexture(aoTexture)\n * \t.setOcclusionStrength(0.5);\n *\n * mesh.listPrimitives()\n * \t.forEach((prim) => prim.setMaterial(material));\n * ```\n *\n * @category Properties\n */\nexport class Material extends ExtensibleProperty<IMaterial> {\n\tpublic declare propertyType: PropertyType.MATERIAL;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\tpublic static AlphaMode: Record<string, GLTF.MaterialAlphaMode> = {\n\t\t/**\n\t\t * The alpha value is ignored and the rendered output is fully opaque\n\t\t */\n\t\tOPAQUE: 'OPAQUE',\n\t\t/**\n\t\t * The rendered output is either fully opaque or fully transparent depending on the alpha\n\t\t * value and the specified alpha cutoff value\n\t\t */\n\t\tMASK: 'MASK',\n\t\t/**\n\t\t * The alpha value is used to composite the source and destination areas. The rendered\n\t\t * output is combined with the background using the normal painting operation (i.e. the\n\t\t * Porter and Duff over operator)\n\t\t */\n\t\tBLEND: 'BLEND',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.MATERIAL;\n\t}\n\n\tprotected getDefaults(): Nullable<IMaterial> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\talphaMode: Material.AlphaMode.OPAQUE,\n\t\t\talphaCutoff: 0.5,\n\t\t\tdoubleSided: false,\n\t\t\tbaseColorFactor: [1, 1, 1, 1] as vec4,\n\t\t\tbaseColorTexture: null,\n\t\t\tbaseColorTextureInfo: new TextureInfo(this.graph, 'baseColorTextureInfo'),\n\t\t\temissiveFactor: [0, 0, 0] as vec3,\n\t\t\temissiveTexture: null,\n\t\t\temissiveTextureInfo: new TextureInfo(this.graph, 'emissiveTextureInfo'),\n\t\t\tnormalScale: 1,\n\t\t\tnormalTexture: null,\n\t\t\tnormalTextureInfo: new TextureInfo(this.graph, 'normalTextureInfo'),\n\t\t\tocclusionStrength: 1,\n\t\t\tocclusionTexture: null,\n\t\t\tocclusionTextureInfo: new TextureInfo(this.graph, 'occlusionTextureInfo'),\n\t\t\troughnessFactor: 1,\n\t\t\tmetallicFactor: 1,\n\t\t\tmetallicRoughnessTexture: null,\n\t\t\tmetallicRoughnessTextureInfo: new TextureInfo(this.graph, 'metallicRoughnessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Double-sided / culling.\n\t */\n\n\t/** Returns true when both sides of triangles should be rendered. May impact performance. */\n\tpublic getDoubleSided(): boolean {\n\t\treturn this.get('doubleSided');\n\t}\n\n\t/** Sets whether to render both sides of triangles. May impact performance. */\n\tpublic setDoubleSided(doubleSided: boolean): this {\n\t\treturn this.set('doubleSided', doubleSided);\n\t}\n\n\t/**********************************************************************************************\n\t * Alpha.\n\t */\n\n\t/** Returns material alpha, equivalent to baseColorFactor[3]. */\n\tpublic getAlpha(): number {\n\t\treturn this.get('baseColorFactor')[3];\n\t}\n\n\t/** Sets material alpha, equivalent to baseColorFactor[3]. */\n\tpublic setAlpha(alpha: number): this {\n\t\tconst baseColorFactor = this.get('baseColorFactor').slice() as vec4;\n\t\tbaseColorFactor[3] = alpha;\n\t\treturn this.set('baseColorFactor', baseColorFactor);\n\t}\n\n\t/**\n\t * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`\n\t * and `baseColorTexture`.\n\t *\n\t * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.\n\t * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and\n\t * \tthe fraction of surface vs. background color in the final result. Alpha blending creates\n\t *\tsignificant edge cases in realtime renderers, and some care when structuring the model is\n\t * \tnecessary for good results. In particular, transparent geometry should be kept in separate\n\t * \tmeshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines\n\t * \tshould usually be disabled on transparent materials.\n\t * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a\n\t * \tsurface, and the pixel is either fully visible or fully discarded based on that cutoff.\n\t * \tThis technique is useful for things like leafs/foliage, grass, fabric meshes, and other\n\t * \tsurfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces\n\t * \tthat don't require semitransparency can avoid the performance penalties and visual issues\n\t * \tinvolved with `BLEND` transparency.\n\t *\n\t * Reference:\n\t * - [glTF → material.alphaMode](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialalphamode)\n\t */\n\tpublic getAlphaMode(): GLTF.MaterialAlphaMode {\n\t\treturn this.get('alphaMode');\n\t}\n\n\t/** Sets the mode of the material's alpha channels. See {@link Material.getAlphaMode getAlphaMode} for details. */\n\tpublic setAlphaMode(alphaMode: GLTF.MaterialAlphaMode): this {\n\t\treturn this.set('alphaMode', alphaMode);\n\t}\n\n\t/** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */\n\tpublic getAlphaCutoff(): number {\n\t\treturn this.get('alphaCutoff');\n\t}\n\n\t/** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */\n\tpublic setAlphaCutoff(alphaCutoff: number): this {\n\t\treturn this.set('alphaCutoff', alphaCutoff);\n\t}\n\n\t/**********************************************************************************************\n\t * Base color.\n\t */\n\n\t/**\n\t * Base color / albedo factor; Linear-sRGB components.\n\t * See {@link Material.getBaseColorTexture getBaseColorTexture}.\n\t */\n\tpublic getBaseColorFactor(): vec4 {\n\t\treturn this.get('baseColorFactor');\n\t}\n\n\t/**\n\t * Base color / albedo factor; Linear-sRGB components.\n\t * See {@link Material.getBaseColorTexture getBaseColorTexture}.\n\t */\n\tpublic setBaseColorFactor(baseColorFactor: vec4): this {\n\t\treturn this.set('baseColorFactor', baseColorFactor);\n\t}\n\n\t/**\n\t * Base color / albedo. The visible color of a non-metallic surface under constant ambient\n\t * light would be a linear combination (multiplication) of its vertex colors, base color\n\t * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,\n\t * also effect the final color. The alpha (`.a`) channel of base color factors and textures\n\t * will have varying effects, based on the setting of {@link Material.getAlphaMode getAlphaMode}.\n\t *\n\t * Reference:\n\t * - [glTF → material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)\n\t */\n\tpublic getBaseColorTexture(): Texture | null {\n\t\treturn this.getRef('baseColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its base color texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getBaseColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('baseColorTexture') ? this.getRef('baseColorTextureInfo') : null;\n\t}\n\n\t/** Sets base color / albedo texture. See {@link Material.getBaseColorTexture getBaseColorTexture}. */\n\tpublic setBaseColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('baseColorTexture', texture, { channels: R | G | B | A, isColor: true });\n\t}\n\n\t/**********************************************************************************************\n\t * Emissive.\n\t */\n\n\t/** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n\tpublic getEmissiveFactor(): vec3 {\n\t\treturn this.get('emissiveFactor');\n\t}\n\n\t/** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n\tpublic setEmissiveFactor(emissiveFactor: vec3): this {\n\t\treturn this.set('emissiveFactor', emissiveFactor);\n\t}\n\n\t/**\n\t * Emissive texture. Emissive color is added to any base color of the material, after any\n\t * lighting/shadowing are applied. An emissive color does not inherently \"glow\", or affect\n\t * objects around it at all. To create that effect, most viewers must also enable a\n\t * post-processing effect called \"bloom\".\n\t *\n\t * Reference:\n\t * - [glTF → material.emissiveTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialemissivetexture)\n\t */\n\tpublic getEmissiveTexture(): Texture | null {\n\t\treturn this.getRef('emissiveTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its emissive texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getEmissiveTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('emissiveTexture') ? this.getRef('emissiveTextureInfo') : null;\n\t}\n\n\t/** Sets emissive texture. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n\tpublic setEmissiveTexture(texture: Texture | null): this {\n\t\treturn this.setRef('emissiveTexture', texture, { channels: R | G | B, isColor: true });\n\t}\n\n\t/**********************************************************************************************\n\t * Normal.\n\t */\n\n\t/** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tpublic getNormalScale(): number {\n\t\treturn this.get('normalScale');\n\t}\n\n\t/** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tpublic setNormalScale(scale: number): this {\n\t\treturn this.set('normalScale', scale);\n\t}\n\n\t/**\n\t * Normal (surface detail) texture.\n\t *\n\t * A tangent space normal map. The texture contains RGB components. Each texel represents the\n\t * XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X [-1 to 1].\n\t * Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal\n\t * vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer.\n\t *\n\t * Reference:\n\t * - [glTF → material.normalTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialnormaltexture)\n\t */\n\tpublic getNormalTexture(): Texture | null {\n\t\treturn this.getRef('normalTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its normal texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getNormalTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('normalTexture') ? this.getRef('normalTextureInfo') : null;\n\t}\n\n\t/** Sets normal (surface detail) texture. See {@link Material.getNormalTexture getNormalTexture}. */\n\tpublic setNormalTexture(texture: Texture | null): this {\n\t\treturn this.setRef('normalTexture', texture, { channels: R | G | B });\n\t}\n\n\t/**********************************************************************************************\n\t * Occlusion.\n\t */\n\n\t/** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n\tpublic getOcclusionStrength(): number {\n\t\treturn this.get('occlusionStrength');\n\t}\n\n\t/** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n\tpublic setOcclusionStrength(strength: number): this {\n\t\treturn this.set('occlusionStrength', strength);\n\t}\n\n\t/**\n\t * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are\n\t * independent of an object's position, such as shading in inset areas and corners. Direct\n\t * lighting is not affected by occlusion, so at least one indirect light source must be present\n\t * in the scene for occlusion effects to be visible.\n\t *\n\t * The occlusion values are sampled from the R channel. Higher values indicate areas that\n\t * should receive full indirect lighting and lower values indicate no indirect lighting.\n\t *\n\t * Reference:\n\t * - [glTF → material.occlusionTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialocclusiontexture)\n\t */\n\tpublic getOcclusionTexture(): Texture | null {\n\t\treturn this.getRef('occlusionTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its occlusion texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getOcclusionTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('occlusionTexture') ? this.getRef('occlusionTextureInfo') : null;\n\t}\n\n\t/** Sets (ambient) occlusion texture. See {@link Material.getOcclusionTexture getOcclusionTexture}. */\n\tpublic setOcclusionTexture(texture: Texture | null): this {\n\t\treturn this.setRef('occlusionTexture', texture, { channels: R });\n\t}\n\n\t/**********************************************************************************************\n\t * Metallic / roughness.\n\t */\n\n\t/**\n\t * Roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n\t */\n\tpublic getRoughnessFactor(): number {\n\t\treturn this.get('roughnessFactor');\n\t}\n\n\t/**\n\t * Sets roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n\t */\n\tpublic setRoughnessFactor(factor: number): this {\n\t\treturn this.set('roughnessFactor', factor);\n\t}\n\n\t/**\n\t * Metallic factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n\t */\n\tpublic getMetallicFactor(): number {\n\t\treturn this.get('metallicFactor');\n\t}\n\n\t/**\n\t * Sets metallic factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n\t */\n\tpublic setMetallicFactor(factor: number): this {\n\t\treturn this.set('metallicFactor', factor);\n\t}\n\n\t/**\n\t * Metallic roughness texture. The metalness values are sampled from the B channel. The\n\t * roughness values are sampled from the G channel. When a material is fully metallic,\n\t * or nearly so, it may require image-based lighting (i.e. an environment map) or global\n\t * illumination to appear well-lit.\n\t *\n\t * Reference:\n\t * - [glTF → material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)\n\t */\n\tpublic getMetallicRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('metallicRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its metallic/roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getMetallicRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('metallicRoughnessTexture') ? this.getRef('metallicRoughnessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Sets metallic/roughness texture.\n\t * See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n\t */\n\tpublic setMetallicRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('metallicRoughnessTexture', texture, { channels: G | B });\n\t}\n}\n", "import { RefSet } from 'property-graph';\nimport { type Nullable, PropertyType } from '../constants.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\nimport type { Primitive } from './primitive.js';\n\ninterface IMesh extends IExtensibleProperty {\n\tweights: number[];\n\tprimitives: RefSet<Primitive>;\n}\n\n/**\n * *Meshes define reusable geometry (triangles, lines, or points) and are instantiated by\n * {@link Node}s.*\n *\n * Each draw call required to render a mesh is represented as a {@link Primitive}. Meshes typically\n * have only a single {@link Primitive}, but may have more for various reasons. A mesh manages only\n * a list of primitives — materials, morph targets, and other properties are managed on a per-\n * primitive basis.\n *\n * When the same geometry and material should be rendered at multiple places in the scene, reuse\n * the same Mesh instance and attach it to multiple nodes for better efficiency. Where the geometry\n * is shared but the material is not, reusing {@link Accessor}s under different meshes and\n * primitives can similarly improve transmission efficiency, although some rendering efficiency is\n * lost as the number of materials in a scene increases.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor);\n * const mesh = doc.createMesh('myMesh')\n * \t.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nexport class Mesh extends ExtensibleProperty<IMesh> {\n\tpublic declare propertyType: PropertyType.MESH;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.MESH;\n\t}\n\n\tprotected getDefaults(): Nullable<IMesh> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tweights: [],\n\t\t\tprimitives: new RefSet<Primitive>(),\n\t\t});\n\t}\n\n\t/** Adds a {@link Primitive} to the mesh's draw call list. */\n\tpublic addPrimitive(primitive: Primitive): this {\n\t\treturn this.addRef('primitives', primitive);\n\t}\n\n\t/** Removes a {@link Primitive} from the mesh's draw call list. */\n\tpublic removePrimitive(primitive: Primitive): this {\n\t\treturn this.removeRef('primitives', primitive);\n\t}\n\n\t/** Lists {@link Primitive} draw calls of the mesh. */\n\tpublic listPrimitives(): Primitive[] {\n\t\treturn this.listRefs('primitives');\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n\t * have the same number of targets. Most engines only support 4-8 active morph targets at a\n\t * time.\n\t */\n\tpublic getWeights(): number[] {\n\t\treturn this.get('weights');\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n\t * have the same number of targets. Most engines only support 4-8 active morph targets at a\n\t * time.\n\t */\n\tpublic setWeights(weights: number[]): this {\n\t\treturn this.set('weights', weights);\n\t}\n}\n", "import { multiply } from 'gl-matrix/mat4';\nimport { RefSet } from 'property-graph';\nimport { type mat4, type Nullable, PropertyType, type vec3, type vec4 } from '../constants.js';\nimport { MathUtils } from '../utils/index.js';\nimport type { Camera } from './camera.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\nimport type { Mesh } from './mesh.js';\nimport { COPY_IDENTITY } from './property.js';\nimport type { Scene } from './scene.js';\nimport type { Skin } from './skin.js';\n\ninterface INode extends IExtensibleProperty {\n\ttranslation: vec3;\n\trotation: vec4;\n\tscale: vec3;\n\tweights: number[];\n\tcamera: Camera;\n\tmesh: Mesh;\n\tskin: Skin;\n\tchildren: RefSet<Node>;\n}\n\n/**\n * *Nodes are the objects that comprise a {@link Scene}.*\n *\n * Each Node may have one or more children, and a transform (position, rotation, and scale) that\n * applies to all of its descendants. A Node may also reference (or \"instantiate\") other resources\n * at its location, including {@link Mesh}, Camera, Light, and Skin properties. A Node cannot be\n * part of more than one {@link Scene}.\n *\n * A Node's local transform is represented with array-like objects, intended to be compatible with\n * [gl-matrix](https://github.com/toji/gl-matrix), or with the `toArray`/`fromArray` methods of\n * libraries like three.js and babylon.js.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.createNode('myNode')\n * \t.setMesh(mesh)\n * \t.setTranslation([0, 0, 0])\n * \t.addChild(otherNode);\n * ```\n *\n * References:\n * - [glTF → Nodes and Hierarchy](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#nodes-and-hierarchy)\n *\n * @category Properties\n */\nexport class Node extends ExtensibleProperty<INode> {\n\tpublic declare propertyType: PropertyType.NODE;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.NODE;\n\t}\n\n\tprotected getDefaults(): Nullable<INode> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\ttranslation: [0, 0, 0] as vec3,\n\t\t\trotation: [0, 0, 0, 1] as vec4,\n\t\t\tscale: [1, 1, 1] as vec3,\n\t\t\tweights: [],\n\t\t\tcamera: null,\n\t\t\tmesh: null,\n\t\t\tskin: null,\n\t\t\tchildren: new RefSet<Node>(),\n\t\t});\n\t}\n\n\tpublic copy(other: this, resolve: typeof COPY_IDENTITY = COPY_IDENTITY): this {\n\t\t// Node cannot be copied, only cloned. Copying is shallow, but Nodes cannot have more than\n\t\t// one parent. Rather than leaving one of the two Nodes without children, throw an error here.\n\t\tif (resolve === COPY_IDENTITY) throw new Error('Node cannot be copied.');\n\t\treturn super.copy(other, resolve);\n\t}\n\n\t/**********************************************************************************************\n\t * Local transform.\n\t */\n\n\t/** Returns the translation (position) of this Node in local space. */\n\tpublic getTranslation(): vec3 {\n\t\treturn this.get('translation');\n\t}\n\n\t/** Returns the rotation (quaternion) of this Node in local space. */\n\tpublic getRotation(): vec4 {\n\t\treturn this.get('rotation');\n\t}\n\n\t/** Returns the scale of this Node in local space. */\n\tpublic getScale(): vec3 {\n\t\treturn this.get('scale');\n\t}\n\n\t/** Sets the translation (position) of this Node in local space. */\n\tpublic setTranslation(translation: vec3): this {\n\t\treturn this.set('translation', translation);\n\t}\n\n\t/** Sets the rotation (quaternion) of this Node in local space. */\n\tpublic setRotation(rotation: vec4): this {\n\t\treturn this.set('rotation', rotation);\n\t}\n\n\t/** Sets the scale of this Node in local space. */\n\tpublic setScale(scale: vec3): this {\n\t\treturn this.set('scale', scale);\n\t}\n\n\t/** Returns the local matrix of this Node. */\n\tpublic getMatrix(): mat4 {\n\t\treturn MathUtils.compose(\n\t\t\tthis.get('translation'),\n\t\t\tthis.get('rotation'),\n\t\t\tthis.get('scale'),\n\t\t\t[] as unknown as mat4,\n\t\t);\n\t}\n\n\t/** Sets the local matrix of this Node. Matrix will be decomposed to TRS properties. */\n\tpublic setMatrix(matrix: mat4): this {\n\t\tconst translation = this.get('translation').slice() as vec3;\n\t\tconst rotation = this.get('rotation').slice() as vec4;\n\t\tconst scale = this.get('scale').slice() as vec3;\n\t\tMathUtils.decompose(matrix, translation, rotation, scale);\n\t\treturn this.set('translation', translation).set('rotation', rotation).set('scale', scale);\n\t}\n\n\t/**********************************************************************************************\n\t * World transform.\n\t */\n\n\t/** Returns the translation (position) of this Node in world space. */\n\tpublic getWorldTranslation(): vec3 {\n\t\tconst t = [0, 0, 0] as vec3;\n\t\tMathUtils.decompose(this.getWorldMatrix(), t, [0, 0, 0, 1], [1, 1, 1]);\n\t\treturn t;\n\t}\n\n\t/** Returns the rotation (quaternion) of this Node in world space. */\n\tpublic getWorldRotation(): vec4 {\n\t\tconst r = [0, 0, 0, 1] as vec4;\n\t\tMathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], r, [1, 1, 1]);\n\t\treturn r;\n\t}\n\n\t/** Returns the scale of this Node in world space. */\n\tpublic getWorldScale(): vec3 {\n\t\tconst s = [1, 1, 1] as vec3;\n\t\tMathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], s);\n\t\treturn s;\n\t}\n\n\t/** Returns the world matrix of this Node. */\n\tpublic getWorldMatrix(): mat4 {\n\t\t// Build ancestor chain.\n\t\tconst ancestors: Node[] = [];\n\t\tfor (let node: Node | null = this; node != null; node = node.getParentNode()) {\n\t\t\tancestors.push(node);\n\t\t}\n\n\t\t// Compute world matrix.\n\t\tlet ancestor: Node | undefined;\n\t\tconst worldMatrix = ancestors.pop()!.getMatrix();\n\t\twhile ((ancestor = ancestors.pop())) {\n\t\t\tmultiply(worldMatrix, worldMatrix, ancestor.getMatrix());\n\t\t}\n\n\t\treturn worldMatrix;\n\t}\n\n\t/**********************************************************************************************\n\t * Scene hierarchy.\n\t */\n\n\t/**\n\t * Adds the given Node as a child of this Node.\n\t *\n\t * Requirements:\n\t *\n\t * 1. Nodes MAY be root children of multiple {@link Scene Scenes}\n\t * 2. Nodes MUST NOT be children of >1 Node\n\t * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}\n\t *\n\t * The `addChild` method enforces these restrictions automatically, and will\n\t * remove the new child from previous parents where needed. This behavior\n\t * may change in future major releases of the library.\n\t */\n\tpublic addChild(child: Node): this {\n\t\t// Remove existing parents.\n\t\tconst parentNode = child.getParentNode();\n\t\tif (parentNode) parentNode.removeChild(child);\n\t\tfor (const parent of child.listParents()) {\n\t\t\tif (parent.propertyType === PropertyType.SCENE) {\n\t\t\t\t(parent as Scene).removeChild(child);\n\t\t\t}\n\t\t}\n\n\t\treturn this.addRef('children', child);\n\t}\n\n\t/** Removes a Node from this Node's child Node list. */\n\tpublic removeChild(child: Node): this {\n\t\treturn this.removeRef('children', child);\n\t}\n\n\t/** Lists all child Nodes of this Node. */\n\tpublic listChildren(): Node[] {\n\t\treturn this.listRefs('children');\n\t}\n\n\t/**\n\t * Returns the Node's unique parent Node within the scene graph. If the\n\t * Node has no parents, or is a direct child of the {@link Scene}\n\t * (\"root node\"), this method returns null.\n\t *\n\t * Unrelated to {@link Property.listParents}, which lists all resource\n\t * references from properties of any type ({@link Skin}, {@link Root}, ...).\n\t */\n\tpublic getParentNode(): Node | null {\n\t\tfor (const parent of this.listParents()) {\n\t\t\tif (parent.propertyType === PropertyType.NODE) {\n\t\t\t\treturn parent as Node;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**********************************************************************************************\n\t * Attachments.\n\t */\n\n\t/** Returns the {@link Mesh}, if any, instantiated at this Node. */\n\tpublic getMesh(): Mesh | null {\n\t\treturn this.getRef('mesh');\n\t}\n\n\t/**\n\t * Sets a {@link Mesh} to be instantiated at this Node. A single mesh may be instantiated by\n\t * multiple Nodes; reuse of this sort is strongly encouraged.\n\t */\n\tpublic setMesh(mesh: Mesh | null): this {\n\t\treturn this.setRef('mesh', mesh);\n\t}\n\n\t/** Returns the {@link Camera}, if any, instantiated at this Node. */\n\tpublic getCamera(): Camera | null {\n\t\treturn this.getRef('camera');\n\t}\n\n\t/** Sets a {@link Camera} to be instantiated at this Node. */\n\tpublic setCamera(camera: Camera | null): this {\n\t\treturn this.setRef('camera', camera);\n\t}\n\n\t/** Returns the {@link Skin}, if any, instantiated at this Node. */\n\tpublic getSkin(): Skin | null {\n\t\treturn this.getRef('skin');\n\t}\n\n\t/** Sets a {@link Skin} to be instantiated at this Node. */\n\tpublic setSkin(skin: Skin | null): this {\n\t\treturn this.setRef('skin', skin);\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.\n\t * Most engines only support 4-8 active morph targets at a time.\n\t */\n\tpublic getWeights(): number[] {\n\t\treturn this.get('weights');\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.\n\t * Most engines only support 4-8 active morph targets at a time.\n\t */\n\tpublic setWeights(weights: number[]): this {\n\t\treturn this.set('weights', weights);\n\t}\n\n\t/**********************************************************************************************\n\t * Helpers.\n\t */\n\n\t/** Visits this {@link Node} and its descendants, top-down. */\n\tpublic traverse(fn: (node: Node) => void): this {\n\t\tfn(this);\n\t\tfor (const child of this.listChildren()) child.traverse(fn);\n\t\treturn this;\n\t}\n}\n", "import { RefMap, RefSet } from 'property-graph';\nimport { BufferViewUsage, type Nullable, PropertyType } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport type { Accessor } from './accessor.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\nimport type { Material } from './material.js';\nimport type { PrimitiveTarget } from './primitive-target.js';\n\ninterface IPrimitive extends IExtensibleProperty {\n\tmode: GLTF.MeshPrimitiveMode;\n\tmaterial: Material;\n\tindices: Accessor;\n\tattributes: RefMap<Accessor>;\n\ttargets: RefSet<PrimitiveTarget>;\n}\n\n/**\n * *Primitives are individual GPU draw calls comprising a {@link Mesh}.*\n *\n * Meshes typically have only a single Primitive, although various cases may require more. Each\n * primitive may be assigned vertex attributes, morph target attributes, and a material. Any of\n * these properties should be reused among multiple primitives where feasible.\n *\n * Primitives cannot be moved independently of other primitives within the same mesh, except\n * through the use of morph targets and skinning. If independent movement or other runtime\n * behavior is necessary (like raycasting or collisions) prefer to assign each primitive to a\n * different mesh. The number of GPU draw calls is typically not affected by grouping or\n * ungrouping primitives to a mesh.\n *\n * Each primitive may optionally be deformed by one or more morph targets, stored in a\n * {@link PrimitiveTarget}.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor)\n * \t.setMaterial(material);\n * mesh.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nexport class Primitive extends ExtensibleProperty<IPrimitive> {\n\tpublic declare propertyType: PropertyType.PRIMITIVE;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Type of primitives to render. All valid values correspond to WebGL enums. */\n\tpublic static Mode: Record<string, GLTF.MeshPrimitiveMode> = {\n\t\t/** Draw single points. */\n\t\tPOINTS: 0,\n\t\t/** Draw lines. Each vertex connects to the one after it. */\n\t\tLINES: 1,\n\t\t/**\n\t\t * Draw lines. Each set of two vertices is treated as a separate line segment.\n\t\t * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n\t\t */\n\t\tLINE_LOOP: 2,\n\t\t/** Draw a connected group of line segments from the first vertex to the last,  */\n\t\tLINE_STRIP: 3,\n\t\t/** Draw triangles. Each set of three vertices creates a separate triangle. */\n\t\tTRIANGLES: 4,\n\t\t/** Draw a connected strip of triangles. */\n\t\tTRIANGLE_STRIP: 5,\n\t\t/**\n\t\t * Draw a connected group of triangles. Each vertex connects to the previous and the first\n\t\t * vertex in the fan.\n\t\t * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n\t\t */\n\t\tTRIANGLE_FAN: 6,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.PRIMITIVE;\n\t}\n\n\tprotected getDefaults(): Nullable<IPrimitive> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tmode: Primitive.Mode.TRIANGLES,\n\t\t\tmaterial: null,\n\t\t\tindices: null,\n\t\t\tattributes: new RefMap<Accessor>(),\n\t\t\ttargets: new RefSet<PrimitiveTarget>(),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Primitive data.\n\t */\n\n\t/** Returns an {@link Accessor} with indices of vertices to be drawn. */\n\tpublic getIndices(): Accessor | null {\n\t\treturn this.getRef('indices');\n\t}\n\n\t/**\n\t * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,\n\t * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)\n\t * winding order.\n\t */\n\tpublic setIndices(indices: Accessor | null): this {\n\t\treturn this.setRef('indices', indices, { usage: BufferViewUsage.ELEMENT_ARRAY_BUFFER });\n\t}\n\n\t/** Returns a vertex attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\treturn this.getRefMap('attributes', semantic);\n\t}\n\n\t/**\n\t * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex\n\t * count.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: BufferViewUsage.ARRAY_BUFFER });\n\t}\n\n\t/**\n\t * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any\n\t * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,\n\t * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.listRefMapValues('attributes');\n\t}\n\n\t/**\n\t * Lists all vertex attribute semantics associated with the primitive, excluding any semantics\n\t * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.listRefMapKeys('attributes');\n\t}\n\n\t/** Returns the material used to render the primitive. */\n\tpublic getMaterial(): Material | null {\n\t\treturn this.getRef('material');\n\t}\n\n\t/** Sets the material used to render the primitive. */\n\tpublic setMaterial(material: Material | null): this {\n\t\treturn this.setRef('material', material);\n\t}\n\n\t/**********************************************************************************************\n\t * Mode.\n\t */\n\n\t/**\n\t * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n\t *\n\t * Reference:\n\t * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)\n\t */\n\tpublic getMode(): GLTF.MeshPrimitiveMode {\n\t\treturn this.get('mode');\n\t}\n\n\t/**\n\t * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n\t *\n\t * Reference:\n\t * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)\n\t */\n\tpublic setMode(mode: GLTF.MeshPrimitiveMode): this {\n\t\treturn this.set('mode', mode);\n\t}\n\n\t/**********************************************************************************************\n\t * Morph targets.\n\t */\n\n\t/** Lists all morph targets associated with the primitive. */\n\tpublic listTargets(): PrimitiveTarget[] {\n\t\treturn this.listRefs('targets');\n\t}\n\n\t/**\n\t * Adds a morph target to the primitive. All primitives in the same mesh must have the same\n\t * number of targets.\n\t */\n\tpublic addTarget(target: PrimitiveTarget): this {\n\t\treturn this.addRef('targets', target);\n\t}\n\n\t/**\n\t * Removes a morph target from the primitive. All primitives in the same mesh must have the same\n\t * number of targets.\n\t */\n\tpublic removeTarget(target: PrimitiveTarget): this {\n\t\treturn this.removeRef('targets', target);\n\t}\n}\n", "import { RefMap } from 'property-graph';\nimport { BufferViewUsage, type Nullable, PropertyType } from '../constants.js';\nimport type { Accessor } from './accessor.js';\nimport type { IExtensibleProperty } from './extensible-property.js';\nimport { Property } from './property.js';\n\ninterface IPrimitiveTarget extends IExtensibleProperty {\n\tattributes: RefMap<Accessor>;\n}\n\n/**\n * *Morph target or shape key used to deform one {@link Primitive} in a {@link Mesh}.*\n *\n * A PrimitiveTarget contains a `POSITION` attribute (and optionally `NORMAL` and `TANGENT`) that\n * can additively deform the base attributes on a {@link Mesh} {@link Primitive}. Vertex values\n * of `0, 0, 0` in the target will have no effect, whereas a value of `0, 1, 0` would offset that\n * vertex in the base geometry by y+=1. Morph targets can be fully or partially applied: their\n * default state is controlled by {@link Mesh.getWeights}, which can also be overridden for a\n * particular instantiation of a {@link Mesh}, using {@link Node.getWeights}.\n *\n * Reference:\n * - [glTF → Morph Targets](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#morph-targets)\n *\n * @category Properties\n */\nexport class PrimitiveTarget extends Property<IPrimitiveTarget> {\n\tpublic declare propertyType: PropertyType.PRIMITIVE_TARGET;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.PRIMITIVE_TARGET;\n\t}\n\n\tprotected getDefaults(): Nullable<IPrimitiveTarget> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { attributes: new RefMap<Accessor>() });\n\t}\n\n\t/** Returns a morph target vertex attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\treturn this.getRefMap('attributes', semantic);\n\t}\n\n\t/**\n\t * Sets a morph target vertex attribute to an {@link Accessor}.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: BufferViewUsage.ARRAY_BUFFER });\n\t}\n\n\t/**\n\t * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be\n\t * consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.listRefMapValues('attributes');\n\t}\n\n\t/**\n\t * Lists all morph target vertex attribute semantics associated. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.listRefMapKeys('attributes');\n\t}\n}\n", "import { RefSet } from 'property-graph';\nimport { type Nullable, PropertyType } from '../constants.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\nimport type { Node } from './node.js';\nimport { COPY_IDENTITY } from './property.js';\n\ninterface IScene extends IExtensibleProperty {\n\tchildren: RefSet<Node>;\n}\n\n/**\n * *Scenes represent a set of visual objects to render.*\n *\n * Typically a glTF file contains only a single Scene, although more are allowed and useful in some\n * cases. No particular meaning is associated with additional Scenes, except as defined by the\n * application. Scenes reference {@link Node}s, and a single Node cannot be a member of more than\n * one Scene.\n *\n * References:\n * - [glTF → Scenes](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#scenes)\n * - [glTF → Coordinate System and Units](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#coordinate-system-and-units)\n *\n * @category Properties\n */\nexport class Scene extends ExtensibleProperty<IScene> {\n\tpublic declare propertyType: PropertyType.SCENE;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.SCENE;\n\t}\n\n\tprotected getDefaults(): Nullable<IScene> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { children: new RefSet<Node>() });\n\t}\n\n\tpublic copy(other: this, resolve: typeof COPY_IDENTITY = COPY_IDENTITY): this {\n\t\t// Scene cannot be copied, only cloned. Copying is shallow, but nodes cannot have more than\n\t\t// one parent. Rather than leaving one of the two Scenes without children, throw an error here.\n\t\tif (resolve === COPY_IDENTITY) throw new Error('Scene cannot be copied.');\n\t\treturn super.copy(other, resolve);\n\t}\n\n\t/**\n\t * Adds a {@link Node} to the Scene.\n\t *\n\t * Requirements:\n\t *\n\t * 1. Nodes MAY be root children of multiple {@link Scene Scenes}\n\t * 2. Nodes MUST NOT be children of >1 Node\n\t * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}\n\t *\n\t * The `addChild` method enforces these restrictions automatically, and will\n\t * remove the new child from previous parents where needed. This behavior\n\t * may change in future major releases of the library.\n\t */\n\tpublic addChild(node: Node): this {\n\t\t// Remove existing parent.\n\t\tconst parentNode = node.getParentNode();\n\t\tif (parentNode) parentNode.removeChild(node);\n\t\treturn this.addRef('children', node);\n\t}\n\n\t/** Removes a {@link Node} from the Scene. */\n\tpublic removeChild(node: Node): this {\n\t\treturn this.removeRef('children', node);\n\t}\n\n\t/**\n\t * Lists all direct child {@link Node Nodes} in the Scene. Indirect\n\t * descendants (children of children) are not returned, but may be\n\t * reached recursively or with {@link Scene.traverse} instead.\n\t */\n\tpublic listChildren(): Node[] {\n\t\treturn this.listRefs('children');\n\t}\n\n\t/** Visits each {@link Node} in the Scene, including descendants, top-down. */\n\tpublic traverse(fn: (node: Node) => void): this {\n\t\tfor (const node of this.listChildren()) node.traverse(fn);\n\t\treturn this;\n\t}\n}\n", "import { RefSet } from 'property-graph';\nimport { BufferViewUsage, type Nullable, PropertyType } from '../constants.js';\nimport type { Accessor } from './accessor.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\nimport type { Node } from './node.js';\n\ninterface ISkin extends IExtensibleProperty {\n\tskeleton: Node;\n\tinverseBindMatrices: Accessor;\n\tjoints: RefSet<Node>;\n}\n\n/**\n * *Collection of {@link Node} joints and inverse bind matrices used with skinned {@link Mesh}\n * instances.*\n *\n * Reference\n * - [glTF → Skins](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#skins)\n *\n * @category Properties\n */\nexport class Skin extends ExtensibleProperty<ISkin> {\n\tpublic declare propertyType: PropertyType.SKIN;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.SKIN;\n\t}\n\n\tprotected getDefaults(): Nullable<ISkin> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tskeleton: null,\n\t\t\tinverseBindMatrices: null,\n\t\t\tjoints: new RefSet<Node>(),\n\t\t});\n\t}\n\n\t/**\n\t * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n\t * hierarchy or a direct or indirect parent node of the closest common root.\n\t */\n\tpublic getSkeleton(): Node | null {\n\t\treturn this.getRef('skeleton');\n\t}\n\n\t/**\n\t * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n\t * hierarchy or a direct or indirect parent node of the closest common root.\n\t */\n\tpublic setSkeleton(skeleton: Node | null): this {\n\t\treturn this.setRef('skeleton', skeleton);\n\t}\n\n\t/**\n\t * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n\t * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n\t * pre-applied.\n\t */\n\tpublic getInverseBindMatrices(): Accessor | null {\n\t\treturn this.getRef('inverseBindMatrices');\n\t}\n\n\t/**\n\t * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n\t * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n\t * pre-applied.\n\t */\n\tpublic setInverseBindMatrices(inverseBindMatrices: Accessor | null): this {\n\t\treturn this.setRef('inverseBindMatrices', inverseBindMatrices, {\n\t\t\tusage: BufferViewUsage.INVERSE_BIND_MATRICES,\n\t\t});\n\t}\n\n\t/** Adds a joint {@link Node} to this {@link Skin}. */\n\tpublic addJoint(joint: Node): this {\n\t\treturn this.addRef('joints', joint);\n\t}\n\n\t/** Removes a joint {@link Node} from this {@link Skin}. */\n\tpublic removeJoint(joint: Node): this {\n\t\treturn this.removeRef('joints', joint);\n\t}\n\n\t/** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */\n\tpublic listJoints(): Node[] {\n\t\treturn this.listRefs('joints');\n\t}\n}\n", "import { type Nullable, PropertyType, type vec2 } from '../constants.js';\nimport { BufferUtils, FileUtils, ImageUtils } from '../utils/index.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\n\ninterface ITexture extends IExtensibleProperty {\n\timage: Uint8Array | null;\n\tmimeType: string;\n\turi: string;\n}\n\n/**\n * *Texture, or images, referenced by {@link Material} properties.*\n *\n * Textures in glTF Transform are a combination of glTF's `texture` and `image` properties, and\n * should be unique within a document, such that no other texture contains the same\n * {@link Texture.getImage getImage()} data. Where duplicates may already exist, the `dedup({textures: true})`\n * transform can remove them. A {@link Document} with N texture properties will be exported to a\n * glTF file with N `image` properties, and the minimum number of `texture` properties necessary\n * for the materials that use it.\n *\n * For properties associated with a particular _use_ of a texture, see {@link TextureInfo}.\n *\n * Reference:\n * - [glTF → Textures](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#textures)\n * - [glTF → Images](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#images)\n *\n * @category Properties\n */\nexport class Texture extends ExtensibleProperty<ITexture> {\n\tpublic declare propertyType: PropertyType.TEXTURE;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.TEXTURE;\n\t}\n\n\tprotected getDefaults(): Nullable<ITexture> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { image: null, mimeType: '', uri: '' });\n\t}\n\n\t/**********************************************************************************************\n\t * MIME type / format.\n\t */\n\n\t/** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */\n\tpublic getMimeType(): string {\n\t\treturn this.get('mimeType') || ImageUtils.extensionToMimeType(FileUtils.extension(this.get('uri')));\n\t}\n\n\t/**\n\t * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not\n\t * have a URI, a MIME type is required for correct export.\n\t */\n\tpublic setMimeType(mimeType: string): this {\n\t\treturn this.set('mimeType', mimeType);\n\t}\n\n\t/**********************************************************************************************\n\t * URI / filename.\n\t */\n\n\t/** Returns the URI (e.g. 'path/to/file.png') for this texture. */\n\tpublic getURI(): string {\n\t\treturn this.get('uri');\n\t}\n\n\t/**\n\t * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME\n\t * type, a URI is required for correct export.\n\t */\n\tpublic setURI(uri: string): this {\n\t\tthis.set('uri', uri);\n\t\tconst mimeType = ImageUtils.extensionToMimeType(FileUtils.extension(uri));\n\t\tif (mimeType) this.set('mimeType', mimeType);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Image data.\n\t */\n\n\t/** Returns the raw image data for this texture. */\n\tpublic getImage(): Uint8Array | null {\n\t\treturn this.get('image');\n\t}\n\n\t/** Sets the raw image data for this texture. */\n\tpublic setImage(image: Uint8Array): this {\n\t\treturn this.set('image', BufferUtils.assertView(image));\n\t}\n\n\t/** Returns the size, in pixels, of this texture. */\n\tpublic getSize(): vec2 | null {\n\t\tconst image = this.get('image');\n\t\tif (!image) return null;\n\t\treturn ImageUtils.getSize(image, this.getMimeType());\n\t}\n}\n", "import type { Graph } from 'property-graph';\nimport { RefSet } from 'property-graph';\nimport { type Nullable, PropertyType, VERSION } from '../constants.js';\nimport type { Extension } from '../extension.js';\nimport { Accessor } from './accessor.js';\nimport { Animation } from './animation.js';\nimport { Buffer } from './buffer.js';\nimport { Camera } from './camera.js';\nimport { ExtensibleProperty, type IExtensibleProperty } from './extensible-property.js';\nimport type { ExtensionProperty } from './extension-property.js';\nimport { Material } from './material.js';\nimport { Mesh } from './mesh.js';\nimport { Node } from './node.js';\nimport { COPY_IDENTITY, type Property } from './property.js';\nimport { Scene } from './scene.js';\nimport { Skin } from './skin.js';\nimport { Texture } from './texture.js';\n\ninterface IAsset {\n\tversion: string;\n\tminVersion?: string;\n\tgenerator?: string;\n\tcopyright?: string;\n\t[key: string]: unknown;\n}\n\ninterface IRoot extends IExtensibleProperty {\n\tasset: IAsset;\n\tdefaultScene: Scene;\n\n\taccessors: RefSet<Accessor>;\n\tanimations: RefSet<Animation>;\n\tbuffers: RefSet<Buffer>;\n\tcameras: RefSet<Camera>;\n\tmaterials: RefSet<Material>;\n\tmeshes: RefSet<Mesh>;\n\tnodes: RefSet<Node>;\n\tscenes: RefSet<Scene>;\n\tskins: RefSet<Skin>;\n\ttextures: RefSet<Texture>;\n}\n\n/**\n * *Root property of a glTF asset.*\n *\n * Any properties to be exported with a particular asset must be referenced (directly or\n * indirectly) by the root. Metadata about the asset's license, generator, and glTF specification\n * version are stored in the asset, accessible with {@link Root.getAsset}.\n *\n * Properties are added to the root with factory methods on its {@link Document}, and removed by\n * calling {@link Property.dispose}() on the resource. Any properties that have been created but\n * not disposed will be included when calling the various `root.list*()` methods.\n *\n * A document's root cannot be removed, and no other root may be created. Unlike other\n * {@link Property} types, the `.dispose()`, `.detach()` methods have no useful function on a\n * Root property.\n *\n * Usage:\n *\n * ```ts\n * const root = document.getRoot();\n * const scene = document.createScene('myScene');\n * const node = document.createNode('myNode');\n * scene.addChild(node);\n *\n * console.log(root.listScenes()); // → [scene x 1]\n * ```\n *\n * Reference: [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nexport class Root extends ExtensibleProperty<IRoot> {\n\tpublic declare propertyType: PropertyType.ROOT;\n\n\tprivate readonly _extensions: Set<Extension> = new Set();\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ROOT;\n\t}\n\n\tprotected getDefaults(): Nullable<IRoot> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tasset: {\n\t\t\t\tgenerator: `glTF-Transform ${VERSION}`,\n\t\t\t\tversion: '2.0',\n\t\t\t},\n\t\t\tdefaultScene: null,\n\t\t\taccessors: new RefSet<Accessor>(),\n\t\t\tanimations: new RefSet<Animation>(),\n\t\t\tbuffers: new RefSet<Buffer>(),\n\t\t\tcameras: new RefSet<Camera>(),\n\t\t\tmaterials: new RefSet<Material>(),\n\t\t\tmeshes: new RefSet<Mesh>(),\n\t\t\tnodes: new RefSet<Node>(),\n\t\t\tscenes: new RefSet<Scene>(),\n\t\t\tskins: new RefSet<Skin>(),\n\t\t\ttextures: new RefSet<Texture>(),\n\t\t});\n\t}\n\n\t/** @internal */\n\tconstructor(graph: Graph<Property>) {\n\t\tsuper(graph);\n\t\tgraph.addEventListener('node:create', (event) => {\n\t\t\tthis._addChildOfRoot(event.target as Property);\n\t\t});\n\t}\n\n\tpublic clone(): this {\n\t\tthrow new Error('Root cannot be cloned.');\n\t}\n\n\tpublic copy(other: this, resolve: typeof COPY_IDENTITY = COPY_IDENTITY): this {\n\t\t// Root cannot be cloned in isolation: only with its Document. Extensions are managed by\n\t\t// the Document during cloning. The Root, and only the Root, should keep existing\n\t\t// references while copying to avoid overwriting during a merge.\n\t\tif (resolve === COPY_IDENTITY) throw new Error('Root cannot be copied.');\n\n\t\t// IMPORTANT: Root cannot call super.copy(), which removes existing references.\n\n\t\tthis.set('asset', { ...other.get('asset') });\n\t\tthis.setName(other.getName());\n\t\tthis.setExtras({ ...other.getExtras() });\n\t\tthis.setDefaultScene(other.getDefaultScene() ? resolve(other.getDefaultScene()!) : null);\n\n\t\tfor (const extensionName of other.listRefMapKeys('extensions')) {\n\t\t\tconst otherExtension = other.getExtension(extensionName) as ExtensionProperty;\n\t\t\tthis.setExtension(extensionName, resolve(otherExtension));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprivate _addChildOfRoot(child: Property): this {\n\t\tif (child instanceof Scene) {\n\t\t\tthis.addRef('scenes', child);\n\t\t} else if (child instanceof Node) {\n\t\t\tthis.addRef('nodes', child);\n\t\t} else if (child instanceof Camera) {\n\t\t\tthis.addRef('cameras', child);\n\t\t} else if (child instanceof Skin) {\n\t\t\tthis.addRef('skins', child);\n\t\t} else if (child instanceof Mesh) {\n\t\t\tthis.addRef('meshes', child);\n\t\t} else if (child instanceof Material) {\n\t\t\tthis.addRef('materials', child);\n\t\t} else if (child instanceof Texture) {\n\t\t\tthis.addRef('textures', child);\n\t\t} else if (child instanceof Animation) {\n\t\t\tthis.addRef('animations', child);\n\t\t} else if (child instanceof Accessor) {\n\t\t\tthis.addRef('accessors', child);\n\t\t} else if (child instanceof Buffer) {\n\t\t\tthis.addRef('buffers', child);\n\t\t}\n\t\t// No error for untracked property types.\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the `asset` object, which specifies the target glTF version of the asset. Additional\n\t * metadata can be stored in optional properties such as `generator` or `copyright`.\n\t *\n\t * Reference: [glTF → Asset](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#asset)\n\t */\n\tpublic getAsset(): IAsset {\n\t\treturn this.get('asset');\n\t}\n\n\t/**********************************************************************************************\n\t * Extensions.\n\t */\n\n\t/** Lists all {@link Extension Extensions} enabled for this root. */\n\tpublic listExtensionsUsed(): Extension[] {\n\t\treturn Array.from(this._extensions);\n\t}\n\n\t/** Lists all {@link Extension Extensions} enabled and required for this root. */\n\tpublic listExtensionsRequired(): Extension[] {\n\t\treturn this.listExtensionsUsed().filter((extension) => extension.isRequired());\n\t}\n\n\t/** @internal */\n\tpublic _enableExtension(extension: Extension): this {\n\t\tthis._extensions.add(extension);\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tpublic _disableExtension(extension: Extension): this {\n\t\tthis._extensions.delete(extension);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Properties.\n\t */\n\n\t/** Lists all {@link Scene} properties associated with this root. */\n\tpublic listScenes(): Scene[] {\n\t\treturn this.listRefs('scenes');\n\t}\n\n\t/** Default {@link Scene} associated with this root. */\n\tpublic setDefaultScene(defaultScene: Scene | null): this {\n\t\treturn this.setRef('defaultScene', defaultScene);\n\t}\n\n\t/** Default {@link Scene} associated with this root. */\n\tpublic getDefaultScene(): Scene | null {\n\t\treturn this.getRef('defaultScene');\n\t}\n\n\t/** Lists all {@link Node} properties associated with this root. */\n\tpublic listNodes(): Node[] {\n\t\treturn this.listRefs('nodes');\n\t}\n\n\t/** Lists all {@link Camera} properties associated with this root. */\n\tpublic listCameras(): Camera[] {\n\t\treturn this.listRefs('cameras');\n\t}\n\n\t/** Lists all {@link Skin} properties associated with this root. */\n\tpublic listSkins(): Skin[] {\n\t\treturn this.listRefs('skins');\n\t}\n\n\t/** Lists all {@link Mesh} properties associated with this root. */\n\tpublic listMeshes(): Mesh[] {\n\t\treturn this.listRefs('meshes');\n\t}\n\n\t/** Lists all {@link Material} properties associated with this root. */\n\tpublic listMaterials(): Material[] {\n\t\treturn this.listRefs('materials');\n\t}\n\n\t/** Lists all {@link Texture} properties associated with this root. */\n\tpublic listTextures(): Texture[] {\n\t\treturn this.listRefs('textures');\n\t}\n\n\t/** Lists all {@link Animation} properties associated with this root. */\n\tpublic listAnimations(): Animation[] {\n\t\treturn this.listRefs('animations');\n\t}\n\n\t/** Lists all {@link Accessor} properties associated with this root. */\n\tpublic listAccessors(): Accessor[] {\n\t\treturn this.listRefs('accessors');\n\t}\n\n\t/** Lists all {@link Buffer} properties associated with this root. */\n\tpublic listBuffers(): Buffer[] {\n\t\treturn this.listRefs('buffers');\n\t}\n}\n", "import { Graph } from 'property-graph';\nimport type { Extension } from './extension.js';\nimport {\n\tAccessor,\n\tAnimation,\n\tAnimationChannel,\n\tAnimationSampler,\n\tBuffer,\n\tCamera,\n\tMaterial,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\ttype Property,\n\tRoot,\n\tScene,\n\tSkin,\n\tTexture,\n} from './properties/index.js';\nimport { type ILogger, Logger } from './utils/index.js';\n\nexport interface TransformContext {\n\tstack: string[];\n}\n\nexport type Transform = (doc: Document, context?: TransformContext) => void;\n\n/**\n * *Wraps a glTF asset and its resources for easier modification.*\n *\n * Documents manage glTF assets and the relationships among dependencies. The document wrapper\n * allow tools to read and write changes without dealing with array indices or byte offsets, which\n * would otherwise require careful management over the course of a file modification. An internal\n * graph structure allows any property in the glTF file to maintain references to its dependencies,\n * and makes it easy to determine where a particular property dependency is being used. For\n * example, finding a list of materials that use a particular texture is as simple as calling\n * {@link Texture.listParents}().\n *\n * A new resource {@link Property} (e.g. a {@link Mesh} or {@link Material}) is created by calling\n * 'create' methods on the document. Resources are destroyed by calling {@link Property.dispose}().\n *\n * ```ts\n * import fs from 'fs/promises';\n * import { Document } from '@gltf-transform/core';\n * import { dedup } from '@gltf-transform/functions';\n *\n * const document = new Document();\n *\n * const texture1 = document.createTexture('myTexture')\n * \t.setImage(await fs.readFile('path/to/image.png'))\n * \t.setMimeType('image/png');\n * const texture2 = document.createTexture('myTexture2')\n * \t.setImage(await fs.readFile('path/to/image2.png'))\n * \t.setMimeType('image/png');\n *\n * // Document containing duplicate copies of the same texture.\n * document.getRoot().listTextures(); // → [texture x 2]\n *\n * await document.transform(\n * \tdedup({textures: true}),\n * \t// ...\n * );\n *\n * // Document with duplicate textures removed.\n * document.getRoot().listTextures(); // → [texture x 1]\n * ```\n *\n * Reference:\n * - [glTF → Basics](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#gltf-basics)\n * - [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Documents\n */\nexport class Document {\n\tprivate _graph: Graph<Property> = new Graph<Property>();\n\tprivate _root: Root = new Root(this._graph);\n\tprivate _logger: ILogger = Logger.DEFAULT_INSTANCE;\n\n\t/**\n\t * Enables lookup of a Document from its Graph. For internal use, only.\n\t * @internal\n\t * @experimental\n\t */\n\tprivate static _GRAPH_DOCUMENTS = new WeakMap<Graph<Property>, Document>();\n\n\t/**\n\t * Returns the Document associated with a given Graph, if any.\n\t * @hidden\n\t * @experimental\n\t */\n\tpublic static fromGraph(graph: Graph<Property>): Document | null {\n\t\treturn Document._GRAPH_DOCUMENTS.get(graph) || null;\n\t}\n\n\t/** Creates a new Document, representing an empty glTF asset. */\n\tpublic constructor() {\n\t\tDocument._GRAPH_DOCUMENTS.set(this._graph, this);\n\t}\n\n\t/** Returns the glTF {@link Root} property. */\n\tpublic getRoot(): Root {\n\t\treturn this._root;\n\t}\n\n\t/**\n\t * Returns the {@link Graph} representing connectivity of resources within this document.\n\t * @hidden\n\t */\n\tpublic getGraph(): Graph<Property> {\n\t\treturn this._graph;\n\t}\n\n\t/** Returns the {@link Logger} instance used for any operations performed on this document. */\n\tpublic getLogger(): ILogger {\n\t\treturn this._logger;\n\t}\n\n\t/**\n\t * Overrides the {@link Logger} instance used for any operations performed on this document.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * doc\n\t * \t.setLogger(new Logger(Logger.Verbosity.SILENT))\n\t * \t.transform(dedup(), weld());\n\t * ```\n\t */\n\tpublic setLogger(logger: ILogger): Document {\n\t\tthis._logger = logger;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clones this Document, copying all resources within it.\n\t * @deprecated Use 'cloneDocument(document)' from '@gltf-transform/functions'.\n\t * @hidden\n\t * @internal\n\t */\n\tpublic clone(): Document {\n\t\tthrow new Error(`Use 'cloneDocument(source)' from '@gltf-transform/functions'.`);\n\t}\n\n\t/**\n\t * Merges the content of another Document into this one, without affecting the original.\n\t * @deprecated Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.\n\t * @hidden\n\t * @internal\n\t */\n\tpublic merge(_other: Document): this {\n\t\tthrow new Error(`Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.`);\n\t}\n\n\t/**\n\t * Applies a series of modifications to this document. Each transformation is asynchronous,\n\t * takes the {@link Document} as input, and returns nothing. Transforms are applied in the\n\t * order given, which may affect the final result.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * await doc.transform(\n\t * \tdedup(),\n\t * \tprune()\n\t * );\n\t * ```\n\t *\n\t * @param transforms List of synchronous transformation functions to apply.\n\t */\n\tpublic async transform(...transforms: Transform[]): Promise<this> {\n\t\tconst stack = transforms.map((fn) => fn.name);\n\t\tfor (const transform of transforms) {\n\t\t\tawait transform(this, { stack });\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Extension factory method.\n\t */\n\n\t/**\n\t * Creates a new {@link Extension}, for the extension type of the given constructor. If the\n\t * extension is already enabled for this Document, the previous Extension reference is reused.\n\t */\n\tcreateExtension<T extends Extension>(ctor: new (doc: Document) => T): T {\n\t\tconst extensionName = (ctor as unknown as { EXTENSION_NAME: 'string' }).EXTENSION_NAME;\n\t\tconst prevExtension = this.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.find((ext) => ext.extensionName === extensionName);\n\t\treturn (prevExtension || new ctor(this)) as T;\n\t}\n\n\t/**********************************************************************************************\n\t * Property factory methods.\n\t */\n\n\t/** Creates a new {@link Scene} attached to this document's {@link Root}. */\n\tcreateScene(name = ''): Scene {\n\t\treturn new Scene(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Node} attached to this document's {@link Root}. */\n\tcreateNode(name = ''): Node {\n\t\treturn new Node(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Camera} attached to this document's {@link Root}. */\n\tcreateCamera(name = ''): Camera {\n\t\treturn new Camera(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Skin} attached to this document's {@link Root}. */\n\tcreateSkin(name = ''): Skin {\n\t\treturn new Skin(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Mesh} attached to this document's {@link Root}. */\n\tcreateMesh(name = ''): Mesh {\n\t\treturn new Mesh(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreatePrimitive(): Primitive {\n\t\treturn new Primitive(this._graph);\n\t}\n\n\t/**\n\t * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a\n\t * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreatePrimitiveTarget(name = ''): PrimitiveTarget {\n\t\treturn new PrimitiveTarget(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Material} attached to this document's {@link Root}. */\n\tcreateMaterial(name = ''): Material {\n\t\treturn new Material(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Texture} attached to this document's {@link Root}. */\n\tcreateTexture(name = ''): Texture {\n\t\treturn new Texture(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Animation} attached to this document's {@link Root}. */\n\tcreateAnimation(name = ''): Animation {\n\t\treturn new Animation(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreateAnimationChannel(name = ''): AnimationChannel {\n\t\treturn new AnimationChannel(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreateAnimationSampler(name = ''): AnimationSampler {\n\t\treturn new AnimationSampler(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Accessor} attached to this document's {@link Root}. */\n\tcreateAccessor(name = '', buffer: Buffer | null = null): Accessor {\n\t\tif (!buffer) {\n\t\t\tbuffer = this.getRoot().listBuffers()[0];\n\t\t}\n\t\treturn new Accessor(this._graph, name).setBuffer(buffer);\n\t}\n\n\t/** Creates a new {@link Buffer} attached to this document's {@link Root}. */\n\tcreateBuffer(name = ''): Buffer {\n\t\treturn new Buffer(this._graph, name);\n\t}\n}\n", "import type { GraphEdgeEvent, GraphEvent, GraphNodeEvent } from 'property-graph';\nimport type { PropertyType } from './constants.js';\nimport type { Document } from './document.js';\nimport type { ReaderContext, WriterContext } from './io/index.js';\nimport { ExtensionProperty } from './properties/index.js';\n\n/**\n * *Base class for all Extensions.*\n *\n * Extensions enhance a glTF {@link Document} with additional features and schema, beyond the core\n * glTF specification. Common extensions may be imported from the `@gltf-transform/extensions`\n * package, or custom extensions may be created by extending this base class.\n *\n * An extension is added to a Document by calling {@link Document.createExtension} with the\n * extension constructor. The extension object may then be used to construct\n * {@link ExtensionProperty} instances, which are attached to properties throughout the Document\n * as prescribed by the extension itself.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#specifying-extensions)\n * - [glTF Extension Registry](https://github.com/KhronosGroup/gltf/blob/main/extensions)\n *\n * @category Extensions\n */\nexport abstract class Extension {\n\t/** Official name of the extension. */\n\tpublic static EXTENSION_NAME: string;\n\t/** Official name of the extension. */\n\tpublic readonly extensionName: string = '';\n\t/**\n\t * Before reading, extension should be called for these {@link Property} types. *Most\n\t * extensions don't need to implement this.*\n\t * @hidden\n\t */\n\tpublic readonly prereadTypes: PropertyType[] = [];\n\t/**\n\t * Before writing, extension should be called for these {@link Property} types. *Most\n\t * extensions don't need to implement this.*\n\t * @hidden\n\t */\n\tpublic readonly prewriteTypes: PropertyType[] = [];\n\n\t/** @hidden Dependency IDs needed to read this extension, to be installed before I/O. */\n\tpublic readonly readDependencies: string[] = [];\n\t/** @hidden Dependency IDs needed to write this extension, to be installed before I/O. */\n\tpublic readonly writeDependencies: string[] = [];\n\n\t/** @hidden */\n\tprotected readonly document: Document;\n\n\t/** @hidden */\n\tprotected required = false;\n\n\t/** @hidden */\n\tprotected properties: Set<ExtensionProperty> = new Set();\n\n\t/** @hidden */\n\tprivate _listener: (event: unknown) => void;\n\n\t/** @hidden */\n\tconstructor(document: Document) {\n\t\tthis.document = document;\n\n\t\tdocument.getRoot()._enableExtension(this);\n\n\t\tthis._listener = (_event: unknown): void => {\n\t\t\tconst event = _event as GraphNodeEvent | GraphEdgeEvent | GraphEvent;\n\t\t\tconst target = event.target as ExtensionProperty | unknown;\n\t\t\tif (target instanceof ExtensionProperty && target.extensionName === this.extensionName) {\n\t\t\t\tif (event.type === 'node:create') this._addExtensionProperty(target);\n\t\t\t\tif (event.type === 'node:dispose') this._removeExtensionProperty(target);\n\t\t\t}\n\t\t};\n\n\t\tconst graph = document.getGraph();\n\t\tgraph.addEventListener('node:create', this._listener);\n\t\tgraph.addEventListener('node:dispose', this._listener);\n\t}\n\n\t/** Disables and removes the extension from the Document. */\n\tpublic dispose(): void {\n\t\tthis.document.getRoot()._disableExtension(this);\n\t\tconst graph = this.document.getGraph();\n\t\tgraph.removeEventListener('node:create', this._listener);\n\t\tgraph.removeEventListener('node:dispose', this._listener);\n\t\tfor (const property of this.properties) {\n\t\t\tproperty.dispose();\n\t\t}\n\t}\n\n\t/** @hidden Performs first-time setup for the extension. Must be idempotent. */\n\tpublic static register(): void {}\n\n\t/**\n\t * Indicates to the client whether it is OK to load the asset when this extension is not\n\t * recognized. Optional extensions are generally preferred, if there is not a good reason\n\t * to require a client to completely fail when an extension isn't known.\n\t */\n\tpublic isRequired(): boolean {\n\t\treturn this.required;\n\t}\n\n\t/**\n\t * Indicates to the client whether it is OK to load the asset when this extension is not\n\t * recognized. Optional extensions are generally preferred, if there is not a good reason\n\t * to require a client to completely fail when an extension isn't known.\n\t */\n\tpublic setRequired(required: boolean): this {\n\t\tthis.required = required;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Lists all {@link ExtensionProperty} instances associated with, or created by, this\n\t * extension. Includes only instances that are attached to the Document's graph; detached\n\t * instances will be excluded.\n\t */\n\tpublic listProperties(): ExtensionProperty[] {\n\t\treturn Array.from(this.properties);\n\t}\n\n\t/**********************************************************************************************\n\t * ExtensionProperty management.\n\t */\n\n\t/** @internal */\n\tprivate _addExtensionProperty(property: ExtensionProperty): this {\n\t\tthis.properties.add(property);\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tprivate _removeExtensionProperty(property: ExtensionProperty): this {\n\t\tthis.properties.delete(property);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * I/O implementation.\n\t */\n\n\t/** @hidden Installs dependencies required by the extension. */\n\tpublic install(_key: string, _dependency: unknown): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method may\n\t * optionally be implemented by an extension, and should then support any property type\n\t * declared by the Extension's {@link Extension.prereadTypes} list. The Extension will\n\t * be given a ReaderContext instance, and is expected to update either the context or its\n\t * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n\t * implement this.*\n\t * @hidden\n\t */\n\tpublic preread(_readerContext: ReaderContext, _propertyType: PropertyType): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method may\n\t * optionally be implemented by an extension, and should then support any property type\n\t * declared by the Extension's {@link Extension.prewriteTypes} list. The Extension will\n\t * be given a WriterContext instance, and is expected to update either the context or its\n\t * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n\t * implement this.*\n\t * @hidden\n\t */\n\tpublic prewrite(_writerContext: WriterContext, _propertyType: PropertyType): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method must be\n\t * implemented by each extension in order to support reading files. The extension will be\n\t * given a ReaderContext instance, and should update the current {@link Document} accordingly.\n\t * @hidden\n\t */\n\tpublic abstract read(readerContext: ReaderContext): this;\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method must be\n\t * implemented by each extension in order to support writing files. The extension will be\n\t * given a WriterContext instance, and should modify the {@link JSONDocument} output\n\t * accordingly. Adding the extension name to the `extensionsUsed` and `extensionsRequired` list\n\t * is done automatically, and should not be included here.\n\t * @hidden\n\t */\n\tpublic abstract write(writerContext: WriterContext): this;\n}\n", "import type { JSONDocument } from '../json-document.js';\nimport type {\n\tAccessor,\n\tAnimation,\n\tBuffer,\n\tCamera,\n\tMaterial,\n\tMesh,\n\tNode,\n\tScene,\n\tSkin,\n\tTexture,\n\tTextureInfo,\n} from '../properties/index.js';\nimport type { GLTF } from '../types/gltf.js';\n\n/**\n * Model class providing glTF Transform objects representing each definition in the glTF file, used\n * by a {@link GLTFReader} and its {@link Extension} implementations. Indices of all properties will be\n * consistent with the glTF file.\n *\n * @hidden\n */\nexport class ReaderContext {\n\tpublic buffers: Buffer[] = [];\n\tpublic bufferViews: Uint8Array[] = [];\n\tpublic bufferViewBuffers: Buffer[] = [];\n\tpublic accessors: Accessor[] = [];\n\tpublic textures: Texture[] = [];\n\tpublic textureInfos: Map<TextureInfo, GLTF.ITextureInfo> = new Map();\n\tpublic materials: Material[] = [];\n\tpublic meshes: Mesh[] = [];\n\tpublic cameras: Camera[] = [];\n\tpublic nodes: Node[] = [];\n\tpublic skins: Skin[] = [];\n\tpublic animations: Animation[] = [];\n\tpublic scenes: Scene[] = [];\n\n\tconstructor(public readonly jsonDoc: JSONDocument) {}\n\n\tpublic setTextureInfo(textureInfo: TextureInfo, textureInfoDef: GLTF.ITextureInfo): void {\n\t\tthis.textureInfos.set(textureInfo, textureInfoDef);\n\n\t\tif (textureInfoDef.texCoord !== undefined) {\n\t\t\ttextureInfo.setTexCoord(textureInfoDef.texCoord);\n\t\t}\n\t\tif (textureInfoDef.extras !== undefined) {\n\t\t\ttextureInfo.setExtras(textureInfoDef.extras);\n\t\t}\n\n\t\tconst textureDef = this.jsonDoc.json.textures![textureInfoDef.index];\n\n\t\tif (textureDef.sampler === undefined) return;\n\n\t\tconst samplerDef = this.jsonDoc.json.samplers![textureDef.sampler];\n\n\t\tif (samplerDef.magFilter !== undefined) {\n\t\t\ttextureInfo.setMagFilter(samplerDef.magFilter);\n\t\t}\n\t\tif (samplerDef.minFilter !== undefined) {\n\t\t\ttextureInfo.setMinFilter(samplerDef.minFilter);\n\t\t}\n\t\tif (samplerDef.wrapS !== undefined) {\n\t\t\ttextureInfo.setWrapS(samplerDef.wrapS);\n\t\t}\n\t\tif (samplerDef.wrapT !== undefined) {\n\t\t\ttextureInfo.setWrapT(samplerDef.wrapT);\n\t\t}\n\t}\n}\n", "import {\n\tComponentTypeToTypedArray,\n\tGLB_BUFFER,\n\ttype mat4,\n\tPropertyType,\n\ttype TypedArray,\n\ttype vec3,\n\ttype vec4,\n} from '../constants.js';\nimport { Document } from '../document.js';\nimport type { Extension } from '../extension.js';\nimport type { JSONDocument } from '../json-document.js';\nimport { Accessor, AnimationSampler, Camera } from '../properties/index.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { BufferUtils, FileUtils, type ILogger, ImageUtils, Logger, MathUtils } from '../utils/index.js';\nimport { ReaderContext } from './reader-context.js';\n\nexport interface ReaderOptions {\n\tlogger?: ILogger;\n\textensions: (typeof Extension)[];\n\tdependencies: { [key: string]: unknown };\n}\n\nconst DEFAULT_OPTIONS: ReaderOptions = {\n\tlogger: Logger.DEFAULT_INSTANCE,\n\textensions: [],\n\tdependencies: {},\n};\n\nconst SUPPORTED_PREREAD_TYPES = new Set<PropertyType>([\n\tPropertyType.BUFFER,\n\tPropertyType.TEXTURE,\n\tPropertyType.MATERIAL,\n\tPropertyType.MESH,\n\tPropertyType.PRIMITIVE,\n\tPropertyType.NODE,\n\tPropertyType.SCENE,\n]);\n\n/** @internal */\nexport class GLTFReader {\n\tpublic static read(jsonDoc: JSONDocument, _options: ReaderOptions = DEFAULT_OPTIONS): Document {\n\t\tconst options = { ...DEFAULT_OPTIONS, ..._options } as Required<ReaderOptions>;\n\t\tconst { json } = jsonDoc;\n\t\tconst document = new Document().setLogger(options.logger);\n\n\t\tthis.validate(jsonDoc, options);\n\n\t\t/* Reader context. */\n\n\t\tconst context = new ReaderContext(jsonDoc);\n\n\t\t/** Asset. */\n\n\t\tconst assetDef = json.asset;\n\t\tconst asset = document.getRoot().getAsset();\n\n\t\tif (assetDef.copyright) asset.copyright = assetDef.copyright;\n\t\tif (assetDef.extras) asset.extras = assetDef.extras;\n\n\t\tif (json.extras !== undefined) {\n\t\t\tdocument.getRoot().setExtras({ ...json.extras });\n\t\t}\n\n\t\t/** Extensions (1/2). */\n\n\t\tconst extensionsUsed = json.extensionsUsed || [];\n\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\toptions.extensions.sort((a, b) => (a.EXTENSION_NAME > b.EXTENSION_NAME ? 1 : -1));\n\n\t\tfor (const Extension of options.extensions) {\n\t\t\tif (extensionsUsed.includes(Extension.EXTENSION_NAME)) {\n\t\t\t\t// Create extension.\n\t\t\t\tconst extension = document\n\t\t\t\t\t.createExtension(Extension as unknown as new (doc: Document) => Extension)\n\t\t\t\t\t.setRequired(extensionsRequired.includes(Extension.EXTENSION_NAME));\n\n\t\t\t\t// Warn on unsupported preread hooks.\n\t\t\t\tconst unsupportedHooks = extension.prereadTypes.filter((type) => !SUPPORTED_PREREAD_TYPES.has(type));\n\t\t\t\tif (unsupportedHooks.length) {\n\t\t\t\t\toptions.logger.warn(\n\t\t\t\t\t\t`Preread hooks for some types (${unsupportedHooks.join()}), requested by extension ` +\n\t\t\t\t\t\t\t`${extension.extensionName}, are unsupported. Please file an issue or a PR.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Install dependencies.\n\t\t\t\tfor (const key of extension.readDependencies) {\n\t\t\t\t\textension.install(key, options.dependencies[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** Buffers. */\n\n\t\tconst bufferDefs = json.buffers || [];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.BUFFER))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.BUFFER));\n\t\tcontext.buffers = bufferDefs.map((bufferDef) => {\n\t\t\tconst buffer = document.createBuffer(bufferDef.name);\n\n\t\t\tif (bufferDef.extras) buffer.setExtras(bufferDef.extras);\n\n\t\t\tif (bufferDef.uri && bufferDef.uri.indexOf('__') !== 0) {\n\t\t\t\tbuffer.setURI(bufferDef.uri);\n\t\t\t}\n\n\t\t\treturn buffer;\n\t\t});\n\n\t\t/** Buffer views. */\n\n\t\tconst bufferViewDefs = json.bufferViews || [];\n\t\tcontext.bufferViewBuffers = bufferViewDefs.map((bufferViewDef, index) => {\n\t\t\tif (!context.bufferViews[index]) {\n\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\tcontext.bufferViews[index] = BufferUtils.toView(resource, byteOffset, bufferViewDef.byteLength);\n\t\t\t}\n\n\t\t\treturn context.buffers[bufferViewDef.buffer];\n\t\t});\n\n\t\t/** Accessors. */\n\n\t\t// Accessor .count and .componentType properties are inferred dynamically.\n\t\tconst accessorDefs = json.accessors || [];\n\t\tcontext.accessors = accessorDefs.map((accessorDef) => {\n\t\t\tconst buffer = context.bufferViewBuffers[accessorDef.bufferView!];\n\t\t\tconst accessor = document.createAccessor(accessorDef.name, buffer).setType(accessorDef.type);\n\n\t\t\tif (accessorDef.extras) accessor.setExtras(accessorDef.extras);\n\n\t\t\tif (accessorDef.normalized !== undefined) {\n\t\t\t\taccessor.setNormalized(accessorDef.normalized);\n\t\t\t}\n\n\t\t\t// Sparse accessors, KHR_draco_mesh_compression, and EXT_meshopt_compression.\n\t\t\tif (accessorDef.bufferView === undefined) return accessor;\n\n\t\t\t// NOTICE: We mark sparse accessors at the end of the I/O reading process. Consider an\n\t\t\t// accessor to be 'sparse' if it (A) includes sparse value overrides, or (B) does not\n\t\t\t// define .bufferView _and_ no extension provides that data.\n\n\t\t\taccessor.setArray(getAccessorArray(accessorDef, context));\n\t\t\treturn accessor;\n\t\t});\n\n\t\t/** Textures. */\n\n\t\t// glTF Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n\t\t// with image files. The glTF file may contain more one texture per image, where images\n\t\t// are reused with different sampler properties.\n\t\tconst imageDefs = json.images || [];\n\t\tconst textureDefs = json.textures || [];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.TEXTURE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.TEXTURE));\n\t\tcontext.textures = imageDefs.map((imageDef) => {\n\t\t\tconst texture = document.createTexture(imageDef.name);\n\n\t\t\t// glTF Image corresponds 1:1 with glTF Transform Texture. See `writer.ts`.\n\t\t\tif (imageDef.extras) texture.setExtras(imageDef.extras);\n\n\t\t\tif (imageDef.bufferView !== undefined) {\n\t\t\t\tconst bufferViewDef = json.bufferViews![imageDef.bufferView];\n\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\tconst bufferData = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\tconst byteLength = bufferViewDef.byteLength;\n\t\t\t\tconst imageData = bufferData.slice(byteOffset, byteOffset + byteLength);\n\t\t\t\ttexture.setImage(imageData);\n\t\t\t} else if (imageDef.uri !== undefined) {\n\t\t\t\ttexture.setImage(jsonDoc.resources[imageDef.uri]);\n\t\t\t\tif (imageDef.uri.indexOf('__') !== 0) {\n\t\t\t\t\ttexture.setURI(imageDef.uri);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (imageDef.mimeType !== undefined) {\n\t\t\t\ttexture.setMimeType(imageDef.mimeType);\n\t\t\t} else if (imageDef.uri) {\n\t\t\t\tconst extension = FileUtils.extension(imageDef.uri);\n\t\t\t\ttexture.setMimeType(ImageUtils.extensionToMimeType(extension));\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t});\n\n\t\t/** Materials. */\n\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.MATERIAL))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.MATERIAL));\n\n\t\tconst materialDefs = json.materials || [];\n\t\tcontext.materials = materialDefs.map((materialDef) => {\n\t\t\tconst material = document.createMaterial(materialDef.name);\n\n\t\t\tif (materialDef.extras) material.setExtras(materialDef.extras);\n\n\t\t\t// Program state & blending.\n\n\t\t\tif (materialDef.alphaMode !== undefined) {\n\t\t\t\tmaterial.setAlphaMode(materialDef.alphaMode);\n\t\t\t}\n\n\t\t\tif (materialDef.alphaCutoff !== undefined) {\n\t\t\t\tmaterial.setAlphaCutoff(materialDef.alphaCutoff);\n\t\t\t}\n\n\t\t\tif (materialDef.doubleSided !== undefined) {\n\t\t\t\tmaterial.setDoubleSided(materialDef.doubleSided);\n\t\t\t}\n\n\t\t\t// Factors.\n\n\t\t\tconst pbrDef = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tif (pbrDef.baseColorFactor !== undefined) {\n\t\t\t\tmaterial.setBaseColorFactor(pbrDef.baseColorFactor as vec4);\n\t\t\t}\n\n\t\t\tif (materialDef.emissiveFactor !== undefined) {\n\t\t\t\tmaterial.setEmissiveFactor(materialDef.emissiveFactor as vec3);\n\t\t\t}\n\n\t\t\tif (pbrDef.metallicFactor !== undefined) {\n\t\t\t\tmaterial.setMetallicFactor(pbrDef.metallicFactor);\n\t\t\t}\n\n\t\t\tif (pbrDef.roughnessFactor !== undefined) {\n\t\t\t\tmaterial.setRoughnessFactor(pbrDef.roughnessFactor);\n\t\t\t}\n\n\t\t\t// Textures.\n\n\t\t\tif (pbrDef.baseColorTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = pbrDef.baseColorTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setBaseColorTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getBaseColorTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\tif (materialDef.emissiveTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.emissiveTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setEmissiveTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getEmissiveTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\tif (materialDef.normalTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.normalTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setNormalTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getNormalTextureInfo()!, textureInfoDef);\n\t\t\t\tif (materialDef.normalTexture.scale !== undefined) {\n\t\t\t\t\tmaterial.setNormalScale(materialDef.normalTexture.scale);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (materialDef.occlusionTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.occlusionTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setOcclusionTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getOcclusionTextureInfo()!, textureInfoDef);\n\t\t\t\tif (materialDef.occlusionTexture.strength !== undefined) {\n\t\t\t\t\tmaterial.setOcclusionStrength(materialDef.occlusionTexture.strength);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pbrDef.metallicRoughnessTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = pbrDef.metallicRoughnessTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setMetallicRoughnessTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getMetallicRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\treturn material;\n\t\t});\n\n\t\t/** Meshes. */\n\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.MESH))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.MESH));\n\n\t\tconst meshDefs = json.meshes || [];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.PRIMITIVE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.PRIMITIVE));\n\t\tcontext.meshes = meshDefs.map((meshDef) => {\n\t\t\tconst mesh = document.createMesh(meshDef.name);\n\n\t\t\tif (meshDef.extras) mesh.setExtras(meshDef.extras);\n\n\t\t\tif (meshDef.weights !== undefined) {\n\t\t\t\tmesh.setWeights(meshDef.weights);\n\t\t\t}\n\n\t\t\tconst primitiveDefs = meshDef.primitives || [];\n\t\t\tprimitiveDefs.forEach((primitiveDef) => {\n\t\t\t\tconst primitive = document.createPrimitive();\n\n\t\t\t\tif (primitiveDef.extras) primitive.setExtras(primitiveDef.extras);\n\n\t\t\t\tif (primitiveDef.material !== undefined) {\n\t\t\t\t\tprimitive.setMaterial(context.materials[primitiveDef.material]);\n\t\t\t\t}\n\n\t\t\t\tif (primitiveDef.mode !== undefined) {\n\t\t\t\t\tprimitive.setMode(primitiveDef.mode);\n\t\t\t\t}\n\n\t\t\t\tfor (const [semantic, index] of Object.entries(primitiveDef.attributes || {})) {\n\t\t\t\t\tprimitive.setAttribute(semantic, context.accessors[index]);\n\t\t\t\t}\n\n\t\t\t\tif (primitiveDef.indices !== undefined) {\n\t\t\t\t\tprimitive.setIndices(context.accessors[primitiveDef.indices]);\n\t\t\t\t}\n\n\t\t\t\tconst targetNames: string[] = (meshDef.extras && (meshDef.extras.targetNames as string[])) || [];\n\t\t\t\tconst targetDefs = primitiveDef.targets || [];\n\t\t\t\ttargetDefs.forEach((targetDef, targetIndex) => {\n\t\t\t\t\tconst targetName = targetNames[targetIndex] || targetIndex.toString();\n\t\t\t\t\tconst target = document.createPrimitiveTarget(targetName);\n\n\t\t\t\t\tfor (const [semantic, accessorIndex] of Object.entries(targetDef)) {\n\t\t\t\t\t\ttarget.setAttribute(semantic, context.accessors[accessorIndex]);\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitive.addTarget(target);\n\t\t\t\t});\n\n\t\t\t\tmesh.addPrimitive(primitive);\n\t\t\t});\n\n\t\t\treturn mesh;\n\t\t});\n\n\t\t/** Cameras. */\n\n\t\tconst cameraDefs = json.cameras || [];\n\t\tcontext.cameras = cameraDefs.map((cameraDef) => {\n\t\t\tconst camera = document.createCamera(cameraDef.name).setType(cameraDef.type);\n\n\t\t\tif (cameraDef.extras) camera.setExtras(cameraDef.extras);\n\n\t\t\tif (cameraDef.type === Camera.Type.PERSPECTIVE) {\n\t\t\t\tconst perspectiveDef = cameraDef.perspective!;\n\t\t\t\tcamera.setYFov(perspectiveDef.yfov);\n\t\t\t\tcamera.setZNear(perspectiveDef.znear);\n\t\t\t\tif (perspectiveDef.zfar !== undefined) {\n\t\t\t\t\tcamera.setZFar(perspectiveDef.zfar);\n\t\t\t\t}\n\t\t\t\tif (perspectiveDef.aspectRatio !== undefined) {\n\t\t\t\t\tcamera.setAspectRatio(perspectiveDef.aspectRatio);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst orthoDef = cameraDef.orthographic!;\n\t\t\t\tcamera.setZNear(orthoDef.znear).setZFar(orthoDef.zfar).setXMag(orthoDef.xmag).setYMag(orthoDef.ymag);\n\t\t\t}\n\t\t\treturn camera;\n\t\t});\n\n\t\t/** Nodes. */\n\n\t\tconst nodeDefs = json.nodes || [];\n\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.NODE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.NODE));\n\n\t\tcontext.nodes = nodeDefs.map((nodeDef) => {\n\t\t\tconst node = document.createNode(nodeDef.name);\n\n\t\t\tif (nodeDef.extras) node.setExtras(nodeDef.extras);\n\n\t\t\tif (nodeDef.translation !== undefined) {\n\t\t\t\tnode.setTranslation(nodeDef.translation as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.rotation !== undefined) {\n\t\t\t\tnode.setRotation(nodeDef.rotation as vec4);\n\t\t\t}\n\n\t\t\tif (nodeDef.scale !== undefined) {\n\t\t\t\tnode.setScale(nodeDef.scale as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.matrix !== undefined) {\n\t\t\t\tconst translation = [0, 0, 0] as vec3;\n\t\t\t\tconst rotation = [0, 0, 0, 1] as vec4;\n\t\t\t\tconst scale = [1, 1, 1] as vec3;\n\n\t\t\t\tMathUtils.decompose(nodeDef.matrix as mat4, translation, rotation, scale);\n\n\t\t\t\tnode.setTranslation(translation);\n\t\t\t\tnode.setRotation(rotation);\n\t\t\t\tnode.setScale(scale);\n\t\t\t}\n\n\t\t\tif (nodeDef.weights !== undefined) {\n\t\t\t\tnode.setWeights(nodeDef.weights);\n\t\t\t}\n\n\t\t\t// Attachments (mesh, camera, skin) defined later in reading process.\n\n\t\t\treturn node;\n\t\t});\n\n\t\t/** Skins. */\n\n\t\tconst skinDefs = json.skins || [];\n\t\tcontext.skins = skinDefs.map((skinDef) => {\n\t\t\tconst skin = document.createSkin(skinDef.name);\n\n\t\t\tif (skinDef.extras) skin.setExtras(skinDef.extras);\n\n\t\t\tif (skinDef.inverseBindMatrices !== undefined) {\n\t\t\t\tskin.setInverseBindMatrices(context.accessors[skinDef.inverseBindMatrices]);\n\t\t\t}\n\n\t\t\tif (skinDef.skeleton !== undefined) {\n\t\t\t\tskin.setSkeleton(context.nodes[skinDef.skeleton]);\n\t\t\t}\n\n\t\t\tfor (const nodeIndex of skinDef.joints) {\n\t\t\t\tskin.addJoint(context.nodes[nodeIndex]);\n\t\t\t}\n\n\t\t\treturn skin;\n\t\t});\n\n\t\t/** Node attachments. */\n\n\t\tnodeDefs.map((nodeDef, nodeIndex) => {\n\t\t\tconst node = context.nodes[nodeIndex];\n\n\t\t\tconst children = nodeDef.children || [];\n\t\t\tchildren.forEach((childIndex) => node.addChild(context.nodes[childIndex]));\n\n\t\t\tif (nodeDef.mesh !== undefined) node.setMesh(context.meshes[nodeDef.mesh]);\n\n\t\t\tif (nodeDef.camera !== undefined) node.setCamera(context.cameras[nodeDef.camera]);\n\n\t\t\tif (nodeDef.skin !== undefined) node.setSkin(context.skins[nodeDef.skin]);\n\t\t});\n\n\t\t/** Animations. */\n\n\t\tconst animationDefs = json.animations || [];\n\t\tcontext.animations = animationDefs.map((animationDef) => {\n\t\t\tconst animation = document.createAnimation(animationDef.name);\n\n\t\t\tif (animationDef.extras) animation.setExtras(animationDef.extras);\n\n\t\t\tconst samplerDefs = animationDef.samplers || [];\n\t\t\tconst samplers = samplerDefs.map((samplerDef) => {\n\t\t\t\tconst sampler = document\n\t\t\t\t\t.createAnimationSampler()\n\t\t\t\t\t.setInput(context.accessors[samplerDef.input])\n\t\t\t\t\t.setOutput(context.accessors[samplerDef.output])\n\t\t\t\t\t.setInterpolation(samplerDef.interpolation || AnimationSampler.Interpolation.LINEAR);\n\n\t\t\t\tif (samplerDef.extras) sampler.setExtras(samplerDef.extras);\n\n\t\t\t\tanimation.addSampler(sampler);\n\t\t\t\treturn sampler;\n\t\t\t});\n\n\t\t\tconst channels = animationDef.channels || [];\n\t\t\tchannels.forEach((channelDef) => {\n\t\t\t\tconst channel = document\n\t\t\t\t\t.createAnimationChannel()\n\t\t\t\t\t.setSampler(samplers[channelDef.sampler])\n\t\t\t\t\t.setTargetPath(channelDef.target.path);\n\n\t\t\t\tif (channelDef.target.node !== undefined) channel.setTargetNode(context.nodes[channelDef.target.node]);\n\t\t\t\tif (channelDef.extras) channel.setExtras(channelDef.extras);\n\n\t\t\t\tanimation.addChannel(channel);\n\t\t\t});\n\n\t\t\treturn animation;\n\t\t});\n\n\t\t/** Scenes. */\n\n\t\tconst sceneDefs = json.scenes || [];\n\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.SCENE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.SCENE));\n\n\t\tcontext.scenes = sceneDefs.map((sceneDef) => {\n\t\t\tconst scene = document.createScene(sceneDef.name);\n\n\t\t\tif (sceneDef.extras) scene.setExtras(sceneDef.extras);\n\n\t\t\tconst children = sceneDef.nodes || [];\n\n\t\t\tchildren.map((nodeIndex) => context.nodes[nodeIndex]).forEach((node) => scene.addChild(node));\n\n\t\t\treturn scene;\n\t\t});\n\n\t\tif (json.scene !== undefined) {\n\t\t\tdocument.getRoot().setDefaultScene(context.scenes[json.scene]);\n\t\t}\n\n\t\t/** Extensions (2/2). */\n\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.forEach((extension) => extension.read(context));\n\n\t\t/** Post-processing. */\n\n\t\t// Consider an accessor to be 'sparse' if it (A) includes sparse value overrides,\n\t\t// or (B) does not define .bufferView _and_ no extension provides that data. Case\n\t\t// (B) represents a zero-filled accessor.\n\t\taccessorDefs.forEach((accessorDef, index) => {\n\t\t\tconst accessor = context.accessors[index];\n\t\t\tconst hasSparseValues = !!accessorDef.sparse;\n\t\t\tconst isZeroFilled = !accessorDef.bufferView && !accessor.getArray();\n\t\t\tif (hasSparseValues || isZeroFilled) {\n\t\t\t\taccessor.setSparse(true).setArray(getSparseArray(accessorDef, context));\n\t\t\t}\n\t\t});\n\n\t\treturn document;\n\t}\n\n\tprivate static validate(jsonDoc: JSONDocument, options: Required<ReaderOptions>): void {\n\t\tconst json = jsonDoc.json;\n\n\t\tif (json.asset.version !== '2.0') {\n\t\t\tthrow new Error(`Unsupported glTF version, \"${json.asset.version}\".`);\n\t\t}\n\n\t\tif (json.extensionsRequired) {\n\t\t\tfor (const extensionName of json.extensionsRequired) {\n\t\t\t\tif (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {\n\t\t\t\t\tthrow new Error(`Missing required extension, \"${extensionName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (json.extensionsUsed) {\n\t\t\tfor (const extensionName of json.extensionsUsed) {\n\t\t\t\tif (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {\n\t\t\t\t\toptions.logger.warn(`Missing optional extension, \"${extensionName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Returns the contents of an interleaved accessor, as a typed array.\n * @internal\n */\nfunction getInterleavedArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst jsonDoc = context.jsonDoc;\n\tconst bufferView = context.bufferViews[accessorDef.bufferView!];\n\tconst bufferViewDef = jsonDoc.json.bufferViews![accessorDef.bufferView!];\n\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\tconst componentSize = TypedArray.BYTES_PER_ELEMENT;\n\tconst accessorByteOffset = accessorDef.byteOffset || 0;\n\n\tconst array = new TypedArray(accessorDef.count * elementSize);\n\tconst view = new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n\tconst byteStride = bufferViewDef.byteStride!;\n\n\tfor (let i = 0; i < accessorDef.count; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tconst byteOffset = accessorByteOffset + i * byteStride + j * componentSize;\n\t\t\tlet value: number;\n\t\t\tswitch (accessorDef.componentType) {\n\t\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\t\tvalue = view.getFloat32(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\t\tvalue = view.getUint32(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\t\tvalue = view.getUint16(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\t\tvalue = view.getUint8(byteOffset);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\t\tvalue = view.getInt16(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\t\tvalue = view.getInt8(byteOffset);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected componentType \"${accessorDef.componentType}\".`);\n\t\t\t}\n\t\t\tarray[i * elementSize + j] = value;\n\t\t}\n\t}\n\n\treturn array;\n}\n\n/**\n * Returns the contents of an accessor, as a typed array.\n * @internal\n */\nfunction getAccessorArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst jsonDoc = context.jsonDoc;\n\tconst bufferView = context.bufferViews[accessorDef.bufferView!];\n\tconst bufferViewDef = jsonDoc.json.bufferViews![accessorDef.bufferView!];\n\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\tconst componentSize = TypedArray.BYTES_PER_ELEMENT;\n\tconst elementStride = elementSize * componentSize;\n\n\t// Interleaved buffer view.\n\tif (bufferViewDef.byteStride !== undefined && bufferViewDef.byteStride !== elementStride) {\n\t\treturn getInterleavedArray(accessorDef, context);\n\t}\n\n\tconst byteOffset = bufferView.byteOffset + (accessorDef.byteOffset || 0);\n\tconst byteLength = accessorDef.count * elementSize * componentSize;\n\n\t// Might optimize this to avoid deep copy later, but it's useful for now and not a known\n\t// bottleneck. See https://github.com/donmccurdy/glTF-Transform/issues/256.\n\treturn new TypedArray(bufferView.buffer.slice(byteOffset, byteOffset + byteLength));\n}\n\n/**\n * Returns the contents of a sparse accessor, as a typed array.\n * @internal\n */\nfunction getSparseArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\n\tlet array: TypedArray;\n\tif (accessorDef.bufferView !== undefined) {\n\t\tarray = getAccessorArray(accessorDef, context);\n\t} else {\n\t\tarray = new TypedArray(accessorDef.count * elementSize);\n\t}\n\n\tconst sparseDef = accessorDef.sparse;\n\tif (!sparseDef) return array; // Zero-filled accessor.\n\n\tconst count = sparseDef.count;\n\tconst indicesDef = { ...accessorDef, ...sparseDef.indices, count, type: 'SCALAR' };\n\tconst valuesDef = { ...accessorDef, ...sparseDef.values, count };\n\tconst indices = getAccessorArray(indicesDef as GLTF.IAccessor, context);\n\tconst values = getAccessorArray(valuesDef, context);\n\n\t// Override indices given in the sparse data.\n\tfor (let i = 0; i < indicesDef.count; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tarray[indices[i] * elementSize + j] = values[i * elementSize + j];\n\t\t}\n\t}\n\n\treturn array;\n}\n", "import { BufferViewUsage, Format, PropertyType } from '../constants.js';\nimport type { Document } from '../document.js';\nimport type { JSONDocument } from '../json-document.js';\nimport type {\n\tAccessor,\n\tAnimation,\n\tBuffer,\n\tCamera,\n\tMaterial,\n\tMesh,\n\tNode,\n\tProperty,\n\tScene,\n\tSkin,\n\tTexture,\n\tTextureInfo,\n} from '../properties/index.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { type ILogger, ImageUtils } from '../utils/index.js';\nimport type { WriterOptions } from './writer.js';\n\ntype PropertyDef = GLTF.IScene | GLTF.INode | GLTF.IMaterial | GLTF.ISkin | GLTF.ITexture;\n\nenum BufferViewTarget {\n\tARRAY_BUFFER = 34962,\n\tELEMENT_ARRAY_BUFFER = 34963,\n}\n\n/**\n * Model class providing writing state to a {@link GLTFWriter} and its {@link Extension}\n * implementations.\n *\n * @hidden\n */\nexport class WriterContext {\n\t/** Explicit buffer view targets defined by glTF specification. */\n\tpublic static readonly BufferViewTarget: typeof BufferViewTarget = BufferViewTarget;\n\t/**\n\t * Implicit buffer view usage, not required by glTF specification, but nonetheless useful for\n\t * proper grouping of accessors into buffer views. Additional usages are defined by extensions,\n\t * like `EXT_mesh_gpu_instancing`.\n\t */\n\tpublic static readonly BufferViewUsage: typeof BufferViewUsage = BufferViewUsage;\n\t/** Maps usage type to buffer view target. Usages not mapped have undefined targets. */\n\tpublic static readonly USAGE_TO_TARGET: { [key: string]: BufferViewTarget | undefined } = {\n\t\t[BufferViewUsage.ARRAY_BUFFER]: BufferViewTarget.ARRAY_BUFFER,\n\t\t[BufferViewUsage.ELEMENT_ARRAY_BUFFER]: BufferViewTarget.ELEMENT_ARRAY_BUFFER,\n\t};\n\n\tpublic readonly accessorIndexMap: Map<Accessor, number> = new Map();\n\tpublic readonly animationIndexMap: Map<Animation, number> = new Map();\n\tpublic readonly bufferIndexMap: Map<Buffer, number> = new Map();\n\tpublic readonly cameraIndexMap: Map<Camera, number> = new Map();\n\tpublic readonly skinIndexMap: Map<Skin, number> = new Map();\n\tpublic readonly materialIndexMap: Map<Material, number> = new Map();\n\tpublic readonly meshIndexMap: Map<Mesh, number> = new Map();\n\tpublic readonly nodeIndexMap: Map<Node, number> = new Map();\n\tpublic readonly imageIndexMap: Map<Texture, number> = new Map();\n\tpublic readonly textureDefIndexMap: Map<string, number> = new Map(); // textureDef JSON -> index\n\tpublic readonly textureInfoDefMap: Map<TextureInfo, GLTF.ITextureInfo> = new Map();\n\tpublic readonly samplerDefIndexMap: Map<string, number> = new Map(); // samplerDef JSON -> index\n\tpublic readonly sceneIndexMap: Map<Scene, number> = new Map();\n\n\tpublic readonly imageBufferViews: Uint8Array[] = [];\n\tpublic readonly otherBufferViews: Map<Buffer, Uint8Array[]> = new Map();\n\tpublic readonly otherBufferViewsIndexMap: Map<Uint8Array, number> = new Map();\n\tpublic readonly extensionData: { [key: string]: unknown } = {};\n\n\tpublic bufferURIGenerator: UniqueURIGenerator<Buffer>;\n\tpublic imageURIGenerator: UniqueURIGenerator<Texture>;\n\tpublic logger: ILogger;\n\n\tprivate readonly _accessorUsageMap: Map<Accessor, BufferViewUsage | string> = new Map();\n\tpublic readonly accessorUsageGroupedByParent: Set<string> = new Set(['ARRAY_BUFFER']);\n\tpublic readonly accessorParents: Map<Accessor, Property> = new Map();\n\n\tconstructor(\n\t\tprivate readonly _doc: Document,\n\t\tpublic readonly jsonDoc: JSONDocument,\n\t\tpublic readonly options: Required<WriterOptions>,\n\t) {\n\t\tconst root = _doc.getRoot();\n\t\tconst numBuffers = root.listBuffers().length;\n\t\tconst numImages = root.listTextures().length;\n\t\tthis.bufferURIGenerator = new UniqueURIGenerator(numBuffers > 1, () => options.basename || 'buffer');\n\t\tthis.imageURIGenerator = new UniqueURIGenerator(\n\t\t\tnumImages > 1,\n\t\t\t(texture) => getSlot(_doc, texture) || options.basename || 'texture',\n\t\t);\n\t\tthis.logger = _doc.getLogger();\n\t}\n\n\t/**\n\t * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If\n\t * possible, Texture and Sampler definitions are shared.\n\t */\n\tpublic createTextureInfoDef(texture: Texture, textureInfo: TextureInfo): GLTF.ITextureInfo {\n\t\tconst samplerDef = {\n\t\t\tmagFilter: textureInfo.getMagFilter() || undefined,\n\t\t\tminFilter: textureInfo.getMinFilter() || undefined,\n\t\t\twrapS: textureInfo.getWrapS(),\n\t\t\twrapT: textureInfo.getWrapT(),\n\t\t} as GLTF.ISampler;\n\n\t\tconst samplerKey = JSON.stringify(samplerDef);\n\t\tif (!this.samplerDefIndexMap.has(samplerKey)) {\n\t\t\tthis.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers!.length);\n\t\t\tthis.jsonDoc.json.samplers!.push(samplerDef);\n\t\t}\n\n\t\tconst textureDef = {\n\t\t\tsource: this.imageIndexMap.get(texture),\n\t\t\tsampler: this.samplerDefIndexMap.get(samplerKey),\n\t\t} as GLTF.ITexture;\n\n\t\tconst textureKey = JSON.stringify(textureDef);\n\t\tif (!this.textureDefIndexMap.has(textureKey)) {\n\t\t\tthis.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures!.length);\n\t\t\tthis.jsonDoc.json.textures!.push(textureDef);\n\t\t}\n\n\t\tconst textureInfoDef = {\n\t\t\tindex: this.textureDefIndexMap.get(textureKey),\n\t\t} as GLTF.ITextureInfo;\n\n\t\tif (textureInfo.getTexCoord() !== 0) {\n\t\t\ttextureInfoDef.texCoord = textureInfo.getTexCoord();\n\t\t}\n\t\tif (Object.keys(textureInfo.getExtras()).length > 0) {\n\t\t\ttextureInfoDef.extras = textureInfo.getExtras();\n\t\t}\n\n\t\tthis.textureInfoDefMap.set(textureInfo, textureInfoDef);\n\n\t\treturn textureInfoDef;\n\t}\n\n\tpublic createPropertyDef(property: Property): PropertyDef {\n\t\tconst def = {} as PropertyDef;\n\t\tif (property.getName()) {\n\t\t\tdef.name = property.getName();\n\t\t}\n\t\tif (Object.keys(property.getExtras()).length > 0) {\n\t\t\tdef.extras = property.getExtras();\n\t\t}\n\t\treturn def;\n\t}\n\n\tpublic createAccessorDef(accessor: Accessor): GLTF.IAccessor {\n\t\tconst accessorDef = this.createPropertyDef(accessor) as GLTF.IAccessor;\n\t\taccessorDef.type = accessor.getType();\n\t\taccessorDef.componentType = accessor.getComponentType();\n\t\taccessorDef.count = accessor.getCount();\n\n\t\tconst needsBounds = this._doc\n\t\t\t.getGraph()\n\t\t\t.listParentEdges(accessor)\n\t\t\t.some(\n\t\t\t\t(edge) =>\n\t\t\t\t\t(edge.getName() === 'attributes' && edge.getAttributes().key === 'POSITION') ||\n\t\t\t\t\tedge.getName() === 'input',\n\t\t\t);\n\t\tif (needsBounds) {\n\t\t\taccessorDef.max = accessor.getMax([]).map(Math.fround);\n\t\t\taccessorDef.min = accessor.getMin([]).map(Math.fround);\n\t\t}\n\n\t\tif (accessor.getNormalized()) {\n\t\t\taccessorDef.normalized = accessor.getNormalized();\n\t\t}\n\n\t\treturn accessorDef;\n\t}\n\n\tpublic createImageData(imageDef: GLTF.IImage, data: Uint8Array, texture: Texture): void {\n\t\tif (this.options.format === Format.GLB) {\n\t\t\tthis.imageBufferViews.push(data);\n\t\t\timageDef.bufferView = this.jsonDoc.json.bufferViews!.length;\n\t\t\tthis.jsonDoc.json.bufferViews!.push({\n\t\t\t\tbuffer: 0,\n\t\t\t\tbyteOffset: -1, // determined while iterating buffers, in Writer.ts.\n\t\t\t\tbyteLength: data.byteLength,\n\t\t\t});\n\t\t} else {\n\t\t\tconst extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());\n\t\t\timageDef.uri = this.imageURIGenerator.createURI(texture, extension);\n\t\t\tthis.assignResourceURI(imageDef.uri, data, false);\n\t\t}\n\t}\n\n\tpublic assignResourceURI(uri: string, data: Uint8Array, throwOnConflict: boolean): void {\n\t\tconst resources = this.jsonDoc.resources;\n\n\t\t// https://github.com/KhronosGroup/glTF/issues/2446\n\t\tif (!(uri in resources)) {\n\t\t\tresources[uri] = data;\n\t\t\treturn;\n\t\t}\n\n\t\tif (data === resources[uri]) {\n\t\t\tthis.logger.warn(`Duplicate resource URI, \"${uri}\".`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst conflictMessage = `Resource URI \"${uri}\" already assigned to different data.`;\n\n\t\tif (!throwOnConflict) {\n\t\t\tthis.logger.warn(conflictMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error(conflictMessage);\n\t}\n\n\t/**\n\t * Returns implicit usage type of the given accessor, related to grouping accessors into\n\t * buffer views. Usage is a superset of buffer view target, including ARRAY_BUFFER and\n\t * ELEMENT_ARRAY_BUFFER, but also usages that do not match GPU buffer view targets such as\n\t * IBMs. Additional usages are defined by extensions, like `EXT_mesh_gpu_instancing`.\n\t */\n\tpublic getAccessorUsage(accessor: Accessor): BufferViewUsage | string {\n\t\tconst cachedUsage = this._accessorUsageMap.get(accessor);\n\t\tif (cachedUsage) return cachedUsage;\n\n\t\tif (accessor.getSparse()) return BufferViewUsage.SPARSE;\n\n\t\tfor (const edge of this._doc.getGraph().listParentEdges(accessor)) {\n\t\t\tconst { usage } = edge.getAttributes() as { usage: BufferViewUsage | undefined };\n\n\t\t\tif (usage) return usage;\n\n\t\t\tif (edge.getParent().propertyType !== PropertyType.ROOT) {\n\t\t\t\tthis.logger.warn(`Missing attribute \".usage\" on edge, \"${edge.getName()}\".`);\n\t\t\t}\n\t\t}\n\n\t\t// Group accessors with no specified usage into a miscellaneous buffer view.\n\t\treturn BufferViewUsage.OTHER;\n\t}\n\n\t/**\n\t * Sets usage for the given accessor. Some accessor types must be grouped into\n\t * buffer views with like accessors. This includes the specified buffer view \"targets\", but\n\t * also implicit usage like IBMs or instanced mesh attributes. If unspecified, an accessor\n\t * will be grouped with other accessors of unspecified usage.\n\t */\n\tpublic addAccessorToUsageGroup(accessor: Accessor, usage: BufferViewUsage | string): this {\n\t\tconst prevUsage = this._accessorUsageMap.get(accessor);\n\t\tif (prevUsage && prevUsage !== usage) {\n\t\t\tthrow new Error(`Accessor with usage \"${prevUsage}\" cannot be reused as \"${usage}\".`);\n\t\t}\n\t\tthis._accessorUsageMap.set(accessor, usage);\n\t\treturn this;\n\t}\n}\n\nexport class UniqueURIGenerator<T extends Texture | Buffer> {\n\tprivate counter = {} as Record<string, number>;\n\n\tconstructor(\n\t\tprivate readonly multiple: boolean,\n\t\tprivate readonly basename: (t: T) => string,\n\t) {}\n\n\tpublic createURI(object: T, extension: string): string {\n\t\tif (object.getURI()) {\n\t\t\treturn object.getURI();\n\t\t} else if (!this.multiple) {\n\t\t\treturn `${this.basename(object)}.${extension}`;\n\t\t} else {\n\t\t\tconst basename = this.basename(object);\n\t\t\tthis.counter[basename] = this.counter[basename] || 1;\n\t\t\treturn `${basename}_${this.counter[basename]++}.${extension}`;\n\t\t}\n\t}\n}\n\n/** Returns the first slot (by name) to which the texture is assigned. */\nfunction getSlot(document: Document, texture: Texture): string {\n\tconst edge = document\n\t\t.getGraph()\n\t\t.listParentEdges(texture)\n\t\t.find((edge) => edge.getParent() !== document.getRoot());\n\treturn edge ? edge.getName().replace(/texture$/i, '') : '';\n}\n", "import {\n\tComponentTypeToTypedArray,\n\tFormat,\n\tGLB_BUFFER,\n\tPropertyType,\n\ttype TypedArray,\n\tVERSION,\n\tVertexLayout,\n} from '../constants.js';\nimport type { Document } from '../document.js';\nimport type { Extension } from '../extension.js';\nimport type { JSONDocument } from '../json-document.js';\nimport { Accessor, type AnimationSampler, Camera, Material } from '../properties/index.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { BufferUtils, Logger, MathUtils } from '../utils/index.js';\nimport { WriterContext } from './writer-context.js';\n\nconst { BufferViewUsage } = WriterContext;\nconst { UNSIGNED_INT, UNSIGNED_SHORT, UNSIGNED_BYTE } = Accessor.ComponentType;\n\nexport interface WriterOptions {\n\tformat: Format;\n\tlogger?: Logger;\n\tbasename?: string;\n\tvertexLayout?: VertexLayout;\n\tdependencies?: { [key: string]: unknown };\n\textensions?: (typeof Extension)[];\n}\n\nconst SUPPORTED_PREWRITE_TYPES = new Set<PropertyType>([\n\tPropertyType.ACCESSOR,\n\tPropertyType.BUFFER,\n\tPropertyType.MATERIAL,\n\tPropertyType.MESH,\n]);\n\n/**\n * @internal\n * @hidden\n */\nexport class GLTFWriter {\n\tpublic static write(doc: Document, options: Required<WriterOptions>): JSONDocument {\n\t\tconst graph = doc.getGraph();\n\t\tconst root = doc.getRoot();\n\t\tconst json = {\n\t\t\tasset: { generator: `glTF-Transform ${VERSION}`, ...root.getAsset() },\n\t\t\textras: { ...root.getExtras() },\n\t\t} as GLTF.IGLTF;\n\t\tconst jsonDoc = { json, resources: {} } as JSONDocument;\n\n\t\tconst context = new WriterContext(doc, jsonDoc, options);\n\t\tconst logger = options.logger || Logger.DEFAULT_INSTANCE;\n\n\t\t/* Extensions (1/2). */\n\n\t\t// Extensions present on the Document are not written unless they are also registered with\n\t\t// the I/O class. This ensures that setup in `extension.register()` is completed, and\n\t\t// allows a Document to be written with specific extensions disabled.\n\t\tconst extensionsRegistered = new Set(options.extensions.map((ext) => ext.EXTENSION_NAME));\n\t\tconst extensionsUsed = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((ext) => extensionsRegistered.has(ext.extensionName))\n\t\t\t.sort((a, b) => (a.extensionName > b.extensionName ? 1 : -1));\n\t\tconst extensionsRequired = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsRequired()\n\t\t\t.filter((ext) => extensionsRegistered.has(ext.extensionName))\n\t\t\t.sort((a, b) => (a.extensionName > b.extensionName ? 1 : -1));\n\t\tif (extensionsUsed.length < doc.getRoot().listExtensionsUsed().length) {\n\t\t\tlogger.warn('Some extensions were not registered for I/O, and will not be written.');\n\t\t}\n\n\t\tfor (const extension of extensionsUsed) {\n\t\t\t// Warn on unsupported prewrite hooks.\n\t\t\tconst unsupportedHooks = extension.prewriteTypes.filter((type) => !SUPPORTED_PREWRITE_TYPES.has(type));\n\t\t\tif (unsupportedHooks.length) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Prewrite hooks for some types (${unsupportedHooks.join()}), requested by extension ` +\n\t\t\t\t\t\t`${extension.extensionName}, are unsupported. Please file an issue or a PR.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Install dependencies.\n\t\t\tfor (const key of extension.writeDependencies) {\n\t\t\t\textension.install(key, options.dependencies[key]);\n\t\t\t}\n\t\t}\n\n\t\t/* Utilities. */\n\n\t\tinterface BufferViewResult {\n\t\t\tbyteLength: number;\n\t\t\tbuffers: Uint8Array[];\n\t\t}\n\n\t\t/**\n\t\t * Pack a group of accessors into a sequential buffer view. Appends accessor and buffer view\n\t\t * definitions to the root JSON lists.\n\t\t *\n\t\t * @param accessors Accessors to be included.\n\t\t * @param bufferIndex Buffer to write to.\n\t\t * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n\t\t * @param bufferViewTarget (Optional) target use of the buffer view.\n\t\t */\n\t\tfunction concatAccessors(\n\t\t\taccessors: Accessor[],\n\t\t\tbufferIndex: number,\n\t\t\tbufferByteOffset: number,\n\t\t\tbufferViewTarget?: number,\n\t\t): BufferViewResult {\n\t\t\tconst buffers: Uint8Array[] = [];\n\t\t\tlet byteLength = 0;\n\n\t\t\t// Create accessor definitions, determining size of final buffer view.\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\taccessorDef.bufferView = json.bufferViews!.length;\n\n\t\t\t\tconst accessorArray = accessor.getArray()!;\n\t\t\t\tconst data = BufferUtils.pad(BufferUtils.toView(accessorArray));\n\t\t\t\taccessorDef.byteOffset = byteLength;\n\t\t\t\tbyteLength += data.byteLength;\n\t\t\t\tbuffers.push(data);\n\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\t\tjson.accessors!.push(accessorDef);\n\t\t\t}\n\n\t\t\t// Create buffer view definition.\n\t\t\tconst bufferViewData = BufferUtils.concat(buffers);\n\t\t\tconst bufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset,\n\t\t\t\tbyteLength: bufferViewData.byteLength,\n\t\t\t};\n\t\t\tif (bufferViewTarget) bufferViewDef.target = bufferViewTarget;\n\t\t\tjson.bufferViews!.push(bufferViewDef);\n\n\t\t\treturn { buffers, byteLength };\n\t\t}\n\n\t\t/**\n\t\t * Pack a group of accessors into an interleaved buffer view. Appends accessor and buffer\n\t\t * view definitions to the root JSON lists. Buffer view target is implicitly attribute data.\n\t\t *\n\t\t * References:\n\t\t * - [Apple • Best Practices for Working with Vertex Data](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html)\n\t\t * - [Khronos • Vertex Specification Best Practices](https://www.khronos.org/opengl/wiki/Vertex_Specification_Best_Practices)\n\t\t *\n\t\t * @param accessors Accessors to be included.\n\t\t * @param bufferIndex Buffer to write to.\n\t\t * @param bufferByteOffset Offset into the buffer, accounting for other buffer views.\n\t\t */\n\t\tfunction interleaveAccessors(\n\t\t\taccessors: Accessor[],\n\t\t\tbufferIndex: number,\n\t\t\tbufferByteOffset: number,\n\t\t): BufferViewResult {\n\t\t\tconst vertexCount = accessors[0].getCount();\n\t\t\tlet byteStride = 0;\n\n\t\t\t// Create accessor definitions, determining size and stride of final buffer view.\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\taccessorDef.bufferView = json.bufferViews!.length;\n\t\t\t\taccessorDef.byteOffset = byteStride;\n\n\t\t\t\tconst elementSize = accessor.getElementSize();\n\t\t\t\tconst componentSize = accessor.getComponentSize();\n\t\t\t\tbyteStride += BufferUtils.padNumber(elementSize * componentSize);\n\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\t\tjson.accessors!.push(accessorDef);\n\t\t\t}\n\n\t\t\t// Allocate interleaved buffer view.\n\t\t\tconst byteLength = vertexCount * byteStride;\n\t\t\tconst buffer = new ArrayBuffer(byteLength);\n\t\t\tconst view = new DataView(buffer);\n\n\t\t\t// Write interleaved accessor data to the buffer view.\n\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\tlet vertexByteOffset = 0;\n\t\t\t\tfor (const accessor of accessors) {\n\t\t\t\t\tconst elementSize = accessor.getElementSize();\n\t\t\t\t\tconst componentSize = accessor.getComponentSize();\n\t\t\t\t\tconst componentType = accessor.getComponentType();\n\t\t\t\t\tconst array = accessor.getArray()!;\n\t\t\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\t\t\tconst viewByteOffset = i * byteStride + vertexByteOffset + j * componentSize;\n\t\t\t\t\t\tconst value = array[i * elementSize + j];\n\t\t\t\t\t\tswitch (componentType) {\n\t\t\t\t\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\t\t\t\t\tview.setFloat32(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\t\t\t\t\tview.setInt8(viewByteOffset, value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\t\t\t\t\tview.setInt16(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\t\t\t\t\tview.setUint8(viewByteOffset, value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\t\t\t\t\tview.setUint16(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\t\t\t\t\tview.setUint32(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow new Error('Unexpected component type: ' + componentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvertexByteOffset += BufferUtils.padNumber(elementSize * componentSize);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create buffer view definition.\n\t\t\tconst bufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset,\n\t\t\t\tbyteLength: byteLength,\n\t\t\t\tbyteStride: byteStride,\n\t\t\t\ttarget: WriterContext.BufferViewTarget.ARRAY_BUFFER,\n\t\t\t};\n\t\t\tjson.bufferViews!.push(bufferViewDef);\n\n\t\t\treturn { byteLength, buffers: [new Uint8Array(buffer)] };\n\t\t}\n\n\t\t/**\n\t\t * Pack a group of sparse accessors. Appends accessor and buffer view\n\t\t * definitions to the root JSON lists.\n\t\t *\n\t\t * @param accessors Accessors to be included.\n\t\t * @param bufferIndex Buffer to write to.\n\t\t * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n\t\t */\n\t\tfunction concatSparseAccessors(\n\t\t\taccessors: Accessor[],\n\t\t\tbufferIndex: number,\n\t\t\tbufferByteOffset: number,\n\t\t): BufferViewResult {\n\t\t\tconst buffers: Uint8Array[] = [];\n\t\t\tlet byteLength = 0;\n\n\t\t\tinterface SparseData {\n\t\t\t\taccessorDef: GLTF.IAccessor;\n\t\t\t\tcount: number;\n\t\t\t\tindices?: number[];\n\t\t\t\tvalues?: TypedArray;\n\t\t\t\tindicesByteOffset?: number;\n\t\t\t\tvaluesByteOffset?: number;\n\t\t\t}\n\t\t\tconst sparseData = new Map<Accessor, SparseData>();\n\t\t\tlet maxIndex = -Infinity;\n\t\t\tlet needSparseWarning = false;\n\n\t\t\t// (1) Write accessor definitions, gathering indices and values.\n\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\tjson.accessors!.push(accessorDef);\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length - 1);\n\n\t\t\t\tconst indices = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tconst el = [] as number[];\n\t\t\t\tconst base = new Array(accessor.getElementSize()).fill(0);\n\n\t\t\t\tfor (let i = 0, il = accessor.getCount(); i < il; i++) {\n\t\t\t\t\taccessor.getElement(i, el);\n\t\t\t\t\tif (MathUtils.eq(el, base, 0)) continue;\n\n\t\t\t\t\tmaxIndex = Math.max(i, maxIndex);\n\t\t\t\t\tindices.push(i);\n\t\t\t\t\tfor (let j = 0; j < el.length; j++) values.push(el[j]);\n\t\t\t\t}\n\n\t\t\t\tconst count = indices.length;\n\t\t\t\tconst data: SparseData = { accessorDef, count };\n\t\t\t\tsparseData.set(accessor, data);\n\n\t\t\t\tif (count === 0) continue;\n\n\t\t\t\tif (count > accessor.getCount() / 2) {\n\t\t\t\t\tneedSparseWarning = true;\n\t\t\t\t}\n\n\t\t\t\tconst ValueArray = ComponentTypeToTypedArray[accessor.getComponentType()];\n\t\t\t\tdata.indices = indices;\n\t\t\t\tdata.values = new ValueArray(values);\n\t\t\t}\n\n\t\t\t// (2) Early exit if all sparse accessors are just zero-filled arrays.\n\n\t\t\tif (!Number.isFinite(maxIndex)) {\n\t\t\t\treturn { buffers, byteLength };\n\t\t\t}\n\n\t\t\tif (needSparseWarning) {\n\t\t\t\tlogger.warn(`Some sparse accessors have >50% non-zero elements, which may increase file size.`);\n\t\t\t}\n\n\t\t\t// (3) Write index buffer view.\n\n\t\t\tconst IndexArray = maxIndex < 255 ? Uint8Array : maxIndex < 65535 ? Uint16Array : Uint32Array;\n\t\t\tconst IndexComponentType =\n\t\t\t\tmaxIndex < 255 ? UNSIGNED_BYTE : maxIndex < 65535 ? UNSIGNED_SHORT : UNSIGNED_INT;\n\n\t\t\tconst indicesBufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset + byteLength,\n\t\t\t\tbyteLength: 0,\n\t\t\t};\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst data = sparseData.get(accessor)!;\n\t\t\t\tif (data.count === 0) continue;\n\n\t\t\t\tdata.indicesByteOffset = indicesBufferViewDef.byteLength;\n\n\t\t\t\tconst buffer = BufferUtils.pad(BufferUtils.toView(new IndexArray(data.indices!)));\n\t\t\t\tbuffers.push(buffer);\n\t\t\t\tbyteLength += buffer.byteLength;\n\t\t\t\tindicesBufferViewDef.byteLength += buffer.byteLength;\n\t\t\t}\n\t\t\tjson.bufferViews!.push(indicesBufferViewDef);\n\t\t\tconst indicesBufferViewIndex = json.bufferViews!.length - 1;\n\n\t\t\t// (4) Write value buffer view.\n\n\t\t\tconst valuesBufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset + byteLength,\n\t\t\t\tbyteLength: 0,\n\t\t\t};\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst data = sparseData.get(accessor)!;\n\t\t\t\tif (data.count === 0) continue;\n\n\t\t\t\tdata.valuesByteOffset = valuesBufferViewDef.byteLength;\n\n\t\t\t\tconst buffer = BufferUtils.pad(BufferUtils.toView(data.values!));\n\t\t\t\tbuffers.push(buffer);\n\t\t\t\tbyteLength += buffer.byteLength;\n\t\t\t\tvaluesBufferViewDef.byteLength += buffer.byteLength;\n\t\t\t}\n\t\t\tjson.bufferViews!.push(valuesBufferViewDef);\n\t\t\tconst valuesBufferViewIndex = json.bufferViews!.length - 1;\n\n\t\t\t// (5) Write accessor sparse entries.\n\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst data = sparseData.get(accessor) as Required<SparseData>;\n\t\t\t\tif (data.count === 0) continue;\n\n\t\t\t\tdata.accessorDef.sparse = {\n\t\t\t\t\tcount: data.count,\n\t\t\t\t\tindices: {\n\t\t\t\t\t\tbufferView: indicesBufferViewIndex,\n\t\t\t\t\t\tbyteOffset: data.indicesByteOffset,\n\t\t\t\t\t\tcomponentType: IndexComponentType,\n\t\t\t\t\t},\n\t\t\t\t\tvalues: {\n\t\t\t\t\t\tbufferView: valuesBufferViewIndex,\n\t\t\t\t\t\tbyteOffset: data.valuesByteOffset,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn { buffers, byteLength };\n\t\t}\n\n\t\tjson.accessors = [];\n\t\tjson.bufferViews = [];\n\n\t\t/* Textures. */\n\n\t\t// glTF Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n\t\t// with image files. The glTF file may contain more one texture per image, where images\n\t\t// are reused with different sampler properties.\n\t\tjson.samplers = [];\n\t\tjson.textures = [];\n\t\tjson.images = root.listTextures().map((texture, textureIndex) => {\n\t\t\tconst imageDef = context.createPropertyDef(texture) as GLTF.IImage;\n\n\t\t\tif (texture.getMimeType()) {\n\t\t\t\timageDef.mimeType = texture.getMimeType();\n\t\t\t}\n\n\t\t\tconst image = texture.getImage();\n\t\t\tif (image) {\n\t\t\t\tcontext.createImageData(imageDef, image, texture);\n\t\t\t}\n\n\t\t\tcontext.imageIndexMap.set(texture, textureIndex);\n\t\t\treturn imageDef;\n\t\t});\n\n\t\t/* Accessors. */\n\n\t\textensionsUsed\n\t\t\t.filter((extension) => extension.prewriteTypes.includes(PropertyType.ACCESSOR))\n\t\t\t.forEach((extension) => extension.prewrite(context, PropertyType.ACCESSOR));\n\t\troot.listAccessors().forEach((accessor) => {\n\t\t\t// Attributes are grouped and interleaved in one buffer view per mesh primitive.\n\t\t\t// Indices for all primitives are grouped into a single buffer view. IBMs are grouped\n\t\t\t// into a single buffer view. Other usage (if specified by extensions) also goes into\n\t\t\t// a dedicated buffer view. Everything else goes into a miscellaneous buffer view.\n\n\t\t\t// Certain accessor usage should group data into buffer views by the accessor parent.\n\t\t\t// The `accessorParents` map uses the first parent of each accessor for this purpose.\n\t\t\tconst groupByParent = context.accessorUsageGroupedByParent;\n\t\t\tconst accessorParents = context.accessorParents;\n\n\t\t\t// Skip if already written by an extension.\n\t\t\tif (context.accessorIndexMap.has(accessor)) return;\n\n\t\t\t// Assign usage for core accessor usage types (explicit targets and implicit usage).\n\t\t\tconst usage = context.getAccessorUsage(accessor);\n\t\t\tcontext.addAccessorToUsageGroup(accessor, usage);\n\n\t\t\t// For accessor usage that requires grouping by parent (vertex and instance\n\t\t\t// attributes) organize buffer views accordingly.\n\t\t\tif (groupByParent.has(usage)) {\n\t\t\t\tconst parent = graph.listParents(accessor).find((parent) => parent.propertyType !== PropertyType.ROOT)!;\n\t\t\t\taccessorParents.set(accessor, parent);\n\t\t\t}\n\t\t});\n\n\t\t/* Buffers, buffer views. */\n\n\t\textensionsUsed\n\t\t\t.filter((extension) => extension.prewriteTypes.includes(PropertyType.BUFFER))\n\t\t\t.forEach((extension) => extension.prewrite(context, PropertyType.BUFFER));\n\n\t\tconst needsBuffer =\n\t\t\troot.listAccessors().length > 0 ||\n\t\t\tcontext.otherBufferViews.size > 0 ||\n\t\t\t(root.listTextures().length > 0 && options.format === Format.GLB);\n\t\tif (needsBuffer && root.listBuffers().length === 0) {\n\t\t\tthrow new Error('Buffer required for Document resources, but none was found.');\n\t\t}\n\n\t\tjson.buffers = [];\n\t\troot.listBuffers().forEach((buffer, index) => {\n\t\t\tconst bufferDef = context.createPropertyDef(buffer) as GLTF.IBuffer;\n\t\t\tconst groupByParent = context.accessorUsageGroupedByParent;\n\n\t\t\tconst accessors = buffer.listParents().filter((property) => property instanceof Accessor) as Accessor[];\n\t\t\tconst uniqueParents = new Set(accessors.map((accessor) => context.accessorParents.get(accessor)));\n\t\t\tconst parentToIndex = new Map(Array.from(uniqueParents).map((parent, index) => [parent, index]));\n\n\t\t\t// Group by usage and (first) parent, including vertex and instance attributes.\n\t\t\ttype AccessorGroup = { usage: string; accessors: Accessor[] };\n\t\t\tconst accessorGroups: Record<string, AccessorGroup> = {};\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\t// Skip if already written by an extension.\n\t\t\t\tif (context.accessorIndexMap.has(accessor)) continue;\n\n\t\t\t\tconst usage = context.getAccessorUsage(accessor);\n\t\t\t\tlet key = usage;\n\t\t\t\tif (groupByParent.has(usage)) {\n\t\t\t\t\tconst parent = context.accessorParents.get(accessor);\n\t\t\t\t\tkey += `:${parentToIndex.get(parent)}`;\n\t\t\t\t}\n\n\t\t\t\taccessorGroups[key] ||= { usage, accessors: [] };\n\t\t\t\taccessorGroups[key].accessors.push(accessor);\n\t\t\t}\n\n\t\t\t// Write accessor groups to buffer views.\n\n\t\t\tconst buffers: Uint8Array[] = [];\n\t\t\tconst bufferIndex = json.buffers!.length;\n\t\t\tlet bufferByteLength = 0;\n\n\t\t\tfor (const { usage, accessors: groupAccessors } of Object.values(accessorGroups)) {\n\t\t\t\tif (usage === BufferViewUsage.ARRAY_BUFFER && options.vertexLayout === VertexLayout.INTERLEAVED) {\n\t\t\t\t\t// (1) Interleaved vertex attributes.\n\t\t\t\t\tconst result = interleaveAccessors(groupAccessors, bufferIndex, bufferByteLength);\n\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\tfor (const buffer of result.buffers) {\n\t\t\t\t\t\tbuffers.push(buffer);\n\t\t\t\t\t}\n\t\t\t\t} else if (usage === BufferViewUsage.ARRAY_BUFFER) {\n\t\t\t\t\t// (2) Non-interleaved vertex attributes.\n\t\t\t\t\tfor (const accessor of groupAccessors) {\n\t\t\t\t\t\t// We 'interleave' a single accessor because the method pads to\n\t\t\t\t\t\t// 4-byte boundaries, which concatAccessors() does not.\n\t\t\t\t\t\tconst result = interleaveAccessors([accessor], bufferIndex, bufferByteLength);\n\t\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\t\tfor (const buffer of result.buffers) {\n\t\t\t\t\t\t\tbuffers.push(buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (usage === BufferViewUsage.SPARSE) {\n\t\t\t\t\t// (3) Sparse accessors.\n\t\t\t\t\tconst result = concatSparseAccessors(groupAccessors, bufferIndex, bufferByteLength);\n\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\tfor (const buffer of result.buffers) {\n\t\t\t\t\t\tbuffers.push(buffer);\n\t\t\t\t\t}\n\t\t\t\t} else if (usage === BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\n\t\t\t\t\t// (4) Indices.\n\t\t\t\t\tconst target = WriterContext.BufferViewTarget.ELEMENT_ARRAY_BUFFER;\n\t\t\t\t\tconst result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength, target);\n\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\tfor (const buffer of result.buffers) {\n\t\t\t\t\t\tbuffers.push(buffer);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// (5) Other.\n\t\t\t\t\tconst result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength);\n\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\tfor (const buffer of result.buffers) {\n\t\t\t\t\t\tbuffers.push(buffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We only support embedded images in GLB, where the embedded buffer must be the first.\n\t\t\t// Additional buffers are currently left empty (see EXT_meshopt_compression fallback).\n\t\t\tif (context.imageBufferViews.length && index === 0) {\n\t\t\t\tfor (let i = 0; i < context.imageBufferViews.length; i++) {\n\t\t\t\t\tjson.bufferViews![json.images![i].bufferView!].byteOffset = bufferByteLength;\n\t\t\t\t\tbufferByteLength += context.imageBufferViews[i].byteLength;\n\t\t\t\t\tbuffers.push(context.imageBufferViews[i]);\n\n\t\t\t\t\tif (bufferByteLength % 8) {\n\t\t\t\t\t\t// See: https://github.com/KhronosGroup/glTF/issues/1935\n\t\t\t\t\t\tconst imagePadding = 8 - (bufferByteLength % 8);\n\t\t\t\t\t\tbufferByteLength += imagePadding;\n\t\t\t\t\t\tbuffers.push(new Uint8Array(imagePadding));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.otherBufferViews.has(buffer)) {\n\t\t\t\tfor (const data of context.otherBufferViews.get(buffer)!) {\n\t\t\t\t\tjson.bufferViews!.push({\n\t\t\t\t\t\tbuffer: bufferIndex,\n\t\t\t\t\t\tbyteOffset: bufferByteLength,\n\t\t\t\t\t\tbyteLength: data.byteLength,\n\t\t\t\t\t});\n\t\t\t\t\tcontext.otherBufferViewsIndexMap.set(data, json.bufferViews!.length - 1);\n\t\t\t\t\tbufferByteLength += data.byteLength;\n\t\t\t\t\tbuffers.push(data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bufferByteLength) {\n\t\t\t\t// Assign buffer URI.\n\t\t\t\tlet uri: string;\n\t\t\t\tif (options.format === Format.GLB) {\n\t\t\t\t\turi = GLB_BUFFER;\n\t\t\t\t} else {\n\t\t\t\t\turi = context.bufferURIGenerator.createURI(buffer, 'bin');\n\t\t\t\t\tbufferDef.uri = uri;\n\t\t\t\t}\n\n\t\t\t\t// Write buffer views to buffer.\n\t\t\t\tbufferDef.byteLength = bufferByteLength;\n\t\t\t\tcontext.assignResourceURI(uri, BufferUtils.concat(buffers), true);\n\t\t\t}\n\n\t\t\tjson.buffers!.push(bufferDef);\n\t\t\tcontext.bufferIndexMap.set(buffer, index);\n\t\t});\n\n\t\tif (root.listAccessors().find((a) => !a.getBuffer())) {\n\t\t\tlogger.warn('Skipped writing one or more Accessors: no Buffer assigned.');\n\t\t}\n\n\t\t/* Materials. */\n\n\t\textensionsUsed\n\t\t\t.filter((extension) => extension.prewriteTypes.includes(PropertyType.MATERIAL))\n\t\t\t.forEach((extension) => extension.prewrite(context, PropertyType.MATERIAL));\n\n\t\tjson.materials = root.listMaterials().map((material, index) => {\n\t\t\tconst materialDef = context.createPropertyDef(material) as GLTF.IMaterial;\n\n\t\t\t// Program state & blending.\n\n\t\t\tif (material.getAlphaMode() !== Material.AlphaMode.OPAQUE) {\n\t\t\t\tmaterialDef.alphaMode = material.getAlphaMode();\n\t\t\t}\n\t\t\tif (material.getAlphaMode() === Material.AlphaMode.MASK) {\n\t\t\t\tmaterialDef.alphaCutoff = material.getAlphaCutoff();\n\t\t\t}\n\t\t\tif (material.getDoubleSided()) materialDef.doubleSided = true;\n\n\t\t\t// Factors.\n\n\t\t\tmaterialDef.pbrMetallicRoughness = {};\n\t\t\tif (!MathUtils.eq(material.getBaseColorFactor(), [1, 1, 1, 1])) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = material.getBaseColorFactor();\n\t\t\t}\n\t\t\tif (!MathUtils.eq(material.getEmissiveFactor(), [0, 0, 0])) {\n\t\t\t\tmaterialDef.emissiveFactor = material.getEmissiveFactor();\n\t\t\t}\n\t\t\tif (material.getRoughnessFactor() !== 1) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.getRoughnessFactor();\n\t\t\t}\n\t\t\tif (material.getMetallicFactor() !== 1) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.getMetallicFactor();\n\t\t\t}\n\n\t\t\t// Textures.\n\n\t\t\tif (material.getBaseColorTexture()) {\n\t\t\t\tconst texture = material.getBaseColorTexture()!;\n\t\t\t\tconst textureInfo = material.getBaseColorTextureInfo()!;\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (material.getEmissiveTexture()) {\n\t\t\t\tconst texture = material.getEmissiveTexture()!;\n\t\t\t\tconst textureInfo = material.getEmissiveTextureInfo()!;\n\t\t\t\tmaterialDef.emissiveTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (material.getNormalTexture()) {\n\t\t\t\tconst texture = material.getNormalTexture()!;\n\t\t\t\tconst textureInfo = material.getNormalTextureInfo()!;\n\t\t\t\tconst textureInfoDef = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo,\n\t\t\t\t) as GLTF.IMaterialNormalTextureInfo;\n\t\t\t\tif (material.getNormalScale() !== 1) {\n\t\t\t\t\ttextureInfoDef.scale = material.getNormalScale();\n\t\t\t\t}\n\t\t\t\tmaterialDef.normalTexture = textureInfoDef;\n\t\t\t}\n\n\t\t\tif (material.getOcclusionTexture()) {\n\t\t\t\tconst texture = material.getOcclusionTexture()!;\n\t\t\t\tconst textureInfo = material.getOcclusionTextureInfo()!;\n\t\t\t\tconst textureInfoDef = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo,\n\t\t\t\t) as GLTF.IMaterialOcclusionTextureInfo;\n\t\t\t\tif (material.getOcclusionStrength() !== 1) {\n\t\t\t\t\ttextureInfoDef.strength = material.getOcclusionStrength();\n\t\t\t\t}\n\t\t\t\tmaterialDef.occlusionTexture = textureInfoDef;\n\t\t\t}\n\n\t\t\tif (material.getMetallicRoughnessTexture()) {\n\t\t\t\tconst texture = material.getMetallicRoughnessTexture()!;\n\t\t\t\tconst textureInfo = material.getMetallicRoughnessTextureInfo()!;\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.materialIndexMap.set(material, index);\n\t\t\treturn materialDef;\n\t\t});\n\n\t\t/* Meshes. */\n\n\t\textensionsUsed\n\t\t\t.filter((extension) => extension.prewriteTypes.includes(PropertyType.MESH))\n\t\t\t.forEach((extension) => extension.prewrite(context, PropertyType.MESH));\n\n\t\tjson.meshes = root.listMeshes().map((mesh, index) => {\n\t\t\tconst meshDef = context.createPropertyDef(mesh) as GLTF.IMesh;\n\n\t\t\tlet targetNames: string[] | null = null;\n\n\t\t\tmeshDef.primitives = mesh.listPrimitives().map((primitive) => {\n\t\t\t\tconst primitiveDef: GLTF.IMeshPrimitive = { attributes: {} };\n\n\t\t\t\tprimitiveDef.mode = primitive.getMode();\n\n\t\t\t\tconst material = primitive.getMaterial();\n\t\t\t\tif (material) {\n\t\t\t\t\tprimitiveDef.material = context.materialIndexMap.get(material);\n\t\t\t\t}\n\n\t\t\t\tif (Object.keys(primitive.getExtras()).length) {\n\t\t\t\t\tprimitiveDef.extras = primitive.getExtras();\n\t\t\t\t}\n\n\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\tif (indices) {\n\t\t\t\t\tprimitiveDef.indices = context.accessorIndexMap.get(indices);\n\t\t\t\t}\n\n\t\t\t\tfor (const semantic of primitive.listSemantics()) {\n\t\t\t\t\tprimitiveDef.attributes[semantic] = context.accessorIndexMap.get(\n\t\t\t\t\t\tprimitive.getAttribute(semantic)!,\n\t\t\t\t\t)!;\n\t\t\t\t}\n\n\t\t\t\tfor (const target of primitive.listTargets()) {\n\t\t\t\t\tconst targetDef = {} as { [name: string]: number };\n\n\t\t\t\t\tfor (const semantic of target.listSemantics()) {\n\t\t\t\t\t\ttargetDef[semantic] = context.accessorIndexMap.get(target.getAttribute(semantic)!)!;\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitiveDef.targets = primitiveDef.targets || [];\n\t\t\t\t\tprimitiveDef.targets.push(targetDef);\n\t\t\t\t}\n\n\t\t\t\tif (primitive.listTargets().length && !targetNames) {\n\t\t\t\t\ttargetNames = primitive.listTargets().map((target) => target.getName());\n\t\t\t\t}\n\n\t\t\t\treturn primitiveDef;\n\t\t\t});\n\n\t\t\tif (mesh.getWeights().length) {\n\t\t\t\tmeshDef.weights = mesh.getWeights();\n\t\t\t}\n\n\t\t\tif (targetNames) {\n\t\t\t\tmeshDef.extras = meshDef.extras || {};\n\t\t\t\tmeshDef.extras['targetNames'] = targetNames;\n\t\t\t}\n\n\t\t\tcontext.meshIndexMap.set(mesh, index);\n\t\t\treturn meshDef;\n\t\t});\n\n\t\t/** Cameras. */\n\n\t\tjson.cameras = root.listCameras().map((camera, index) => {\n\t\t\tconst cameraDef = context.createPropertyDef(camera) as GLTF.ICamera;\n\t\t\tcameraDef.type = camera.getType();\n\t\t\tif (cameraDef.type === Camera.Type.PERSPECTIVE) {\n\t\t\t\tcameraDef.perspective = {\n\t\t\t\t\tznear: camera.getZNear(),\n\t\t\t\t\tzfar: camera.getZFar(),\n\t\t\t\t\tyfov: camera.getYFov(),\n\t\t\t\t};\n\t\t\t\tconst aspectRatio = camera.getAspectRatio();\n\t\t\t\tif (aspectRatio !== null) {\n\t\t\t\t\tcameraDef.perspective.aspectRatio = aspectRatio;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcameraDef.orthographic = {\n\t\t\t\t\tznear: camera.getZNear(),\n\t\t\t\t\tzfar: camera.getZFar(),\n\t\t\t\t\txmag: camera.getXMag(),\n\t\t\t\t\tymag: camera.getYMag(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcontext.cameraIndexMap.set(camera, index);\n\t\t\treturn cameraDef;\n\t\t});\n\n\t\t/* Nodes. */\n\n\t\tjson.nodes = root.listNodes().map((node, index) => {\n\t\t\tconst nodeDef = context.createPropertyDef(node) as GLTF.INode;\n\n\t\t\tif (!MathUtils.eq(node.getTranslation(), [0, 0, 0])) {\n\t\t\t\tnodeDef.translation = node.getTranslation();\n\t\t\t}\n\n\t\t\tif (!MathUtils.eq(node.getRotation(), [0, 0, 0, 1])) {\n\t\t\t\tnodeDef.rotation = node.getRotation();\n\t\t\t}\n\n\t\t\tif (!MathUtils.eq(node.getScale(), [1, 1, 1])) {\n\t\t\t\tnodeDef.scale = node.getScale();\n\t\t\t}\n\n\t\t\tif (node.getWeights().length) {\n\t\t\t\tnodeDef.weights = node.getWeights();\n\t\t\t}\n\n\t\t\t// Attachments (mesh, camera, skin) defined later in writing process.\n\n\t\t\tcontext.nodeIndexMap.set(node, index);\n\t\t\treturn nodeDef;\n\t\t});\n\n\t\t/** Skins. */\n\n\t\tjson.skins = root.listSkins().map((skin, index) => {\n\t\t\tconst skinDef = context.createPropertyDef(skin) as GLTF.ISkin;\n\n\t\t\tconst inverseBindMatrices = skin.getInverseBindMatrices();\n\t\t\tif (inverseBindMatrices) {\n\t\t\t\tskinDef.inverseBindMatrices = context.accessorIndexMap.get(inverseBindMatrices);\n\t\t\t}\n\n\t\t\tconst skeleton = skin.getSkeleton();\n\t\t\tif (skeleton) {\n\t\t\t\tskinDef.skeleton = context.nodeIndexMap.get(skeleton);\n\t\t\t}\n\n\t\t\tskinDef.joints = skin.listJoints().map((joint) => context.nodeIndexMap.get(joint)!);\n\n\t\t\tcontext.skinIndexMap.set(skin, index);\n\t\t\treturn skinDef;\n\t\t});\n\n\t\t/** Node attachments. */\n\n\t\troot.listNodes().forEach((node, index) => {\n\t\t\tconst nodeDef = json.nodes![index];\n\n\t\t\tconst mesh = node.getMesh();\n\t\t\tif (mesh) {\n\t\t\t\tnodeDef.mesh = context.meshIndexMap.get(mesh);\n\t\t\t}\n\n\t\t\tconst camera = node.getCamera();\n\t\t\tif (camera) {\n\t\t\t\tnodeDef.camera = context.cameraIndexMap.get(camera);\n\t\t\t}\n\n\t\t\tconst skin = node.getSkin();\n\t\t\tif (skin) {\n\t\t\t\tnodeDef.skin = context.skinIndexMap.get(skin);\n\t\t\t}\n\n\t\t\tif (node.listChildren().length > 0) {\n\t\t\t\tnodeDef.children = node.listChildren().map((node) => context.nodeIndexMap.get(node)!);\n\t\t\t}\n\t\t});\n\n\t\t/** Animations. */\n\n\t\tjson.animations = root.listAnimations().map((animation, index) => {\n\t\t\tconst animationDef = context.createPropertyDef(animation) as GLTF.IAnimation;\n\n\t\t\tconst samplerIndexMap: Map<AnimationSampler, number> = new Map();\n\n\t\t\tanimationDef.samplers = animation.listSamplers().map((sampler, samplerIndex) => {\n\t\t\t\tconst samplerDef = context.createPropertyDef(sampler) as GLTF.IAnimationSampler;\n\t\t\t\tsamplerDef.input = context.accessorIndexMap.get(sampler.getInput()!)!;\n\t\t\t\tsamplerDef.output = context.accessorIndexMap.get(sampler.getOutput()!)!;\n\t\t\t\tsamplerDef.interpolation = sampler.getInterpolation();\n\t\t\t\tsamplerIndexMap.set(sampler, samplerIndex);\n\t\t\t\treturn samplerDef;\n\t\t\t});\n\n\t\t\tanimationDef.channels = animation.listChannels().map((channel) => {\n\t\t\t\tconst channelDef = context.createPropertyDef(channel) as GLTF.IAnimationChannel;\n\t\t\t\tchannelDef.sampler = samplerIndexMap.get(channel.getSampler()!)!;\n\t\t\t\tchannelDef.target = {\n\t\t\t\t\tnode: context.nodeIndexMap.get(channel.getTargetNode()!)!,\n\t\t\t\t\tpath: channel.getTargetPath()!,\n\t\t\t\t};\n\t\t\t\treturn channelDef;\n\t\t\t});\n\n\t\t\tcontext.animationIndexMap.set(animation, index);\n\t\t\treturn animationDef;\n\t\t});\n\n\t\t/* Scenes. */\n\n\t\tjson.scenes = root.listScenes().map((scene, index) => {\n\t\t\tconst sceneDef = context.createPropertyDef(scene) as GLTF.IScene;\n\t\t\tsceneDef.nodes = scene.listChildren().map((node) => context.nodeIndexMap.get(node)!);\n\t\t\tcontext.sceneIndexMap.set(scene, index);\n\t\t\treturn sceneDef;\n\t\t});\n\n\t\tconst defaultScene = root.getDefaultScene();\n\t\tif (defaultScene) {\n\t\t\tjson.scene = root.listScenes().indexOf(defaultScene);\n\t\t}\n\n\t\t/* Extensions (2/2). */\n\n\t\tjson.extensionsUsed = extensionsUsed.map((ext) => ext.extensionName);\n\t\tjson.extensionsRequired = extensionsRequired.map((ext) => ext.extensionName);\n\t\textensionsUsed.forEach((extension) => extension.write(context));\n\n\t\t//\n\n\t\tclean(json as unknown as Record<string, unknown>);\n\n\t\treturn jsonDoc;\n\t}\n}\n\n/**\n * Removes empty and null values from an object.\n * @param object\n * @internal\n */\nfunction clean(object: Record<string, unknown>): void {\n\tconst unused: string[] = [];\n\n\tfor (const key in object) {\n\t\tconst value = object[key];\n\t\tif (Array.isArray(value) && value.length === 0) {\n\t\t\tunused.push(key);\n\t\t} else if (value === null || value === '') {\n\t\t\tunused.push(key);\n\t\t} else if (value && typeof value === 'object' && Object.keys(value).length === 0) {\n\t\t\tunused.push(key);\n\t\t}\n\t}\n\n\tfor (const key of unused) {\n\t\tdelete object[key];\n\t}\n}\n", "import { Format, GLB_BUFFER, VertexLayout } from '../constants.js';\nimport type { Document } from '../document.js';\nimport type { Extension } from '../extension.js';\nimport type { JSONDocument } from '../json-document.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { BufferUtils, FileUtils, type ILogger, Logger, uuid } from '../utils/index.js';\nimport { GLTFReader } from './reader.js';\nimport { GLTFWriter, type WriterOptions } from './writer.js';\n\nenum ChunkType {\n\tJSON = 0x4e4f534a,\n\tBIN = 0x004e4942,\n}\n\ntype PublicWriterOptions = Partial<Pick<WriterOptions, 'format' | 'basename'>>;\n\n/**\n * *Abstract I/O service.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * For platform-specific implementations, see {@link NodeIO}, {@link WebIO}, and {@link DenoIO}.\n *\n * @category I/O\n */\nexport abstract class PlatformIO {\n\tprotected _logger: ILogger = Logger.DEFAULT_INSTANCE;\n\tprivate _extensions = new Set<typeof Extension>();\n\tprivate _dependencies: { [key: string]: unknown } = {};\n\tprivate _vertexLayout = VertexLayout.INTERLEAVED;\n\n\t/** @hidden */\n\tpublic lastReadBytes = 0;\n\n\t/** @hidden */\n\tpublic lastWriteBytes = 0;\n\n\t/** Sets the {@link Logger} used by this I/O instance. Defaults to Logger.DEFAULT_INSTANCE. */\n\tpublic setLogger(logger: ILogger): this {\n\t\tthis._logger = logger;\n\t\treturn this;\n\t}\n\n\t/** Registers extensions, enabling I/O class to read and write glTF assets requiring them. */\n\tpublic registerExtensions(extensions: (typeof Extension)[]): this {\n\t\tfor (const extension of extensions) {\n\t\t\tthis._extensions.add(extension);\n\t\t\textension.register();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Registers dependencies used (e.g. by extensions) in the I/O process. */\n\tpublic registerDependencies(dependencies: { [key: string]: unknown }): this {\n\t\tObject.assign(this._dependencies, dependencies);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the vertex layout method used by this I/O instance. Defaults to\n\t * VertexLayout.INTERLEAVED.\n\t */\n\tpublic setVertexLayout(layout: VertexLayout): this {\n\t\tthis._vertexLayout = layout;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Abstract.\n\t */\n\n\tprotected abstract readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected abstract readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected abstract readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string>;\n\n\tprotected abstract resolve(base: string, path: string): string;\n\tprotected abstract dirname(uri: string): string;\n\n\t/**********************************************************************************************\n\t * Public Read API.\n\t */\n\n\t/** Reads a {@link Document} from the given URI. */\n\tpublic async read(uri: string): Promise<Document> {\n\t\treturn await this.readJSON(await this.readAsJSON(uri));\n\t}\n\n\t/** Loads a URI and returns a {@link JSONDocument} struct, without parsing. */\n\tpublic async readAsJSON(uri: string): Promise<JSONDocument> {\n\t\tconst view = await this.readURI(uri, 'view');\n\t\tthis.lastReadBytes = view.byteLength;\n\t\tconst jsonDoc = isGLB(view)\n\t\t\t? this._binaryToJSON(view)\n\t\t\t: { json: JSON.parse(BufferUtils.decodeText(view)), resources: {} };\n\t\t// Read external resources first, before Data URIs are replaced.\n\t\tawait this._readResourcesExternal(jsonDoc, this.dirname(uri));\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\treturn jsonDoc;\n\t}\n\n\t/** Converts glTF-formatted JSON and a resource map to a {@link Document}. */\n\tpublic async readJSON(jsonDoc: JSONDocument): Promise<Document> {\n\t\tjsonDoc = this._copyJSON(jsonDoc);\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\treturn GLTFReader.read(jsonDoc, {\n\t\t\textensions: Array.from(this._extensions),\n\t\t\tdependencies: this._dependencies,\n\t\t\tlogger: this._logger,\n\t\t});\n\t}\n\n\t/** Converts a GLB-formatted Uint8Array to a {@link JSONDocument}. */\n\tpublic async binaryToJSON(glb: Uint8Array): Promise<JSONDocument> {\n\t\tconst jsonDoc = this._binaryToJSON(BufferUtils.assertView(glb));\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\tconst json = jsonDoc.json;\n\n\t\t// Check for external references, which can't be resolved by this method.\n\t\tif (json.buffers && json.buffers.some((bufferDef) => isExternalBuffer(jsonDoc, bufferDef))) {\n\t\t\tthrow new Error('Cannot resolve external buffers with binaryToJSON().');\n\t\t} else if (json.images && json.images.some((imageDef) => isExternalImage(jsonDoc, imageDef))) {\n\t\t\tthrow new Error('Cannot resolve external images with binaryToJSON().');\n\t\t}\n\n\t\treturn jsonDoc;\n\t}\n\n\t/** Converts a GLB-formatted Uint8Array to a {@link Document}. */\n\tpublic async readBinary(glb: Uint8Array): Promise<Document> {\n\t\treturn this.readJSON(await this.binaryToJSON(BufferUtils.assertView(glb)));\n\t}\n\n\t/**********************************************************************************************\n\t * Public Write API.\n\t */\n\n\t/** Converts a {@link Document} to glTF-formatted JSON and a resource map. */\n\tpublic async writeJSON(doc: Document, _options: PublicWriterOptions = {}): Promise<JSONDocument> {\n\t\tif (_options.format === Format.GLB && doc.getRoot().listBuffers().length > 1) {\n\t\t\tthrow new Error('GLB must have 0–1 buffers.');\n\t\t}\n\t\treturn GLTFWriter.write(doc, {\n\t\t\tformat: _options.format || Format.GLTF,\n\t\t\tbasename: _options.basename || '',\n\t\t\tlogger: this._logger,\n\t\t\tvertexLayout: this._vertexLayout,\n\t\t\tdependencies: { ...this._dependencies },\n\t\t\textensions: Array.from(this._extensions),\n\t\t} as Required<WriterOptions>);\n\t}\n\n\t/** Converts a {@link Document} to a GLB-formatted Uint8Array. */\n\tpublic async writeBinary(doc: Document): Promise<Uint8Array> {\n\t\tconst { json, resources } = await this.writeJSON(doc, { format: Format.GLB });\n\n\t\tconst header = new Uint32Array([0x46546c67, 2, 12]);\n\n\t\tconst jsonText = JSON.stringify(json);\n\t\tconst jsonChunkData = BufferUtils.pad(BufferUtils.encodeText(jsonText), 0x20);\n\t\tconst jsonChunkHeader = BufferUtils.toView(new Uint32Array([jsonChunkData.byteLength, 0x4e4f534a]));\n\t\tconst jsonChunk = BufferUtils.concat([jsonChunkHeader, jsonChunkData]);\n\t\theader[header.length - 1] += jsonChunk.byteLength;\n\n\t\tconst binBuffer = Object.values(resources)[0];\n\t\tif (!binBuffer || !binBuffer.byteLength) {\n\t\t\treturn BufferUtils.concat([BufferUtils.toView(header), jsonChunk]);\n\t\t}\n\n\t\tconst binChunkData = BufferUtils.pad(binBuffer, 0x00);\n\t\tconst binChunkHeader = BufferUtils.toView(new Uint32Array([binChunkData.byteLength, 0x004e4942]));\n\t\tconst binChunk = BufferUtils.concat([binChunkHeader, binChunkData]);\n\t\theader[header.length - 1] += binChunk.byteLength;\n\n\t\treturn BufferUtils.concat([BufferUtils.toView(header), jsonChunk, binChunk]);\n\t}\n\n\t/**********************************************************************************************\n\t * Internal.\n\t */\n\n\tprivate async _readResourcesExternal(jsonDoc: JSONDocument, base: string): Promise<void> {\n\t\tconst images = jsonDoc.json.images || [];\n\t\tconst buffers = jsonDoc.json.buffers || [];\n\t\tconst pendingResources: Array<Promise<void>> = [...images, ...buffers].map(\n\t\t\tasync (resource: GLTF.IBuffer | GLTF.IImage): Promise<void> => {\n\t\t\t\tconst uri = resource.uri;\n\t\t\t\tif (!uri || uri.match(/data:/)) return Promise.resolve();\n\n\t\t\t\tjsonDoc.resources[uri] = await this.readURI(this.resolve(base, uri), 'view');\n\t\t\t\tthis.lastReadBytes += jsonDoc.resources[uri].byteLength;\n\t\t\t},\n\t\t);\n\t\tawait Promise.all(pendingResources);\n\t}\n\n\tprivate _readResourcesInternal(jsonDoc: JSONDocument): void {\n\t\t// NOTICE: This method may be called more than once during the loading\n\t\t// process (e.g. WebIO.read) and should handle that safely.\n\n\t\tfunction resolveResource(resource: GLTF.IBuffer | GLTF.IImage) {\n\t\t\tif (!resource.uri) return;\n\n\t\t\tif (resource.uri in jsonDoc.resources) {\n\t\t\t\tBufferUtils.assertView(jsonDoc.resources[resource.uri]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (resource.uri.match(/data:/)) {\n\t\t\t\t// Rewrite Data URIs to something short and unique.\n\t\t\t\tconst resourceUUID = `__${uuid()}.${FileUtils.extension(resource.uri)}`;\n\t\t\t\tjsonDoc.resources[resourceUUID] = BufferUtils.createBufferFromDataURI(resource.uri);\n\t\t\t\tresource.uri = resourceUUID;\n\t\t\t}\n\t\t}\n\n\t\t// Unpack images.\n\t\tconst images = jsonDoc.json.images || [];\n\t\timages.forEach((image: GLTF.IImage) => {\n\t\t\tif (image.bufferView === undefined && image.uri === undefined) {\n\t\t\t\tthrow new Error('Missing resource URI or buffer view.');\n\t\t\t}\n\n\t\t\tresolveResource(image);\n\t\t});\n\n\t\t// Unpack buffers.\n\t\tconst buffers = jsonDoc.json.buffers || [];\n\t\tbuffers.forEach(resolveResource);\n\t}\n\n\t/**\n\t * Creates a shallow copy of glTF-formatted {@link JSONDocument}.\n\t *\n\t * Images, Buffers, and Resources objects are deep copies so that PlatformIO can safely\n\t * modify them during the parsing process. Other properties are shallow copies, and buffers\n\t * are passed by reference.\n\t */\n\tprivate _copyJSON(jsonDoc: JSONDocument): JSONDocument {\n\t\tconst { images, buffers } = jsonDoc.json;\n\n\t\tjsonDoc = { json: { ...jsonDoc.json }, resources: { ...jsonDoc.resources } };\n\n\t\tif (images) {\n\t\t\tjsonDoc.json.images = images.map((image) => ({ ...image }));\n\t\t}\n\t\tif (buffers) {\n\t\t\tjsonDoc.json.buffers = buffers.map((buffer) => ({ ...buffer }));\n\t\t}\n\n\t\treturn jsonDoc;\n\t}\n\n\t/** Internal version of binaryToJSON; does not warn about external resources. */\n\tprivate _binaryToJSON(glb: Uint8Array): JSONDocument {\n\t\t// Decode and verify GLB header.\n\t\tif (!isGLB(glb)) {\n\t\t\tthrow new Error('Invalid glTF 2.0 binary.');\n\t\t}\n\n\t\t// Decode JSON chunk.\n\n\t\tconst jsonChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + 12, 2);\n\t\tif (jsonChunkHeader[1] !== ChunkType.JSON) {\n\t\t\tthrow new Error('Missing required GLB JSON chunk.');\n\t\t}\n\n\t\tconst jsonByteOffset = 20;\n\t\tconst jsonByteLength = jsonChunkHeader[0];\n\t\tconst jsonText = BufferUtils.decodeText(BufferUtils.toView(glb, jsonByteOffset, jsonByteLength));\n\t\tconst json = JSON.parse(jsonText) as GLTF.IGLTF;\n\n\t\t// Decode BIN chunk.\n\n\t\tconst binByteOffset = jsonByteOffset + jsonByteLength;\n\t\tif (glb.byteLength <= binByteOffset) {\n\t\t\treturn { json, resources: {} };\n\t\t}\n\n\t\tconst binChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + binByteOffset, 2);\n\t\tif (binChunkHeader[1] !== ChunkType.BIN) {\n\t\t\t// Allow GLB files without BIN chunk, but with unknown chunk\n\t\t\t// Spec: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#chunks-overview\n\t\t\treturn { json, resources: {} };\n\t\t}\n\n\t\tconst binByteLength = binChunkHeader[0];\n\t\tconst binBuffer = BufferUtils.toView(glb, binByteOffset + 8, binByteLength);\n\n\t\treturn { json, resources: { [GLB_BUFFER]: binBuffer } };\n\t}\n}\n\nfunction isExternalBuffer(jsonDocument: JSONDocument, bufferDef: GLTF.IBuffer): boolean {\n\treturn bufferDef.uri !== undefined && !(bufferDef.uri in jsonDocument.resources);\n}\n\nfunction isExternalImage(jsonDocument: JSONDocument, imageDef: GLTF.IImage): boolean {\n\treturn imageDef.uri !== undefined && !(imageDef.uri in jsonDocument.resources) && imageDef.bufferView === undefined;\n}\n\nfunction isGLB(view: Uint8Array): boolean {\n\tif (view.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT) return false;\n\tconst header = new Uint32Array(view.buffer, view.byteOffset, 3);\n\treturn header[0] === 0x46546c67 && header[1] === 2;\n}\n", "import { PlatformIO } from './platform-io.js';\n\ninterface Path {\n\tresolve(base: string, path: string): string;\n\tdirname(uri: string): string;\n}\n\n/**\n * *I/O service for [Deno](https://deno.land/).*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * _*NOTICE:* Support for the Deno environment is currently experimental. See\n * [glTF-Transform#457](https://github.com/donmccurdy/glTF-Transform/issues/457)._\n *\n * Usage:\n *\n * ```typescript\n * import { DenoIO } from 'https://esm.sh/@gltf-transform/core';\n * import * as path from 'https://deno.land/std/path/mod.ts';\n *\n * const io = new DenoIO(path);\n *\n * // Read.\n * let document;\n * document = io.read('model.glb');  // → Document\n * document = io.readBinary(glb);    // Uint8Array → Document\n *\n * // Write.\n * const glb = io.writeBinary(document);  // Document → Uint8Array\n * ```\n *\n * @category I/O\n */\nexport class DenoIO extends PlatformIO {\n\tprivate _path: Path;\n\n\tconstructor(path: unknown) {\n\t\tsuper();\n\t\tthis._path = path as Path;\n\t}\n\n\tprotected async readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected async readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected async readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string> {\n\t\tswitch (type) {\n\t\t\tcase 'view':\n\t\t\t\treturn Deno.readFile(uri);\n\t\t\tcase 'text':\n\t\t\t\treturn Deno.readTextFile(uri);\n\t\t}\n\t}\n\n\tprotected resolve(base: string, path: string): string {\n\t\t// https://github.com/KhronosGroup/glTF/issues/1449\n\t\t// https://stackoverflow.com/a/27278490/1314762\n\t\treturn this._path.resolve(base, decodeURIComponent(path));\n\t}\n\n\tprotected dirname(uri: string): string {\n\t\treturn this._path.dirname(uri);\n\t}\n}\n", "import { Format } from '../constants.js';\nimport type { Document } from '../document.js';\nimport { FileUtils, HTTPUtils } from '../utils/index.js';\nimport { PlatformIO } from './platform-io.js';\n\n/**\n * *I/O service for Node.js.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n *\n * const io = new NodeIO();\n *\n * // Read.\n * let document;\n * document = await io.read('model.glb'); // → Document\n * document = await io.readBinary(glb);   // Uint8Array → Document\n *\n * // Write.\n * await io.write('model.glb', document);      // → void\n * const glb = await io.writeBinary(document); // Document → Uint8Array\n * ```\n *\n * By default, NodeIO can only read/write paths on disk. To enable network requests, provide a Fetch\n * API implementation (global [`fetch()`](https://nodejs.org/api/globals.html#fetch) is stable in\n * Node.js v21+, or [`node-fetch`](https://www.npmjs.com/package/node-fetch) may be installed) and enable\n * {@link NodeIO.setAllowNetwork setAllowNetwork}. Network requests may optionally be configured with\n * [RequestInit](https://developer.mozilla.org/en-US/docs/Web/API/fetch#parameters) parameters.\n *\n * ```typescript\n * const io = new NodeIO(fetch, {headers: {...}}).setAllowNetwork(true);\n *\n * const document = await io.read('https://example.com/path/to/model.glb');\n * ```\n *\n * @category I/O\n */\nexport class NodeIO extends PlatformIO {\n\tprivate declare _fs;\n\tprivate declare _path;\n\tprivate readonly _fetch: typeof fetch | null;\n\tprivate readonly _fetchConfig: RequestInit;\n\n\tprivate _init: Promise<void>;\n\tprivate _fetchEnabled = false;\n\n\t/**\n\t * Constructs a new NodeIO service. Instances are reusable. By default, only NodeIO can only\n\t * read/write paths on disk. To enable HTTP requests, provide a Fetch API implementation and\n\t * enable {@link NodeIO.setAllowNetwork setAllowNetwork}.\n\t *\n\t * @param fetch Implementation of Fetch API.\n\t * @param fetchConfig Configuration object for Fetch API.\n\t */\n\tconstructor(_fetch: unknown = null, _fetchConfig: RequestInit = HTTPUtils.DEFAULT_INIT) {\n\t\tsuper();\n\t\tthis._fetch = _fetch as typeof fetch | null;\n\t\tthis._fetchConfig = _fetchConfig;\n\t\tthis._init = this.init();\n\t}\n\n\tpublic async init(): Promise<void> {\n\t\tif (this._init) return this._init;\n\t\treturn Promise.all([import('fs'), import('path')]).then(([fs, path]) => {\n\t\t\tthis._fs = fs.promises;\n\t\t\tthis._path = path;\n\t\t});\n\t}\n\n\tpublic setAllowNetwork(allow: boolean): this {\n\t\tif (allow && !this._fetch) {\n\t\t\tthrow new Error('NodeIO requires a Fetch API implementation for HTTP requests.');\n\t\t}\n\t\tthis._fetchEnabled = allow;\n\t\treturn this;\n\t}\n\n\tprotected async readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected async readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected async readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string> {\n\t\tawait this.init();\n\t\tif (HTTPUtils.isAbsoluteURL(uri)) {\n\t\t\tif (!this._fetchEnabled || !this._fetch) {\n\t\t\t\tthrow new Error('Network request blocked. Allow HTTP requests explicitly, if needed.');\n\t\t\t}\n\n\t\t\tconst response = await this._fetch(uri, this._fetchConfig);\n\t\t\tswitch (type) {\n\t\t\t\tcase 'view':\n\t\t\t\t\treturn new Uint8Array(await response.arrayBuffer());\n\t\t\t\tcase 'text':\n\t\t\t\t\treturn response.text();\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (type) {\n\t\t\t\tcase 'view':\n\t\t\t\t\treturn this._fs.readFile(uri);\n\t\t\t\tcase 'text':\n\t\t\t\t\treturn this._fs.readFile(uri, 'utf8');\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected resolve(base: string, path: string): string {\n\t\tif (HTTPUtils.isAbsoluteURL(base) || HTTPUtils.isAbsoluteURL(path)) {\n\t\t\treturn HTTPUtils.resolve(base, path);\n\t\t}\n\t\t// https://github.com/KhronosGroup/glTF/issues/1449\n\t\t// https://stackoverflow.com/a/27278490/1314762\n\t\treturn this._path.resolve(base, decodeURIComponent(path));\n\t}\n\n\tprotected dirname(uri: string): string {\n\t\tif (HTTPUtils.isAbsoluteURL(uri)) {\n\t\t\treturn HTTPUtils.dirname(uri);\n\t\t}\n\t\treturn this._path.dirname(uri);\n\t}\n\n\t/**********************************************************************************************\n\t * Public.\n\t */\n\n\t/** Writes a {@link Document} instance to a local path. */\n\tpublic async write(uri: string, doc: Document): Promise<void> {\n\t\tawait this.init();\n\t\tconst isGLB = !!uri.match(/\\.glb$/);\n\t\tawait (isGLB ? this._writeGLB(uri, doc) : this._writeGLTF(uri, doc));\n\t}\n\n\t/**********************************************************************************************\n\t * Private.\n\t */\n\n\t/** @internal */\n\tprivate async _writeGLTF(uri: string, doc: Document): Promise<void> {\n\t\tthis.lastWriteBytes = 0;\n\t\tconst { json, resources } = await this.writeJSON(doc, {\n\t\t\tformat: Format.GLTF,\n\t\t\tbasename: FileUtils.basename(uri),\n\t\t});\n\t\tconst { _fs: fs, _path: path } = this;\n\t\tconst dir = path.dirname(uri);\n\n\t\t// write json\n\t\tconst jsonContent = JSON.stringify(json, null, 2);\n\t\tawait fs.writeFile(uri, jsonContent);\n\t\tthis.lastWriteBytes += jsonContent.length;\n\n\t\t// write resources\n\t\tfor (const batch of listBatches(Object.keys(resources), 10)) {\n\t\t\tawait Promise.all(\n\t\t\t\tbatch.map(async (resourceURI) => {\n\t\t\t\t\tif (HTTPUtils.isAbsoluteURL(resourceURI)) {\n\t\t\t\t\t\tif (HTTPUtils.extension(resourceURI) === 'bin') {\n\t\t\t\t\t\t\tthrow new Error(`Cannot write buffer to path \"${resourceURI}\".`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst resourcePath = path.join(dir, decodeURIComponent(resourceURI));\n\t\t\t\t\tawait fs.mkdir(path.dirname(resourcePath), { recursive: true });\n\t\t\t\t\tawait fs.writeFile(resourcePath, resources[resourceURI]);\n\t\t\t\t\tthis.lastWriteBytes += resources[resourceURI].byteLength;\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate async _writeGLB(uri: string, doc: Document): Promise<void> {\n\t\tconst buffer = await this.writeBinary(doc);\n\t\tawait this._fs.writeFile(uri, buffer);\n\t\tthis.lastWriteBytes = buffer.byteLength;\n\t}\n}\n\n/** Divides a flat input array into batches of size `batchSize`. */\nfunction listBatches<T>(array: T[], batchSize: number): T[][] {\n\tconst batches: T[][] = [];\n\n\tfor (let i = 0, il = array.length; i < il; i += batchSize) {\n\t\tconst batch: T[] = [];\n\t\tfor (let j = 0; j < batchSize && i + j < il; j++) {\n\t\t\tbatch.push(array[i + j]);\n\t\t}\n\t\tbatches.push(batch);\n\t}\n\n\treturn batches;\n}\n", "import { HTTPUtils } from '../utils/index.js';\nimport { PlatformIO } from './platform-io.js';\n\n/**\n * *I/O service for Web.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { WebIO } from '@gltf-transform/core';\n *\n * const io = new WebIO({credentials: 'include'});\n *\n * // Read.\n * let document;\n * document = await io.read('model.glb');  // → Document\n * document = await io.readBinary(glb);    // Uint8Array → Document\n *\n * // Write.\n * const glb = await io.writeBinary(document); // Document → Uint8Array\n * ```\n *\n * @category I/O\n */\nexport class WebIO extends PlatformIO {\n\tprivate readonly _fetchConfig: RequestInit;\n\n\t/**\n\t * Constructs a new WebIO service. Instances are reusable.\n\t * @param fetchConfig Configuration object for Fetch API.\n\t */\n\tconstructor(fetchConfig: RequestInit = HTTPUtils.DEFAULT_INIT) {\n\t\tsuper();\n\t\tthis._fetchConfig = fetchConfig;\n\t}\n\n\tprotected async readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected async readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected async readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string> {\n\t\tconst response = await fetch(uri, this._fetchConfig);\n\t\tswitch (type) {\n\t\t\tcase 'view':\n\t\t\t\treturn new Uint8Array(await response.arrayBuffer());\n\t\t\tcase 'text':\n\t\t\t\treturn response.text();\n\t\t}\n\t}\n\n\tprotected resolve(base: string, path: string): string {\n\t\treturn HTTPUtils.resolve(base, path);\n\t}\n\n\tprotected dirname(uri: string): string {\n\t\treturn HTTPUtils.dirname(uri);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["EventDispatcher", "_listeners", "addEventListener", "type", "listener", "listeners", "undefined", "indexOf", "push", "removeEventListener", "listenerArray", "index", "splice", "dispatchEvent", "event", "array", "slice", "i", "l", "length", "call", "dispose", "key", "GraphEdge", "constructor", "_name", "_parent", "_child", "_attributes", "_disposed", "isOnGraph", "Error", "getName", "getParent", "getChild", "setChild", "child", "getAttributes", "_destroyRef", "isDisposed", "Graph", "_emptySet", "Set", "_edges", "_parentEdges", "Map", "_childEdges", "listEdges", "Array", "from", "listParentEdges", "node", "get", "listParents", "parentSet", "edge", "add", "listChildEdges", "listChildren", "childSet", "disconnectParents", "filter", "_createEdge", "name", "a", "b", "attributes", "parent", "has", "set", "_destroyEdge", "delete", "RefList", "refs", "list", "ref", "remove", "removeChild", "listRefsByChild", "values", "RefSet", "map", "getRefByChild", "RefMap", "Object", "assign", "keys", "$attributes", "Symbol", "$immutableKeys", "GraphNode", "graph", "_createAttributes", "getDefaults", "defaultAttributes", "value", "other", "forEach", "detach", "swap", "prevValue", "nextValue", "attribute", "setRef", "refAttributes", "removeRef", "addRef", "setRefMap", "getRef", "prevRef", "listRefs", "assertRefList", "listRefMapKeys", "assertRefMap", "listRefMapValues", "getRefMap", "refMap", "metadata", "target", "VERSION", "GLB_BUFFER", "PropertyType", "VertexLayout", "BufferViewUsage", "TextureChannel", "Format", "ComponentTypeToTypedArray", "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Uint32Array", "Float32Array", "BufferUtils", "createBufferFromDataURI", "dataURI", "Buffer", "byteString", "atob", "split", "ia", "length", "i", "charCodeAt", "data", "isBase64", "indexOf", "from", "encodeText", "text", "TextEncoder", "encode", "decodeText", "array", "TextDecoder", "decode", "concat", "arrays", "totalByteLength", "byteLength", "result", "byteOffset", "set", "pad", "srcArray", "paddingByte", "paddedLength", "padNumber", "dstArray", "v", "Math", "ceil", "equals", "a", "b", "toView", "Infinity", "buffer", "min", "assertView", "view", "ArrayBuffer", "isView", "Error", "ColorUtils", "hexToFactor", "hex", "target", "floor", "_target", "convertSRGBToLinear", "factorToHex", "factor", "r", "g", "convertLinearToSRGB", "source", "_source", "pow", "JPEGImageUtils", "match", "getSize", "DataView", "next", "getUint16", "validateJPEGBuffer", "getUint8", "TypeError", "getChannels", "_buffer", "PNGImageUtils", "magic", "slice", "PNG_FRIED_CHUNK_NAME", "getUint32", "ImageUtils", "registerFormat", "mimeType", "impl", "impls", "getMimeType", "getVRAMByteLength", "uncompressedBytes", "channels", "resolution", "max", "mimeTypeToExtension", "pop", "extensionToMimeType", "extension", "FileUtils", "basename", "uri", "fileName", "substring", "lastIndexOf", "startsWith", "glMatrix.ARRAY_TYPE", "getBounds", "node", "resultBounds", "createBounds", "parents", "propertyType", "NODE", "listChildren", "parent", "traverse", "mesh", "getMesh", "meshBounds", "getMeshBounds", "getWorldMatrix", "every", "isFinite", "expandBounds", "worldMatrix", "prim", "listPrimitives", "position", "getAttribute", "indices", "getIndices", "localPos", "worldPos", "il", "getCount", "index", "getScalar", "getElement", "transformMat4", "point", "NULL_DOMAIN", "HTTPUtils", "dirname", "path", "URL", "pathname", "resolve", "base", "isRelativePath", "stack", "parts", "push", "join", "isAbsoluteURL", "PROTOCOL_REGEXP", "test", "DEFAULT_INIT", "isObject", "o", "Object", "prototype", "toString", "call", "isPlainObject", "ctor", "constructor", "undefined", "prot", "hasOwn", "Verbosity", "Logger", "verbosity", "debug", "DEBUG", "console", "info", "INFO", "warn", "WARN", "error", "ERROR", "DEFAULT_INSTANCE", "MathUtils", "identity", "eq", "tolerance", "abs", "clamp", "value", "decodeNormalizedInt", "componentType", "encodeNormalizedInt", "f", "round", "decompose", "srcMat", "dstTranslation", "dstRotation", "dstScale", "sx", "sy", "sz", "det", "determinant", "_m1", "invSX", "invSY", "invSZ", "getRotation", "compose", "srcTranslation", "srcRotation", "srcScale", "dstMat", "te", "x", "y", "z", "w", "x2", "y2", "z2", "xx", "xy", "xz", "yy", "yz", "zz", "wx", "wy", "wz", "equalsRef", "refA", "refB", "getChild", "equalsRefSet", "refSetA", "refSetB", "refValuesA", "values", "refValuesB", "equalsRefMap", "refMapA", "refMapB", "keysA", "keys", "keysB", "key", "get", "equalsArray", "equalsObject", "_a", "_b", "numKeysA", "numKeysB", "valueA", "valueB", "isArray", "Array", "ALPHABET", "UNIQUE_RETRIES", "ID_LENGTH", "previousIDs", "Set", "generateOne", "rtn", "charAt", "random", "uuid", "retries", "id", "has", "add", "COPY_IDENTITY", "t", "EMPTY_SET", "Property", "GraphNode", "graph", "name", "$attributes", "init", "dispatchEvent", "type", "getGraph", "getDefaults", "assign", "extras", "attribute", "getName", "setName", "getExtras", "setExtras", "clone", "PropertyClass", "copy", "other", "GraphEdge", "$immutableKeys", "dispose", "RefList", "RefSet", "ref", "RefMap", "thisValue", "otherValue", "setRef", "getAttributes", "addRef", "subkey", "setRefMap", "JSON", "parse", "stringify", "skip", "detach", "disconnectParents", "n", "listParents", "ExtensibleProperty", "extensions", "getExtension", "getRefMap", "setExtension", "extensionProperty", "_validateParent", "listExtensions", "listRefMapValues", "Accessor", "ACCESSOR", "Type", "SCALAR", "ComponentType", "FLOAT", "normalized", "sparse", "getElementSize", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "getComponentSize", "BYTE", "UNSIGNED_BYTE", "SHORT", "UNSIGNED_SHORT", "UNSIGNED_INT", "getMinNormalized", "getNormalized", "elementSize", "getComponentType", "getMin", "j", "getArray", "count", "Number", "getMaxNormalized", "getMax", "getType", "setType", "BYTES_PER_ELEMENT", "setNormalized", "setScalar", "setElement", "getSparse", "setSparse", "getBuffer", "getRef", "setBuffer", "setArray", "arrayToComponentType", "getByteLength", "Animation", "ANIMATION", "samplers", "addChannel", "channel", "removeChannel", "removeRef", "listChannels", "listRefs", "addSampler", "sampler", "removeSampler", "listSamplers", "AnimationChannel", "ANIMATION_CHANNEL", "targetPath", "targetNode", "getTargetPath", "setTargetPath", "getTargetNode", "setTargetNode", "getSampler", "setSampler", "TargetPath", "TRANSLATION", "ROTATION", "SCALE", "WEIGHTS", "AnimationSampler", "ANIMATION_SAMPLER", "getDefaultAttributes", "interpolation", "Interpolation", "LINEAR", "input", "output", "getInterpolation", "setInterpolation", "getInput", "setInput", "usage", "OTHER", "getOutput", "setOutput", "STEP", "CUBICSPLINE", "BUFFER", "getURI", "setURI", "Camera", "CAMERA", "PERSPECTIVE", "znear", "zfar", "aspectRatio", "yfov", "PI", "xmag", "ymag", "getZNear", "setZNear", "getZFar", "setZFar", "getAspectRatio", "setAspectRatio", "getYFov", "setYFov", "getXMag", "setXMag", "getYMag", "setYMag", "ORTHOGRAPHIC", "ExtensionProperty", "parentTypes", "includes", "EXTENSION_NAME", "TextureInfo", "TEXTURE_INFO", "texCoord", "magFilter", "minFilter", "wrapS", "WrapMode", "REPEAT", "wrapT", "getTexCoord", "setTexCoord", "getMagFilter", "setMagFilter", "getMinFilter", "setMinFilter", "getWrapS", "setWrapS", "getWrapT", "setWrapT", "CLAMP_TO_EDGE", "MIRRORED_REPEAT", "MagFilter", "NEAREST", "MinFilter", "NEAREST_MIPMAP_NEAREST", "LINEAR_MIPMAP_NEAREST", "NEAREST_MIPMAP_LINEAR", "LINEAR_MIPMAP_LINEAR", "R", "G", "B", "A", "Material", "MATERIAL", "alphaMode", "AlphaMode", "OPAQUE", "alphaCutoff", "doubleSided", "baseColorFactor", "baseColorTexture", "baseColorTextureInfo", "emissiveFactor", "emissiveTexture", "emissiveTextureInfo", "normalScale", "normalTexture", "normalTextureInfo", "occlusionStrength", "occlusionTexture", "occlusionTextureInfo", "roughnessFactor", "metallicFactor", "metallicRoughnessTexture", "metallicRoughnessTextureInfo", "getDoubleSided", "setDoubleSided", "getAlpha", "setAlpha", "alpha", "getAlphaMode", "setAlphaMode", "getAlphaCutoff", "setAlphaCutoff", "getBaseColorFactor", "setBaseColorFactor", "getBaseColorTexture", "getBaseColorTextureInfo", "setBaseColorTexture", "texture", "isColor", "getEmissiveFactor", "setEmissiveFactor", "getEmissiveTexture", "getEmissiveTextureInfo", "setEmissiveTexture", "getNormalScale", "setNormalScale", "scale", "getNormalTexture", "getNormalTextureInfo", "setNormalTexture", "getOcclusionStrength", "setOcclusionStrength", "strength", "getOcclusionTexture", "getOcclusionTextureInfo", "setOcclusionTexture", "getRoughnessFactor", "setRoughnessFactor", "getMetallicFactor", "setMetallicFactor", "getMetallicRoughnessTexture", "getMetallicRoughnessTextureInfo", "setMetallicRoughnessTexture", "MASK", "BLEND", "Mesh", "MESH", "weights", "primitives", "addPrimitive", "primitive", "removePrimitive", "getWeights", "setWeights", "Node", "translation", "rotation", "camera", "skin", "children", "getTranslation", "getScale", "setTranslation", "setRotation", "setScale", "getMatrix", "setMatrix", "matrix", "getWorldTranslation", "getWorldRotation", "getWorldScale", "s", "ancestors", "getParentNode", "ancestor", "multiply", "addChild", "child", "parentNode", "removeChild", "SCENE", "setMesh", "getCamera", "setCamera", "getSkin", "setSkin", "fn", "Primitive", "PRIMITIVE", "mode", "Mode", "TRIANGLES", "material", "attributes", "targets", "setIndices", "ELEMENT_ARRAY_BUFFER", "semantic", "setAttribute", "accessor", "ARRAY_BUFFER", "listAttributes", "listSemantics", "listRefMapKeys", "getMaterial", "setMaterial", "getMode", "setMode", "listTargets", "addTarget", "removeTarget", "POINTS", "LINES", "LINE_LOOP", "LINE_STRIP", "TRIANGLE_STRIP", "TRIANGLE_FAN", "PrimitiveTarget", "PRIMITIVE_TARGET", "Scene", "Skin", "SKIN", "skeleton", "inverseBindMatrices", "joints", "getSkeleton", "setSkeleton", "getInverseBindMatrices", "setInverseBindMatrices", "INVERSE_BIND_MATRICES", "addJoint", "joint", "removeJoint", "listJoints", "Texture", "TEXTURE", "image", "setMimeType", "getImage", "setImage", "Root", "ROOT", "asset", "generator", "version", "defaultScene", "accessors", "animations", "buffers", "cameras", "materials", "meshes", "nodes", "scenes", "skins", "textures", "_extensions", "addEventListener", "event", "_addChildOfRoot", "_extends", "setDefaultScene", "getDefaultScene", "extensionName", "otherExtension", "getAsset", "listExtensionsUsed", "listExtensionsRequired", "filter", "isRequired", "_enableExtension", "_disableExtension", "delete", "listScenes", "listNodes", "listCameras", "listSkins", "listMeshes", "listMaterials", "listTextures", "listAnimations", "listAccessors", "listBuffers", "Document", "fromGraph", "_GRAPH_DOCUMENTS", "_graph", "Graph", "_root", "_logger", "getRoot", "getLogger", "setLogger", "logger", "merge", "_other", "transform", "transforms", "map", "createExtension", "prevExtension", "find", "ext", "createScene", "createNode", "createCamera", "createSkin", "createMesh", "createPrimitive", "createPrimitiveTarget", "createMaterial", "createTexture", "createAnimation", "createAnimationChannel", "createAnimationSampler", "createAccessor", "createBuffer", "WeakMap", "Extension", "document", "prereadTypes", "prewriteTypes", "readDependencies", "writeDependencies", "required", "properties", "_listener", "_event", "_addExtensionProperty", "_removeExtensionProperty", "removeEventListener", "property", "register", "setRequired", "listProperties", "install", "_key", "_dependency", "preread", "_readerContext", "_propertyType", "prewrite", "_writerContext", "ReaderContext", "jsonDoc", "bufferViews", "bufferViewBuffers", "textureInfos", "Map", "setTextureInfo", "textureInfo", "textureInfoDef", "textureDef", "json", "samplerDef", "DEFAULT_OPTIONS", "dependencies", "SUPPORTED_PREREAD_TYPES", "GLTFReader", "read", "_options", "options", "validate", "context", "assetDef", "copyright", "extensionsUsed", "extensionsRequired", "sort", "unsupportedHooks", "bufferDefs", "forEach", "bufferDef", "bufferViewDefs", "bufferViewDef", "resource", "resources", "accessorDefs", "accessorDef", "bufferView", "getAccessorArray", "imageDefs", "images", "textureDefs", "imageDef", "bufferData", "imageData", "materialDefs", "materialDef", "pbrDef", "pbrMetallicRoughness", "meshDefs", "meshDef", "primitiveDefs", "primitiveDef", "entries", "targetNames", "targetDefs", "targetDef", "targetIndex", "targetName", "accessorIndex", "cameraDefs", "cameraDef", "perspectiveDef", "perspective", "orthoDef", "orthographic", "nodeDefs", "nodeDef", "skinDefs", "skinDef", "nodeIndex", "childIndex", "animationDefs", "animationDef", "animation", "samplerDefs", "channelDef", "sceneDefs", "sceneDef", "scene", "hasSparseValues", "isZeroFilled", "getSparseArray", "getInterleavedArray", "TypedArray", "componentSize", "accessorByteOffset", "byteStride", "getFloat32", "getInt16", "getInt8", "elementStride", "sparseDef", "indicesDef", "valuesDef", "BufferViewTarget", "WriterContext", "_doc", "accessorIndexMap", "animationIndexMap", "bufferIndexMap", "cameraIndexMap", "skinIndexMap", "materialIndexMap", "meshIndexMap", "nodeIndexMap", "imageIndexMap", "textureDefIndexMap", "textureInfoDefMap", "samplerDefIndexMap", "sceneIndexMap", "imageBufferViews", "otherBufferViews", "otherBufferViewsIndexMap", "extensionData", "bufferURIGenerator", "imageURIGenerator", "_accessorUsageMap", "accessorUsageGroupedByParent", "accessorParents", "root", "numBuffers", "numImages", "UniqueURIGenerator", "getSlot", "createTextureInfoDef", "samplerKey", "textureKey", "createPropertyDef", "def", "createAccessorDef", "needsBounds", "listParentEdges", "some", "edge", "fround", "createImageData", "format", "GLB", "createURI", "assignResourceURI", "throwOnConflict", "conflictMessage", "getAccessorUsage", "cachedUsage", "SPARSE", "getParent", "addAccessorToUsageGroup", "prevUsage", "USAGE_TO_TARGET", "multiple", "counter", "object", "replace", "SUPPORTED_PREWRITE_TYPES", "GLTFWriter", "write", "doc", "extensionsRegistered", "concatAccessors", "bufferIndex", "bufferByteOffset", "bufferViewTarget", "accessorArray", "bufferViewData", "interleaveAccessors", "vertexCount", "vertexByteOffset", "viewByteOffset", "setFloat32", "setInt8", "setInt16", "setUint8", "setUint16", "setUint32", "concatSparseAccessors", "sparseData", "maxIndex", "needSparseWarning", "el", "fill", "ValueArray", "IndexArray", "IndexComponentType", "indicesBufferViewDef", "indicesByteOffset", "indicesBufferViewIndex", "valuesBufferViewDef", "valuesByteOffset", "valuesBufferViewIndex", "textureIndex", "groupByParent", "needsBuffer", "size", "uniqueParents", "parentToIndex", "accessorGroups", "bufferByteLength", "groupAccessors", "vertexLayout", "INTERLEAVED", "imagePadding", "samplerIndexMap", "samplerIndex", "clean", "unused", "ChunkType", "PlatformIO", "_dependencies", "_vertexLayout", "lastReadBytes", "lastWriteBytes", "registerExtensions", "registerDependencies", "setVertexLayout", "layout", "readJSON", "readAsJSON", "readURI", "isGLB", "_binaryToJSON", "_readResourcesExternal", "_readResourcesInternal", "_copyJSON", "binaryToJSON", "glb", "isExternalBuffer", "isExternalImage", "readBinary", "writeJSON", "GLTF", "writeBinary", "header", "jsonText", "jsonChunkData", "jsonChunkHeader", "jsonChunk", "binBuffer", "binChunkData", "binChunkHeader", "binChunk", "_this", "pendingResources", "Promise", "all", "resolveResource", "resourceUUID", "jsonByteOffset", "jsonByteLength", "binByteOffset", "BIN", "binByteLength", "jsonDocument", "DenoIO", "_path", "Deno", "readFile", "readTextFile", "decodeURIComponent", "NodeIO", "_fetch", "_fetchConfig", "_init", "_fetchEnabled", "then", "fs", "_fs", "promises", "setAllowNetwork", "allow", "response", "arrayBuffer", "_writeGLB", "_writeGLTF", "dir", "jsonContent", "writeFile", "batch", "listBatches", "resourceURI", "resourcePath", "mkdir", "recursive", "batchSize", "batches", "WebIO", "fetchConfig", "fetch"]
}
