{
  "version": 3,
  "sources": ["../../iota-array/iota.js", "../../is-buffer/index.js", "../../ndarray/ndarray.js", "../../uniq/uniq.js", "../../cwise-compiler/lib/compile.js", "../../cwise-compiler/lib/thunk.js", "../../cwise-compiler/compiler.js", "../../ndarray-ops/ndarray-ops.js", "../../ndarray-pixels/src/browser-get-pixels.ts", "../../ndarray-pixels/src/common.ts", "../../ndarray-pixels/src/browser-save-pixels.ts", "../../ndarray-pixels/src/index.ts", "../../ndarray-lanczos/vendor/filters.ts", "../../ndarray-lanczos/src/convolve.ts", "../../ndarray-lanczos/src/index.ts", "../../@gltf-transform/functions/src/utils.ts", "../../@gltf-transform/functions/src/center.ts", "../../@gltf-transform/functions/src/list-node-scenes.ts", "../../@gltf-transform/functions/src/clear-node-parent.ts", "../../node_modules/gl-matrix/esm/common.js", "../../node_modules/gl-matrix/esm/mat4.js", "../../@gltf-transform/functions/src/get-vertex-count.ts", "../../@gltf-transform/functions/src/hash-table.ts", "../../@gltf-transform/functions/src/compact-primitive.ts", "../../node_modules/gl-matrix/esm/mat3.js", "../../node_modules/gl-matrix/esm/vec3.js", "../../@gltf-transform/functions/src/weld.ts", "../../@gltf-transform/functions/src/transform-primitive.ts", "../../@gltf-transform/functions/src/transform-mesh.ts", "../../@gltf-transform/functions/src/clear-node-transform.ts", "../../@gltf-transform/functions/src/convert-primitive-mode.ts", "../../@gltf-transform/functions/src/dedup.ts", "../../@gltf-transform/functions/src/dequantize.ts", "../../@gltf-transform/functions/src/document-utils.ts", "../../@gltf-transform/functions/src/draco.ts", "../../node_modules/gl-matrix/esm/vec4.js", "../../@gltf-transform/functions/src/get-texture-color-space.ts", "../../@gltf-transform/functions/src/list-texture-info.ts", "../../@gltf-transform/functions/src/list-texture-slots.ts", "../../@gltf-transform/functions/src/prune.ts", "../../@gltf-transform/functions/src/flatten.ts", "../../@gltf-transform/functions/src/get-bounds.ts", "../../@gltf-transform/functions/src/inspect.ts", "../../@gltf-transform/functions/src/instance.ts", "../../@gltf-transform/functions/src/join-primitives.ts", "../../@gltf-transform/functions/src/join.ts", "../../@gltf-transform/functions/src/list-texture-channels.ts", "../../@gltf-transform/functions/src/sort-primitive-weights.ts", "../../@gltf-transform/functions/src/quantize.ts", "../../@gltf-transform/functions/src/reorder.ts", "../../@gltf-transform/functions/src/meshopt.ts", "../../@gltf-transform/functions/src/metal-rough.ts", "../../@gltf-transform/functions/src/unweld.ts", "../../@gltf-transform/functions/src/normals.ts", "../../@gltf-transform/functions/src/palette.ts", "../../@gltf-transform/functions/src/partition.ts", "../../node_modules/keyframe-resample/dist/keyframe-resample-browser.modern.js", "../../@gltf-transform/functions/src/resample.ts", "../../@gltf-transform/functions/src/sequence.ts", "../../@gltf-transform/functions/src/simplify.ts", "../../@gltf-transform/functions/src/sparse.ts", "../../@gltf-transform/functions/src/tangents.ts", "../../@gltf-transform/functions/src/texture-compress.ts", "../../@gltf-transform/functions/src/uninstance.ts", "../../@gltf-transform/functions/src/unlit.ts", "../../@gltf-transform/functions/src/unpartition.ts", "../../@gltf-transform/functions/src/unwrap.ts", "../../@gltf-transform/functions/src/vertex-color-space.ts"],
  "sourcesContent": ["\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota", "/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n", "var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n", "\"use strict\"\n\nfunction unique_pred(list, compare) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b=list[0]\n  for(var i=1; i<len; ++i) {\n    b = a\n    a = list[i]\n    if(compare(a, b)) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique_eq(list) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b = list[0]\n  for(var i=1; i<len; ++i, b=a) {\n    b = a\n    a = list[i]\n    if(a !== b) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique(list, compare, sorted) {\n  if(list.length === 0) {\n    return list\n  }\n  if(compare) {\n    if(!sorted) {\n      list.sort(compare)\n    }\n    return unique_pred(list, compare)\n  }\n  if(!sorted) {\n    list.sort()\n  }\n  return unique_eq(list)\n}\n\nmodule.exports = unique\n", "\"use strict\"\n\nvar uniq = require(\"uniq\")\n\n// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)\n// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of \"pointers\" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.\nfunction innerFill(order, proc, body) {\n  var dimension = order.length\n    , nargs = proc.arrayArgs.length\n    , has_index = proc.indexArgs.length>0\n    , code = []\n    , vars = []\n    , idx=0, pidx=0, i, j\n  for(i=0; i<dimension; ++i) { // Iteration variables\n    vars.push([\"i\",i,\"=0\"].join(\"\"))\n  }\n  //Compute scan deltas\n  for(j=0; j<nargs; ++j) {\n    for(i=0; i<dimension; ++i) {\n      pidx = idx\n      idx = order[i]\n      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride\n        vars.push([\"d\",j,\"s\",i,\"=t\",j,\"p\",idx].join(\"\"))\n      } else { // For other dimensions the delta is basically the stride minus something which essentially \"rewinds\" the previous (more inner) dimension\n        vars.push([\"d\",j,\"s\",i,\"=(t\",j,\"p\",idx,\"-s\",pidx,\"*t\",j,\"p\",pidx,\")\"].join(\"\"))\n      }\n    }\n  }\n  if (vars.length > 0) {\n    code.push(\"var \" + vars.join(\",\"))\n  }  \n  //Scan loop\n  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards\n    idx = order[i]\n    code.push([\"for(i\",i,\"=0;i\",i,\"<s\",idx,\";++i\",i,\"){\"].join(\"\"))\n  }\n  //Push body of inner loop\n  code.push(body)\n  //Advance scan pointers\n  for(i=0; i<dimension; ++i) {\n    pidx = idx\n    idx = order[i]\n    for(j=0; j<nargs; ++j) {\n      code.push([\"p\",j,\"+=d\",j,\"s\",i].join(\"\"))\n    }\n    if(has_index) {\n      if(i > 0) {\n        code.push([\"index[\",pidx,\"]-=s\",pidx].join(\"\"))\n      }\n      code.push([\"++index[\",idx,\"]\"].join(\"\"))\n    }\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\n// Generate \"outer\" loops that loop over blocks of data, applying \"inner\" loops to the blocks by manipulating the local variables in such a way that the inner loop only \"sees\" the current block.\n// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.\n//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and \"shape\" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.\nfunction outerFill(matched, order, proc, body) {\n  var dimension = order.length\n    , nargs = proc.arrayArgs.length\n    , blockSize = proc.blockSize\n    , has_index = proc.indexArgs.length > 0\n    , code = []\n  for(var i=0; i<nargs; ++i) {\n    code.push([\"var offset\",i,\"=p\",i].join(\"\"))\n  }\n  //Generate loops for unmatched dimensions\n  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)\n  // TODO: It would be nice if the order in which these loops are placed would also be somehow \"optimal\" (at the very least we should check that it really doesn't hurt us if they're not).\n  for(var i=matched; i<dimension; ++i) {\n    code.push([\"for(var j\"+i+\"=SS[\", order[i], \"]|0;j\", i, \">0;){\"].join(\"\")) // Iterate back to front\n    code.push([\"if(j\",i,\"<\",blockSize,\"){\"].join(\"\")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).\n    code.push([\"s\",order[i],\"=j\",i].join(\"\"))\n    code.push([\"j\",i,\"=0\"].join(\"\"))\n    code.push([\"}else{s\",order[i],\"=\",blockSize].join(\"\"))\n    code.push([\"j\",i,\"-=\",blockSize,\"}\"].join(\"\"))\n    if(has_index) {\n      code.push([\"index[\",order[i],\"]=j\",i].join(\"\"))\n    }\n  }\n  for(var i=0; i<nargs; ++i) {\n    var indexStr = [\"offset\"+i]\n    for(var j=matched; j<dimension; ++j) {\n      indexStr.push([\"j\",j,\"*t\",i,\"p\",order[j]].join(\"\"))\n    }\n    code.push([\"p\",i,\"=(\",indexStr.join(\"+\"),\")\"].join(\"\"))\n  }\n  code.push(innerFill(order, proc, body))\n  for(var i=matched; i<dimension; ++i) {\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\n//Count the number of compatible inner orders\n// This is the length of the longest common prefix of the arrays in orders.\n// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.\n// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.\nfunction countMatches(orders) {\n  var matched = 0, dimension = orders[0].length\n  while(matched < dimension) {\n    for(var j=1; j<orders.length; ++j) {\n      if(orders[j][matched] !== orders[0][matched]) {\n        return matched\n      }\n    }\n    ++matched\n  }\n  return matched\n}\n\n//Processes a block according to the given data types\n// Replaces variable names by different ones, either \"local\" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.\nfunction processBlock(block, proc, dtypes) {\n  var code = block.body\n  var pre = []\n  var post = []\n  for(var i=0; i<block.args.length; ++i) {\n    var carg = block.args[i]\n    if(carg.count <= 0) {\n      continue\n    }\n    var re = new RegExp(carg.name, \"g\")\n    var ptrStr = \"\"\n    var arrNum = proc.arrayArgs.indexOf(i)\n    switch(proc.argTypes[i]) {\n      case \"offset\":\n        var offArgIndex = proc.offsetArgIndex.indexOf(i)\n        var offArg = proc.offsetArgs[offArgIndex]\n        arrNum = offArg.array\n        ptrStr = \"+q\" + offArgIndex // Adds offset to the \"pointer\" in the array\n      case \"array\":\n        ptrStr = \"p\" + arrNum + ptrStr\n        var localStr = \"l\" + i\n        var arrStr = \"a\" + arrNum\n        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array\n          if(carg.count === 1) { // Argument/array used only once(?)\n            if(dtypes[arrNum] === \"generic\") {\n              if(carg.lvalue) {\n                pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n                code = code.replace(re, localStr)\n                post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n              } else {\n                code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n              }\n            } else {\n              code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n            }\n          } else if(dtypes[arrNum] === \"generic\") {\n            pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n            code = code.replace(re, localStr)\n            if(carg.lvalue) {\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            }\n          } else {\n            pre.push([\"var \", localStr, \"=\", arrStr, \"[\", ptrStr, \"]\"].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n            code = code.replace(re, localStr)\n            if(carg.lvalue) {\n              post.push([arrStr, \"[\", ptrStr, \"]=\", localStr].join(\"\"))\n            }\n          }\n        } else { // Argument to body is a \"block\"\n          var reStrArr = [carg.name], ptrStrArr = [ptrStr]\n          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {\n            reStrArr.push(\"\\\\s*\\\\[([^\\\\]]+)\\\\]\")\n            ptrStrArr.push(\"$\" + (j+1) + \"*t\" + arrNum + \"b\" + j) // Matched index times stride\n          }\n          re = new RegExp(reStrArr.join(\"\"), \"g\")\n          ptrStr = ptrStrArr.join(\"+\")\n          if(dtypes[arrNum] === \"generic\") {\n            /*if(carg.lvalue) {\n              pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n              code = code.replace(re, localStr)\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            } else {\n              code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n            }*/\n            throw new Error(\"cwise: Generic arrays not supported in combination with blocks!\")\n          } else {\n            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.\n            code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n          }\n        }\n      break\n      case \"scalar\":\n        code = code.replace(re, \"Y\" + proc.scalarArgs.indexOf(i))\n      break\n      case \"index\":\n        code = code.replace(re, \"index\")\n      break\n      case \"shape\":\n        code = code.replace(re, \"shape\")\n      break\n    }\n  }\n  return [pre.join(\"\\n\"), code, post.join(\"\\n\")].join(\"\\n\").trim()\n}\n\nfunction typeSummary(dtypes) {\n  var summary = new Array(dtypes.length)\n  var allEqual = true\n  for(var i=0; i<dtypes.length; ++i) {\n    var t = dtypes[i]\n    var digits = t.match(/\\d+/)\n    if(!digits) {\n      digits = \"\"\n    } else {\n      digits = digits[0]\n    }\n    if(t.charAt(0) === 0) {\n      summary[i] = \"u\" + t.charAt(1) + digits\n    } else {\n      summary[i] = t.charAt(0) + digits\n    }\n    if(i > 0) {\n      allEqual = allEqual && summary[i] === summary[i-1]\n    }\n  }\n  if(allEqual) {\n    return summary[0]\n  }\n  return summary.join(\"\")\n}\n\n//Generates a cwise operator\nfunction generateCWiseOp(proc, typesig) {\n\n  //Compute dimension\n  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.\n  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0\n  var orders = new Array(proc.arrayArgs.length)\n  var dtypes = new Array(proc.arrayArgs.length)\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    dtypes[i] = typesig[2*i]\n    orders[i] = typesig[2*i+1]\n  }\n  \n  //Determine where block and loop indices start and end\n  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks\n  var loopBegin = [], loopEnd = [] // These indices are iterated over\n  var loopOrders = [] // orders restricted to the loop indices\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    if (proc.arrayBlockIndices[i]<0) {\n      loopBegin.push(0)\n      loopEnd.push(dimension)\n      blockBegin.push(dimension)\n      blockEnd.push(dimension+proc.arrayBlockIndices[i])\n    } else {\n      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative\n      loopEnd.push(proc.arrayBlockIndices[i]+dimension)\n      blockBegin.push(0)\n      blockEnd.push(proc.arrayBlockIndices[i])\n    }\n    var newOrder = []\n    for(var j=0; j<orders[i].length; j++) {\n      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {\n        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.\n      }\n    }\n    loopOrders.push(newOrder)\n  }\n\n  //First create arguments for procedure\n  var arglist = [\"SS\"] // SS is the overall shape over which we iterate\n  var code = [\"'use strict'\"]\n  var vars = []\n  \n  for(var j=0; j<dimension; ++j) {\n    vars.push([\"s\", j, \"=SS[\", j, \"]\"].join(\"\")) // The limits for each dimension.\n  }\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    arglist.push(\"a\"+i) // Actual data array\n    arglist.push(\"t\"+i) // Strides\n    arglist.push(\"p\"+i) // Offset in the array at which the data starts (also used for iterating over the data)\n    \n    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping\n      vars.push([\"t\",i,\"p\",j,\"=t\",i,\"[\",loopBegin[i]+j,\"]\"].join(\"\"))\n    }\n    \n    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration\n      vars.push([\"t\",i,\"b\",j,\"=t\",i,\"[\",blockBegin[i]+j,\"]\"].join(\"\"))\n    }\n  }\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    arglist.push(\"Y\" + i)\n  }\n  if(proc.shapeArgs.length > 0) {\n    vars.push(\"shape=SS.slice(0)\") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)\n  }\n  if(proc.indexArgs.length > 0) {\n    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.\n    var zeros = new Array(dimension)\n    for(var i=0; i<dimension; ++i) {\n      zeros[i] = \"0\"\n    }\n    vars.push([\"index=[\", zeros.join(\",\"), \"]\"].join(\"\"))\n  }\n  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations\n    var off_arg = proc.offsetArgs[i]\n    var init_string = []\n    for(var j=0; j<off_arg.offset.length; ++j) {\n      if(off_arg.offset[j] === 0) {\n        continue\n      } else if(off_arg.offset[j] === 1) {\n        init_string.push([\"t\", off_arg.array, \"p\", j].join(\"\"))      \n      } else {\n        init_string.push([off_arg.offset[j], \"*t\", off_arg.array, \"p\", j].join(\"\"))\n      }\n    }\n    if(init_string.length === 0) {\n      vars.push(\"q\" + i + \"=0\")\n    } else {\n      vars.push([\"q\", i, \"=\", init_string.join(\"+\")].join(\"\"))\n    }\n  }\n\n  //Prepare this variables\n  var thisVars = uniq([].concat(proc.pre.thisVars)\n                      .concat(proc.body.thisVars)\n                      .concat(proc.post.thisVars))\n  vars = vars.concat(thisVars)\n  if (vars.length > 0) {\n    code.push(\"var \" + vars.join(\",\"))\n  }\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    code.push(\"p\"+i+\"|=0\")\n  }\n  \n  //Inline prelude\n  if(proc.pre.body.length > 3) {\n    code.push(processBlock(proc.pre, proc, dtypes))\n  }\n\n  //Process body\n  var body = processBlock(proc.body, proc, dtypes)\n  var matched = countMatches(loopOrders)\n  if(matched < dimension) {\n    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.\n  } else {\n    code.push(innerFill(loopOrders[0], proc, body))\n  }\n\n  //Inline epilog\n  if(proc.post.body.length > 3) {\n    code.push(processBlock(proc.post, proc, dtypes))\n  }\n  \n  if(proc.debug) {\n    console.log(\"-----Generated cwise routine for \", typesig, \":\\n\" + code.join(\"\\n\") + \"\\n----------\")\n  }\n  \n  var loopName = [(proc.funcName||\"unnamed\"), \"_cwise_loop_\", orders[0].join(\"s\"),\"m\",matched,typeSummary(dtypes)].join(\"\")\n  var f = new Function([\"function \",loopName,\"(\", arglist.join(\",\"),\"){\", code.join(\"\\n\"),\"} return \", loopName].join(\"\"))\n  return f()\n}\nmodule.exports = generateCWiseOp\n", "\"use strict\"\n\n// The function below is called when constructing a cwise function object, and does the following:\n// A function object is constructed which accepts as argument a compilation function and returns another function.\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\n// The compilation passed to the first function object is used for compiling new functions.\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\n// So createThunk roughly works like this:\n// function createThunk(proc) {\n//   var thunk = function(compileBound) {\n//     var CACHED = {}\n//     return function(arrays and scalars) {\n//       if (dtype and order of arrays in CACHED) {\n//         var func = CACHED[dtype and order of arrays]\n//       } else {\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\n//       }\n//       return func(arrays and scalars)\n//     }\n//   }\n//   return thunk(compile.bind1(proc))\n// }\n\nvar compile = require(\"./compile.js\")\n\nfunction createThunk(proc) {\n  var code = [\"'use strict'\", \"var CACHED={}\"]\n  var vars = []\n  var thunkName = proc.funcName + \"_cwise_thunk\"\n  \n  //Build thunk\n  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"))\n  var typesig = []\n  var string_typesig = []\n  var proc_args = [[\"array\",proc.arrayArgs[0],\".shape.slice(\", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).\n                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(\",\"+proc.arrayBlockIndices[0]+\")\"):\")\"].join(\"\")]\n  var shapeLengthConditions = [], shapeConditions = []\n  // Process array arguments\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    var j = proc.arrayArgs[i]\n    vars.push([\"t\", j, \"=array\", j, \".dtype,\",\n               \"r\", j, \"=array\", j, \".order\"].join(\"\"))\n    typesig.push(\"t\" + j)\n    typesig.push(\"r\" + j)\n    string_typesig.push(\"t\"+j)\n    string_typesig.push(\"r\"+j+\".join()\")\n    proc_args.push(\"array\" + j + \".data\")\n    proc_args.push(\"array\" + j + \".stride\")\n    proc_args.push(\"array\" + j + \".offset|0\")\n    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)\n      shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))\n      shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[i]) + \"]\")\n    }\n  }\n  // Check for shape equality\n  if (proc.arrayArgs.length > 1) {\n    code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\")\n    code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\")\n    code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\")\n    code.push(\"}\")\n  }\n  // Process scalar arguments\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    proc_args.push(\"scalar\" + proc.scalarArgs[i])\n  }\n  // Check for cached function (and if not present, generate it)\n  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"))\n  vars.push(\"proc=CACHED[type]\")\n  code.push(\"var \" + vars.join(\",\"))\n  \n  code.push([\"if(!proc){\",\n             \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\",\n             \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"))\n\n  if(proc.debug) {\n    console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\")\n  }\n  \n  //Compile thunk\n  var thunk = new Function(\"compile\", code.join(\"\\n\"))\n  return thunk(compile.bind(undefined, proc))\n}\n\nmodule.exports = createThunk\n", "\"use strict\"\n\nvar createThunk = require(\"./lib/thunk.js\")\n\nfunction Procedure() {\n  this.argTypes = []\n  this.shimArgs = []\n  this.arrayArgs = []\n  this.arrayBlockIndices = []\n  this.scalarArgs = []\n  this.offsetArgs = []\n  this.offsetArgIndex = []\n  this.indexArgs = []\n  this.shapeArgs = []\n  this.funcName = \"\"\n  this.pre = null\n  this.body = null\n  this.post = null\n  this.debug = false\n}\n\nfunction compileCwise(user_args) {\n  //Create procedure\n  var proc = new Procedure()\n  \n  //Parse blocks\n  proc.pre    = user_args.pre\n  proc.body   = user_args.body\n  proc.post   = user_args.post\n\n  //Parse arguments\n  var proc_args = user_args.args.slice(0)\n  proc.argTypes = proc_args\n  for(var i=0; i<proc_args.length; ++i) {\n    var arg_type = proc_args[i]\n    if(arg_type === \"array\" || (typeof arg_type === \"object\" && arg_type.blockIndices)) {\n      proc.argTypes[i] = \"array\"\n      proc.arrayArgs.push(i)\n      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)\n      proc.shimArgs.push(\"array\" + i)\n      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {\n        throw new Error(\"cwise: pre() block may not reference array args\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].count>0) {\n        throw new Error(\"cwise: post() block may not reference array args\")\n      }\n    } else if(arg_type === \"scalar\") {\n      proc.scalarArgs.push(i)\n      proc.shimArgs.push(\"scalar\" + i)\n    } else if(arg_type === \"index\") {\n      proc.indexArgs.push(i)\n      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {\n        throw new Error(\"cwise: pre() block may not reference array index\")\n      }\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n        throw new Error(\"cwise: body() block may not write to array index\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].count > 0) {\n        throw new Error(\"cwise: post() block may not reference array index\")\n      }\n    } else if(arg_type === \"shape\") {\n      proc.shapeArgs.push(i)\n      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {\n        throw new Error(\"cwise: pre() block may not write to array shape\")\n      }\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n        throw new Error(\"cwise: body() block may not write to array shape\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].lvalue) {\n        throw new Error(\"cwise: post() block may not write to array shape\")\n      }\n    } else if(typeof arg_type === \"object\" && arg_type.offset) {\n      proc.argTypes[i] = \"offset\"\n      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })\n      proc.offsetArgIndex.push(i)\n    } else {\n      throw new Error(\"cwise: Unknown argument type \" + proc_args[i])\n    }\n  }\n  \n  //Make sure at least one array argument was specified\n  if(proc.arrayArgs.length <= 0) {\n    throw new Error(\"cwise: No array arguments specified\")\n  }\n  \n  //Make sure arguments are correct\n  if(proc.pre.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in pre() block\")\n  }\n  if(proc.body.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in body() block\")\n  }\n  if(proc.post.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in post() block\")\n  }\n\n  //Check debug flag\n  proc.debug = !!user_args.printCode || !!user_args.debug\n  \n  //Retrieve name\n  proc.funcName = user_args.funcName || \"cwise\"\n  \n  //Read in block size\n  proc.blockSize = user_args.blockSize || 64\n\n  return createThunk(proc)\n}\n\nmodule.exports = compileCwise\n", "\"use strict\"\n\nvar compile = require(\"cwise-compiler\")\n\nvar EmptyProc = {\n  body: \"\",\n  args: [],\n  thisVars: [],\n  localVars: []\n}\n\nfunction fixup(x) {\n  if(!x) {\n    return EmptyProc\n  }\n  for(var i=0; i<x.args.length; ++i) {\n    var a = x.args[i]\n    if(i === 0) {\n      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }\n    } else {\n      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}\n    }\n  }\n  if(!x.thisVars) {\n    x.thisVars = []\n  }\n  if(!x.localVars) {\n    x.localVars = []\n  }\n  return x\n}\n\nfunction pcompile(user_args) {\n  return compile({\n    args:     user_args.args,\n    pre:      fixup(user_args.pre),\n    body:     fixup(user_args.body),\n    post:     fixup(user_args.proc),\n    funcName: user_args.funcName\n  })\n}\n\nfunction makeOp(user_args) {\n  var args = []\n  for(var i=0; i<user_args.args.length; ++i) {\n    args.push(\"a\"+i)\n  }\n  var wrapper = new Function(\"P\", [\n    \"return function \", user_args.funcName, \"_ndarrayops(\", args.join(\",\"), \") {P(\", args.join(\",\"), \");return a0}\"\n  ].join(\"\"))\n  return wrapper(pcompile(user_args))\n}\n\nvar assign_ops = {\n  add:  \"+\",\n  sub:  \"-\",\n  mul:  \"*\",\n  div:  \"/\",\n  mod:  \"%\",\n  band: \"&\",\n  bor:  \"|\",\n  bxor: \"^\",\n  lshift: \"<<\",\n  rshift: \">>\",\n  rrshift: \">>>\"\n}\n;(function(){\n  for(var id in assign_ops) {\n    var op = assign_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\",\"array\",\"array\"],\n      body: {args:[\"a\",\"b\",\"c\"],\n             body: \"a=b\"+op+\"c\"},\n      funcName: id\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\",\"array\"],\n      body: {args:[\"a\",\"b\"],\n             body:\"a\"+op+\"=b\"},\n      rvalue: true,\n      funcName: id+\"eq\"\n    })\n    exports[id+\"s\"] = makeOp({\n      args: [\"array\", \"array\", \"scalar\"],\n      body: {args:[\"a\",\"b\",\"s\"],\n             body:\"a=b\"+op+\"s\"},\n      funcName: id+\"s\"\n    })\n    exports[id+\"seq\"] = makeOp({\n      args: [\"array\",\"scalar\"],\n      body: {args:[\"a\",\"s\"],\n             body:\"a\"+op+\"=s\"},\n      rvalue: true,\n      funcName: id+\"seq\"\n    })\n  }\n})();\n\nvar unary_ops = {\n  not: \"!\",\n  bnot: \"~\",\n  neg: \"-\",\n  recip: \"1.0/\"\n}\n;(function(){\n  for(var id in unary_ops) {\n    var op = unary_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {args:[\"a\",\"b\"],\n             body:\"a=\"+op+\"b\"},\n      funcName: id\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\"],\n      body: {args:[\"a\"],\n             body:\"a=\"+op+\"a\"},\n      rvalue: true,\n      count: 2,\n      funcName: id+\"eq\"\n    })\n  }\n})();\n\nvar binary_ops = {\n  and: \"&&\",\n  or: \"||\",\n  eq: \"===\",\n  neq: \"!==\",\n  lt: \"<\",\n  gt: \">\",\n  leq: \"<=\",\n  geq: \">=\"\n}\n;(function() {\n  for(var id in binary_ops) {\n    var op = binary_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\",\"array\",\"array\"],\n      body: {args:[\"a\", \"b\", \"c\"],\n             body:\"a=b\"+op+\"c\"},\n      funcName: id\n    })\n    exports[id+\"s\"] = makeOp({\n      args: [\"array\",\"array\",\"scalar\"],\n      body: {args:[\"a\", \"b\", \"s\"],\n             body:\"a=b\"+op+\"s\"},\n      funcName: id+\"s\"\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {args:[\"a\", \"b\"],\n             body:\"a=a\"+op+\"b\"},\n      rvalue:true,\n      count:2,\n      funcName: id+\"eq\"\n    })\n    exports[id+\"seq\"] = makeOp({\n      args: [\"array\", \"scalar\"],\n      body: {args:[\"a\",\"s\"],\n             body:\"a=a\"+op+\"s\"},\n      rvalue:true,\n      count:2,\n      funcName: id+\"seq\"\n    })\n  }\n})();\n\nvar math_unary = [\n  \"abs\",\n  \"acos\",\n  \"asin\",\n  \"atan\",\n  \"ceil\",\n  \"cos\",\n  \"exp\",\n  \"floor\",\n  \"log\",\n  \"round\",\n  \"sin\",\n  \"sqrt\",\n  \"tan\"\n]\n;(function() {\n  for(var i=0; i<math_unary.length; ++i) {\n    var f = math_unary[i]\n    exports[f] = makeOp({\n                    args: [\"array\", \"array\"],\n                    pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                    body: {args:[\"a\",\"b\"], body:\"a=this_f(b)\", thisVars:[\"this_f\"]},\n                    funcName: f\n                  })\n    exports[f+\"eq\"] = makeOp({\n                      args: [\"array\"],\n                      pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                      body: {args: [\"a\"], body:\"a=this_f(a)\", thisVars:[\"this_f\"]},\n                      rvalue: true,\n                      count: 2,\n                      funcName: f+\"eq\"\n                    })\n  }\n})();\n\nvar math_comm = [\n  \"max\",\n  \"min\",\n  \"atan2\",\n  \"pow\"\n]\n;(function(){\n  for(var i=0; i<math_comm.length; ++i) {\n    var f= math_comm[i]\n    exports[f] = makeOp({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(b,c)\", thisVars:[\"this_f\"]},\n                  funcName: f\n                })\n    exports[f+\"s\"] = makeOp({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(b,c)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"s\"\n                  })\n    exports[f+\"eq\"] = makeOp({ args:[\"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(a,b)\", thisVars:[\"this_f\"]},\n                  rvalue: true,\n                  count: 2,\n                  funcName: f+\"eq\"\n                  })\n    exports[f+\"seq\"] = makeOp({ args:[\"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(a,b)\", thisVars:[\"this_f\"]},\n                  rvalue:true,\n                  count:2,\n                  funcName: f+\"seq\"\n                  })\n  }\n})();\n\nvar math_noncomm = [\n  \"atan2\",\n  \"pow\"\n]\n;(function(){\n  for(var i=0; i<math_noncomm.length; ++i) {\n    var f= math_noncomm[i]\n    exports[f+\"op\"] = makeOp({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(c,b)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"op\"\n                })\n    exports[f+\"ops\"] = makeOp({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(c,b)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"ops\"\n                  })\n    exports[f+\"opeq\"] = makeOp({ args:[\"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(b,a)\", thisVars:[\"this_f\"]},\n                  rvalue: true,\n                  count: 2,\n                  funcName: f+\"opeq\"\n                  })\n    exports[f+\"opseq\"] = makeOp({ args:[\"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(b,a)\", thisVars:[\"this_f\"]},\n                  rvalue:true,\n                  count:2,\n                  funcName: f+\"opseq\"\n                  })\n  }\n})();\n\nexports.any = compile({\n  args:[\"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"if(a){return true}\", localVars: [], thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return false\"},\n  funcName: \"any\"\n})\n\nexports.all = compile({\n  args:[\"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"x\", lvalue:false, rvalue:true, count:1}], body: \"if(!x){return false}\", localVars: [], thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return true\"},\n  funcName: \"all\"\n})\n\nexports.sum = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"this_s+=a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"sum\"\n})\n\nexports.prod = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=1\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"this_s*=a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"prod\"\n})\n\nexports.norm2squared = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:2}], body: \"this_s+=a*a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norm2squared\"\n})\n  \nexports.norm2 = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:2}], body: \"this_s+=a*a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return Math.sqrt(this_s)\"},\n  funcName: \"norm2\"\n})\n  \n\nexports.norminf = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:4}], body:\"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norminf\"\n})\n\nexports.norm1 = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:3}], body: \"this_s+=a<0?-a:a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norm1\"\n})\n\nexports.sup = compile({\n  args: [ \"array\" ],\n  pre:\n   { body: \"this_h=-Infinity\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  body:\n   { body: \"if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_\",\n     args: [{\"name\":\"_inline_1_arg0_\",\"lvalue\":false,\"rvalue\":true,\"count\":2} ],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  post:\n   { body: \"return this_h\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] }\n })\n\nexports.inf = compile({\n  args: [ \"array\" ],\n  pre:\n   { body: \"this_h=Infinity\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  body:\n   { body: \"if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_\",\n     args: [{\"name\":\"_inline_1_arg0_\",\"lvalue\":false,\"rvalue\":true,\"count\":2} ],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  post:\n   { body: \"return this_h\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] }\n })\n\nexports.argmin = compile({\n  args:[\"index\",\"array\",\"shape\"],\n  pre:{\n    body:\"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args:[\n      {name:\"_inline_0_arg0_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg1_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg2_\",lvalue:false,rvalue:true,count:1}\n      ],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[]},\n  body:{\n    body:\"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args:[\n      {name:\"_inline_1_arg0_\",lvalue:false,rvalue:true,count:2},\n      {name:\"_inline_1_arg1_\",lvalue:false,rvalue:true,count:2}],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[\"_inline_1_k\"]},\n  post:{\n    body:\"{return this_i}\",\n    args:[],\n    thisVars:[\"this_i\"],\n    localVars:[]}\n})\n\nexports.argmax = compile({\n  args:[\"index\",\"array\",\"shape\"],\n  pre:{\n    body:\"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args:[\n      {name:\"_inline_0_arg0_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg1_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg2_\",lvalue:false,rvalue:true,count:1}\n      ],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[]},\n  body:{\n    body:\"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args:[\n      {name:\"_inline_1_arg0_\",lvalue:false,rvalue:true,count:2},\n      {name:\"_inline_1_arg1_\",lvalue:false,rvalue:true,count:2}],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[\"_inline_1_k\"]},\n  post:{\n    body:\"{return this_i}\",\n    args:[],\n    thisVars:[\"this_i\"],\n    localVars:[]}\n})  \n\nexports.random = makeOp({\n  args: [\"array\"],\n  pre: {args:[], body:\"this_f=Math.random\", thisVars:[\"this_f\"]},\n  body: {args: [\"a\"], body:\"a=this_f()\", thisVars:[\"this_f\"]},\n  funcName: \"random\"\n})\n\nexports.assign = makeOp({\n  args:[\"array\", \"array\"],\n  body: {args:[\"a\", \"b\"], body:\"a=b\"},\n  funcName: \"assign\" })\n\nexports.assigns = makeOp({\n  args:[\"array\", \"scalar\"],\n  body: {args:[\"a\", \"b\"], body:\"a=b\"},\n  funcName: \"assigns\" })\n\n\nexports.equals = compile({\n  args:[\"array\", \"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"x\", lvalue:false, rvalue:true, count:1},\n               {name:\"y\", lvalue:false, rvalue:true, count:1}], \n        body: \"if(x!==y){return false}\", \n        localVars: [], \n        thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return true\"},\n  funcName: \"equals\"\n})\n\n\n", "import ndarray from 'ndarray';\nimport type { NdArray } from 'ndarray';\n\nexport function getPixelsInternal(\n\tbuffer: Uint8Array,\n\tmimeType: string,\n): Promise<NdArray<Uint8Array>> {\n\t// Warn for Data URIs, URLs, and file paths. Support removed in v3.\n\tif (!(buffer instanceof Uint8Array)) {\n\t\tthrow new Error('[ndarray-pixels] Input must be Uint8Array or Buffer.');\n\t}\n\n\tconst blob = new Blob([buffer], { type: mimeType });\n\treturn createImageBitmap(blob, {\n\t\tpremultiplyAlpha: 'none',\n\t\tcolorSpaceConversion: 'none',\n\t}).then((img) => {\n\t\tconst canvas = new OffscreenCanvas(img.width, img.height);\n\t\tconst context = canvas.getContext('2d')!;\n\t\tcontext.drawImage(img, 0, 0);\n\t\tconst pixels = context.getImageData(0, 0, img.width, img.height);\n\t\treturn ndarray(\n\t\t\tnew Uint8Array(pixels.data),\n\t\t\t[img.width, img.height, 4],\n\t\t\t[4, 4 * img.width, 1],\n\t\t\t0,\n\t\t);\n\t});\n}\n", "import ndarray, { type NdArray } from 'ndarray';\nimport ops from 'ndarray-ops';\n\nexport interface ImageEncodeOptions {\n\ttype?: string;\n\tquality?: number;\n}\n\nexport function putPixelData(\n\tarray: NdArray<Uint8Array | Uint8ClampedArray>,\n\tdata: Uint8Array | Uint8ClampedArray,\n\tframe = -1,\n): Uint8Array | Uint8ClampedArray {\n\tif (array.shape.length === 4) {\n\t\treturn putPixelData(array.pick(frame), data, 0);\n\t}\n\n\tif (array.shape.length === 3) {\n\t\tif (array.shape[2] === 3) {\n\t\t\tops.assign(\n\t\t\t\tndarray(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]),\n\t\t\t\tarray,\n\t\t\t);\n\t\t\tops.assigns(ndarray(data, [array.shape[0] * array.shape[1]], [4], 3), 255);\n\t\t} else if (array.shape[2] === 4) {\n\t\t\tops.assign(\n\t\t\t\tndarray(data, [array.shape[0], array.shape[1], 4], [4, array.shape[0] * 4, 1]),\n\t\t\t\tarray,\n\t\t\t);\n\t\t} else if (array.shape[2] === 1) {\n\t\t\tops.assign(\n\t\t\t\tndarray(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]),\n\t\t\t\tndarray(\n\t\t\t\t\tarray.data,\n\t\t\t\t\t[array.shape[0], array.shape[1], 3],\n\t\t\t\t\t[array.stride[0], array.stride[1], 0],\n\t\t\t\t\tarray.offset,\n\t\t\t\t),\n\t\t\t);\n\t\t\tops.assigns(ndarray(data, [array.shape[0] * array.shape[1]], [4], 3), 255);\n\t\t} else {\n\t\t\tthrow new Error('[ndarray-pixels] Incompatible array shape.');\n\t\t}\n\t} else if (array.shape.length === 2) {\n\t\tops.assign(\n\t\t\tndarray(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]),\n\t\t\tndarray(\n\t\t\t\tarray.data,\n\t\t\t\t[array.shape[0], array.shape[1], 3],\n\t\t\t\t[array.stride[0], array.stride[1], 0],\n\t\t\t\tarray.offset,\n\t\t\t),\n\t\t);\n\t\tops.assigns(ndarray(data, [array.shape[0] * array.shape[1]], [4], 3), 255);\n\t} else {\n\t\tthrow new Error('[ndarray-pixels] Incompatible array shape.');\n\t}\n\n\treturn data;\n}\n", "import type { NdArray } from 'ndarray';\nimport { putPixelData } from './common';\nimport type { ImageEncodeOptions } from './common';\n\nexport async function savePixelsInternal(\n\tpixels: NdArray<Uint8Array | Uint8ClampedArray>,\n\toptions: ImageEncodeOptions,\n): Promise<Uint8Array> {\n\t// Create OffscreenCanvas and write pixel data.\n\tconst canvas = new OffscreenCanvas(pixels.shape[0], pixels.shape[1]);\n\n\tconst context = canvas.getContext('2d')!;\n\tconst imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\n\tputPixelData(pixels, imageData.data);\n\tcontext.putImageData(imageData, 0, 0);\n\n\treturn streamCanvas(canvas, options);\n}\n\n/** Creates readable stream from given OffscreenCanvas and options. */\nasync function streamCanvas(\n\tcanvas: OffscreenCanvas,\n\toptions: ImageEncodeOptions,\n): Promise<Uint8Array> {\n\tconst blob = await canvas.convertToBlob(options);\n\tconst ab = await blob.arrayBuffer();\n\treturn new Uint8Array(ab);\n}\n", "import type { NdArray } from 'ndarray';\nimport { getPixelsInternal } from './node-get-pixels';\nimport { savePixelsInternal } from './node-save-pixels';\n\n/**\n * Decodes image data to an `ndarray`.\n *\n * MIME type is optional when given a path or URL, and required when given a Uint8Array.\n *\n * Accepts `image/png` or `image/jpeg` in Node.js, and additional formats on browsers with\n * the necessary support in Canvas 2D.\n *\n * @param data\n * @param mimeType `image/jpeg`, `image/png`, etc.\n * @returns\n */\nasync function getPixels(data: Uint8Array, mimeType: string): Promise<NdArray<Uint8Array>> {\n\treturn getPixelsInternal(data, mimeType);\n}\n\n/**\n * Encodes an `ndarray` as image data in the given format.\n *\n * If the source `ndarray` was constructed manually with default stride, use\n * `ndarray.transpose(1, 0)` to reshape it and ensure an identical result from getPixels(). For an\n * ndarray created by getPixels(), this isn't necessary.\n *\n * Accepts `image/png` or `image/jpeg` in Node.js, and additional formats on browsers with\n * the necessary support in Canvas 2D.\n *\n * @param pixels ndarray of shape W x H x 4.\n * @param typeOrOptions object with encoding options or just the type\n * @param typeOrOptions.type target format (`image/jpeg`, `image/png`, `image/webp`, etc.)\n * @param typeOrOptions.quality quality as a number from 0 to 1, inclusive\n * @returns\n */\nasync function savePixels(\n\tpixels: NdArray<Uint8Array | Uint8ClampedArray>,\n\ttypeOrOptions: string | { type?: string; quality?: number },\n): Promise<Uint8Array> {\n\tlet options: { type?: string; quality?: number };\n\tif (typeof typeOrOptions === 'string') {\n\t\toptions = {\n\t\t\ttype: typeOrOptions,\n\t\t\tquality: undefined,\n\t\t};\n\t} else {\n\t\toptions = {\n\t\t\ttype: typeOrOptions.type,\n\t\t\tquality: typeOrOptions.quality,\n\t\t};\n\t}\n\treturn savePixelsInternal(pixels, options);\n}\n\nexport { getPixels, savePixels };\n", "export type TypedArrayConstructor = Int8ArrayConstructor | Int16ArrayConstructor | Int32ArrayConstructor |\n\tUint8ArrayConstructor | Uint8ClampedArrayConstructor | Uint16ArrayConstructor |\n\tUint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor\n\nconst filterValue = ( x: number, a: 2 | 3 ) => {\n\tif ( x <= -a || x >= a ) return 0\n\n\t// appears to do nothing?\n\tif ( x > -1.19209290e-07 && x < 1.19209290e-07 ) return 1\n\n\tconst xPi = x * Math.PI\n\n\treturn ( Math.sin( xPi ) / xPi ) * Math.sin( xPi / a ) / ( xPi / a )\n}\n\nexport const filters = (\n\tsrcSize: number,\n\tdestSize: number,\n\tscale: number,\n\toffset: number,\n\tuse2: boolean,\n\tfloatType: TypedArrayConstructor,\n\tintType: TypedArrayConstructor,\n\tfixedFracBits: number\n) => {\n\tconst mul = (2 ** fixedFracBits) - 1\n\tconst toFixedPoint = (value: number) => Math.round(value * mul)\n\n\tconst a = use2 ? 2 : 3\n\tconst scaleInverted = 1 / scale\n\tconst scaleClamped = Math.min( 1, scale ) // For upscale\n\n\t// Filter window (averaging interval), scaled to src image\n\tconst srcWindow = a / scaleClamped\n\n\tconst maxFilterElementSize = Math.floor( ( srcWindow + 1 ) * 2 )\n\tconst packedFilter = new intType( ( maxFilterElementSize + 2 ) * destSize )\n\tlet packedFilterPtr = 0\n\n\t// For each destination pixel calculate source range and built filter values\n\tfor ( let destPixel = 0; destPixel < destSize; destPixel++ ) {\n\n\t\t// Scaling should be done relative to central pixel point\n\t\tconst sourcePixel = ( destPixel + 0.5 ) * scaleInverted + offset\n\t\tconst sourceFirst = Math.max( 0, Math.floor( sourcePixel - srcWindow ) )\n\t\tconst sourceLast = Math.min( srcSize - 1, Math.ceil( sourcePixel + srcWindow ) )\n\n\t\tconst filterElementSize = sourceLast - sourceFirst + 1\n\t\tconst floatFilter = new floatType( filterElementSize )\n\t\tconst fxpFilter = new intType( filterElementSize )\n\n\t\tlet total = 0\n\n\t\t// Fill filter values for calculated range\n\t\tlet index = 0\n\t\tfor ( let pixel = sourceFirst; pixel <= sourceLast; pixel++ ) {\n\t\t\tconst floatValue = filterValue( ( ( pixel + 0.5 ) - sourcePixel ) * scaleClamped, a )\n\n\t\t\ttotal += floatValue\n\t\t\tfloatFilter[ index ] = floatValue\n\n\t\t\tindex++\n\t\t}\n\n\t\t// Normalize filter, convert to fixed point and accumulate conversion error\n\t\tlet filterTotal = 0\n\n\t\tfor ( let index = 0; index < floatFilter.length; index++ ) {\n\t\t\tconst filterValue = floatFilter[ index ] / total\n\n\t\t\tfilterTotal += filterValue\n\t\t\tfxpFilter[ index ] = toFixedPoint( filterValue )\n\t\t}\n\n\t\t// Compensate normalization error, to minimize brightness drift\n\t\tfxpFilter[ destSize >> 1 ] += toFixedPoint( 1 - filterTotal )\n\n\t\t//\n\t\t// Now pack filter to useable form\n\t\t//\n\t\t// 1. Trim heading and tailing zero values, and compensate shitf/length\n\t\t// 2. Put all to single array in this format:\n\t\t//\n\t\t//    [ pos shift, data length, value1, value2, value3, ... ]\n\t\t//\n\t\tlet leftNotEmpty = 0\n\t\twhile ( leftNotEmpty < fxpFilter.length && fxpFilter[ leftNotEmpty ] === 0 ) {\n\t\t\tleftNotEmpty++\n\t\t}\n\n\t\tlet rightNotEmpty = fxpFilter.length - 1\n\t\twhile ( rightNotEmpty > 0 && fxpFilter[ rightNotEmpty ] === 0 ) {\n\t\t\trightNotEmpty--\n\t\t}\n\n\t\tconst filterShift = sourceFirst + leftNotEmpty\n\t\tconst filterSize = rightNotEmpty - leftNotEmpty + 1\n\n\t\tpackedFilter[ packedFilterPtr++ ] = filterShift // shift\n\t\tpackedFilter[ packedFilterPtr++ ] = filterSize // size\n\n\t\tpackedFilter.set( fxpFilter.subarray( leftNotEmpty, rightNotEmpty + 1 ), packedFilterPtr )\n\t\tpackedFilterPtr += filterSize\n\t}\n\n\treturn packedFilter\n}\n", "import type { NdArray, TypedArray } from 'ndarray';\n\nexport const convolve = (src: NdArray<TypedArray | number[]>, dst: NdArray<TypedArray>, filters: TypedArray, fixedFracBits: number) => {\n\tconst [_, srcHeight] = src.shape;\n\tconst [dstWidth] = dst.shape;\n\n\tconst maxValue = 2 ** (dst.data.BYTES_PER_ELEMENT * 8) - 1;\n\tconst clamp = (v: number): number => v < 0 ? 0 : (v > maxValue ? maxValue : v);\n\tconst fixedFracMul = 2 ** (fixedFracBits - 1);\n\tconst fixedFracMul2 = 2 * fixedFracMul;\n\n\t// For each row\n\tfor (let srcY = 0; srcY < srcHeight; srcY++) {\n\t\tconst dstY = srcY;\n\n\t\t// Apply precomputed filters to each destination row point\n\t\tlet filterPtr = 0;\n\t\tfor (let dstX = 0; dstX < dstWidth; dstX++) {\n\t\t\t// Get the filter that determines the current output pixel.\n\t\t\tlet srcX = filters[filterPtr++];\n\n\t\t\tlet r = 0;\n\t\t\tlet g = 0;\n\t\t\tlet b = 0;\n\t\t\tlet a = 0;\n\n\t\t\t// Apply the filter to the row to get the destination pixel r, g, b, a\n\t\t\tfor (let filterSize = filters[filterPtr++]; filterSize > 0; filterSize--) {\n\t\t\t\tconst filterValue = filters[filterPtr++];\n\n\t\t\t\tr = ( r + filterValue * src.get(srcX, srcY, 0) );\n\t\t\t\tg = ( g + filterValue * src.get(srcX, srcY, 1) );\n\t\t\t\tb = ( b + filterValue * src.get(srcX, srcY, 2) );\n\t\t\t\ta = ( a + filterValue * src.get(srcX, srcY, 3) );\n\n\t\t\t\tsrcX++;\n\t\t\t}\n\n\t\t\t// Bring this value back in range. All of the filter scaling factors\n\t\t\t// are in fixed point with fixedFracBits bits of fractional part.\n\t\t\t//\n\t\t\t// (!) Add 1/2 of value before clamping to get proper rounding. In other\n\t\t\t// case brightness loss will be noticeable if you resize image with white\n\t\t\t// border and place it on white background.\n\t\t\tdst.set(dstX, dstY, 0, clamp( ( r + fixedFracMul ) / fixedFracMul2 ) );\n\t\t\tdst.set(dstX, dstY, 1, clamp( ( g + fixedFracMul ) / fixedFracMul2 ) );\n\t\t\tdst.set(dstX, dstY, 2, clamp( ( b + fixedFracMul ) / fixedFracMul2 ) );\n\t\t\tdst.set(dstX, dstY, 3, clamp( ( a + fixedFracMul ) / fixedFracMul2 ) );\n\t\t}\n\t}\n}\n", "import ndarray, { NdArray } from 'ndarray';\nimport { filters, TypedArrayConstructor } from '../vendor/filters.js';\nimport { convolve } from './convolve.js';\n\nenum Method {\n\tLANCZOS_3 = 3,\n\tLANCZOS_2 = 2,\n}\n\nexport type SupportedTypes = Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array\n\nfunction resize(\n\tsrc: NdArray<SupportedTypes | number[]>,\n\tdst: NdArray<SupportedTypes>, method: Method\n): void {\n\tif (src.shape.length !== 3 || dst.shape.length !== 3)\n\t\tthrow new TypeError\n\t\t\t('Input and output must have exactly 3 dimensions (width, height and colorspace)');\n\n\tconst [srcWidth, srcHeight] = src.shape;\n\tconst [dstWidth, dstHeight] = dst.shape;\n\n\tconst ratioX = dstWidth / srcWidth;\n\tconst ratioY = dstHeight / srcHeight;\n\n\tlet floatType, intType;\n\tswitch (dst.dtype) {\n\t\tcase 'uint8_clamped':\n\t\tcase 'uint8':\n\t\t\tfloatType = Float32Array;\n\t\t\tintType = Int16Array;\n\t\t\tbreak;\n\t\tcase 'uint16':\n\t\tcase 'uint32':\n\t\t\tfloatType = Float64Array;\n\t\t\tintType = Int32Array;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow TypeError(`Unsupported data type ${dst.dtype}`);\n\t}\n\tconst fixedFracBits = intType.BYTES_PER_ELEMENT * 7;\n\n\tconst filtersX = filters(srcWidth, dstWidth, ratioX, 0, method === Method.LANCZOS_2,\n\t\tfloatType, intType, fixedFracBits);\n\tconst filtersY = filters(srcHeight, dstHeight, ratioY, 0, method === Method.LANCZOS_2,\n\t\tfloatType, intType, fixedFracBits);\n\n\tconst constructor = dst.data.constructor as TypedArrayConstructor;\n\tconst tmp = ndarray(new constructor(dstWidth * srcHeight * 4), [srcHeight, dstWidth, 4]);\n\tconst tmpTranspose = tmp.transpose(1, 0);\n\tconst dstTranspose = dst.transpose(1, 0);\n\n\tconvolve(src, tmpTranspose, filtersX, fixedFracBits);\n\tconvolve(tmp, dstTranspose, filtersY, fixedFracBits);\n}\n\nexport function lanczos3(src: NdArray<SupportedTypes | number[]>, dst: NdArray<SupportedTypes>): void {\n\tresize(src, dst, Method.LANCZOS_3);\n}\n\nexport function lanczos2(src: NdArray<SupportedTypes | number[]>, dst: NdArray<SupportedTypes>): void {\n\tresize(src, dst, Method.LANCZOS_2);\n}\n", "import {\n\ttype Accessor,\n\tDocument,\n\ttype GLTF,\n\tPrimitive,\n\ttype Property,\n\tPropertyType,\n\ttype Texture,\n\ttype Transform,\n\ttype TransformContext,\n\ttype vec2,\n} from '@gltf-transform/core';\nimport type { NdArray } from 'ndarray';\nimport { getPixels, savePixels } from 'ndarray-pixels';\n\nconst { POINTS, LINES, LINE_STRIP, LINE_LOOP, TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN } = Primitive.Mode;\n\n/**\n * Prepares a function used in an {@link Document#transform} pipeline. Use of this wrapper is\n * optional, and plain functions may be used in transform pipelines just as well. The wrapper is\n * used internally so earlier pipeline stages can detect and optimize based on later stages.\n * @hidden\n */\nexport function createTransform(name: string, fn: Transform): Transform {\n\tObject.defineProperty(fn, 'name', { value: name });\n\treturn fn;\n}\n\n/** @hidden */\nexport function isTransformPending(context: TransformContext | undefined, initial: string, pending: string): boolean {\n\tif (!context) return false;\n\tconst initialIndex = context.stack.lastIndexOf(initial);\n\tconst pendingIndex = context.stack.lastIndexOf(pending);\n\treturn initialIndex < pendingIndex;\n}\n\n/**\n * Performs a shallow merge on an 'options' object and a 'defaults' object.\n * Equivalent to `{...defaults, ...options}` _except_ that `undefined` values\n * in the 'options' object are ignored.\n *\n * @hidden\n */\nexport function assignDefaults<Defaults, Options>(defaults: Defaults, options: Options): Defaults & Options {\n\tconst result = { ...defaults } as Defaults & Partial<Options>;\n\tfor (const key in options) {\n\t\tif (options[key] !== undefined) {\n\t\t\t// biome-ignore lint/suspicious/noExplicitAny: TODO\n\t\t\tresult[key] = options[key] as any;\n\t\t}\n\t}\n\treturn result as Defaults & Options;\n}\n\n/**\n * Maps pixels from source to target textures, with a per-pixel callback.\n * @hidden\n */\nexport async function rewriteTexture(\n\tsource: Texture,\n\ttarget: Texture,\n\tfn: (pixels: NdArray, i: number, j: number) => void,\n): Promise<Texture | null> {\n\tif (!source) return null;\n\n\tconst srcImage = source.getImage();\n\tif (!srcImage) return null;\n\n\tconst pixels = await getPixels(srcImage, source.getMimeType());\n\n\tfor (let i = 0; i < pixels.shape[0]; ++i) {\n\t\tfor (let j = 0; j < pixels.shape[1]; ++j) {\n\t\t\tfn(pixels, i, j);\n\t\t}\n\t}\n\n\tconst dstImage = await savePixels(pixels, 'image/png');\n\treturn target.setImage(dstImage).setMimeType('image/png');\n}\n\n/** @hidden */\nexport function getGLPrimitiveCount(prim: Primitive): number {\n\tconst indices = prim.getIndices();\n\tconst position = prim.getAttribute('POSITION')!;\n\n\t// Reference: https://www.khronos.org/opengl/wiki/Primitive\n\tswitch (prim.getMode()) {\n\t\tcase Primitive.Mode.POINTS:\n\t\t\treturn indices ? indices.getCount() : position.getCount();\n\t\tcase Primitive.Mode.LINES:\n\t\t\treturn indices ? indices.getCount() / 2 : position.getCount() / 2;\n\t\tcase Primitive.Mode.LINE_LOOP:\n\t\t\treturn indices ? indices.getCount() : position.getCount();\n\t\tcase Primitive.Mode.LINE_STRIP:\n\t\t\treturn indices ? indices.getCount() - 1 : position.getCount() - 1;\n\t\tcase Primitive.Mode.TRIANGLES:\n\t\t\treturn indices ? indices.getCount() / 3 : position.getCount() / 3;\n\t\tcase Primitive.Mode.TRIANGLE_STRIP:\n\t\tcase Primitive.Mode.TRIANGLE_FAN:\n\t\t\treturn indices ? indices.getCount() - 2 : position.getCount() - 2;\n\t\tdefault:\n\t\t\tthrow new Error('Unexpected mode: ' + prim.getMode());\n\t}\n}\n\n/** @hidden */\nexport class SetMap<K, V> {\n\tprivate _map = new Map<K, Set<V>>();\n\tpublic get size(): number {\n\t\treturn this._map.size;\n\t}\n\tpublic has(k: K): boolean {\n\t\treturn this._map.has(k);\n\t}\n\tpublic add(k: K, v: V): this {\n\t\tlet entry = this._map.get(k);\n\t\tif (!entry) {\n\t\t\tentry = new Set();\n\t\t\tthis._map.set(k, entry);\n\t\t}\n\t\tentry.add(v);\n\t\treturn this;\n\t}\n\tpublic get(k: K): Set<V> {\n\t\treturn this._map.get(k) || new Set();\n\t}\n\tpublic keys(): Iterable<K> {\n\t\treturn this._map.keys();\n\t}\n}\n\n/** @hidden */\nexport function formatBytes(bytes: number, decimals = 2): string {\n\tif (bytes === 0) return '0 Bytes';\n\n\tconst k = 1000;\n\tconst dm = decimals < 0 ? 0 : decimals;\n\tconst sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n\tconst i = Math.floor(Math.log(bytes) / Math.log(k));\n\n\treturn parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\n\nconst _longFormatter = new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 });\n\n/** @hidden */\nexport function formatLong(x: number): string {\n\treturn _longFormatter.format(x);\n}\n\n/** @hidden */\nexport function formatDelta(a: number, b: number, decimals = 2): string {\n\tconst prefix = a > b ? '' : '+';\n\tconst suffix = '%';\n\treturn prefix + ((Math.abs(a - b) / a) * 100).toFixed(decimals) + suffix;\n}\n\n/** @hidden */\nexport function formatDeltaOp(a: number, b: number) {\n\treturn `${formatLong(a)}  ${formatLong(b)} (${formatDelta(a, b)})`;\n}\n\n/**\n * Returns a list of all unique vertex attributes on the given primitive and\n * its morph targets.\n * @hidden\n */\nexport function deepListAttributes(prim: Primitive): Accessor[] {\n\tconst accessors: Accessor[] = [];\n\n\tfor (const attribute of prim.listAttributes()) {\n\t\taccessors.push(attribute);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const attribute of target.listAttributes()) {\n\t\t\taccessors.push(attribute);\n\t\t}\n\t}\n\n\treturn Array.from(new Set(accessors));\n}\n\n/** @hidden */\nexport function deepSwapAttribute(prim: Primitive, src: Accessor, dst: Accessor): void {\n\tprim.swap(src, dst);\n\tfor (const target of prim.listTargets()) {\n\t\ttarget.swap(src, dst);\n\t}\n}\n\n/**\n * Disposes of a {@link Primitive} and any {@link Accessor Accesors} for which\n * it is the last remaining parent.\n * @hidden\n */\nexport function deepDisposePrimitive(prim: Primitive): void {\n\tconst indices = prim.getIndices();\n\tconst attributes = deepListAttributes(prim);\n\n\tprim.dispose();\n\n\tif (indices && !isUsed(indices)) {\n\t\tindices.dispose();\n\t}\n\n\tfor (const attribute of attributes) {\n\t\tif (!isUsed(attribute)) {\n\t\t\tattribute.dispose();\n\t\t}\n\t}\n}\n\n/** @hidden */\nexport function shallowEqualsArray(a: ArrayLike<unknown> | null, b: ArrayLike<unknown> | null): boolean {\n\tif (a == null && b == null) return true;\n\tif (a == null || b == null) return false;\n\tif (a.length !== b.length) return false;\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) return false;\n\t}\n\treturn true;\n}\n\n/** Clones an {@link Accessor} without creating a copy of its underlying TypedArray data. */\nexport function shallowCloneAccessor(document: Document, accessor: Accessor): Accessor {\n\treturn document\n\t\t.createAccessor(accessor.getName())\n\t\t.setArray(accessor.getArray())\n\t\t.setType(accessor.getType())\n\t\t.setBuffer(accessor.getBuffer())\n\t\t.setNormalized(accessor.getNormalized())\n\t\t.setSparse(accessor.getSparse());\n}\n\n/** @hidden */\nexport function createIndices(count: number, maxIndex: number = count): Uint16Array | Uint32Array {\n\tconst array = createIndicesEmpty(count, maxIndex);\n\tfor (let i = 0; i < array.length; i++) array[i] = i;\n\treturn array;\n}\n\n/** @hidden */\nexport function createIndicesEmpty(count: number, maxIndex: number = count): Uint16Array | Uint32Array {\n\treturn maxIndex <= 65534 ? new Uint16Array(count) : new Uint32Array(count);\n}\n\n/** @hidden */\nexport function isUsed(prop: Property): boolean {\n\treturn prop.listParents().some((parent) => parent.propertyType !== PropertyType.ROOT);\n}\n\n/** @hidden */\nexport function isEmptyObject(object: Record<string, unknown>): boolean {\n\tfor (const _key in object) return false;\n\treturn true;\n}\n\n/**\n * Creates a unique key associated with the structure and draw call characteristics of\n * a {@link Primitive}, independent of its vertex content. Helper method, used to\n * identify candidate Primitives for joining.\n * @hidden\n */\nexport function createPrimGroupKey(prim: Primitive): string {\n\tconst document = Document.fromGraph(prim.getGraph())!;\n\tconst material = prim.getMaterial();\n\tconst materialIndex = document.getRoot().listMaterials().indexOf(material!);\n\tconst mode = BASIC_MODE_MAPPING[prim.getMode()];\n\tconst indices = !!prim.getIndices();\n\n\tconst attributes = prim\n\t\t.listSemantics()\n\t\t.sort()\n\t\t.map((semantic) => {\n\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\tconst elementSize = attribute.getElementSize();\n\t\t\tconst componentType = attribute.getComponentType();\n\t\t\treturn `${semantic}:${elementSize}:${componentType}`;\n\t\t})\n\t\t.join('+');\n\n\tconst targets = prim\n\t\t.listTargets()\n\t\t.map((target) => {\n\t\t\treturn target\n\t\t\t\t.listSemantics()\n\t\t\t\t.sort()\n\t\t\t\t.map((semantic) => {\n\t\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\t\tconst elementSize = attribute.getElementSize();\n\t\t\t\t\tconst componentType = attribute.getComponentType();\n\t\t\t\t\treturn `${semantic}:${elementSize}:${componentType}`;\n\t\t\t\t})\n\t\t\t\t.join('+');\n\t\t})\n\t\t.join('~');\n\n\treturn `${materialIndex}|${mode}|${indices}|${attributes}|${targets}`;\n}\n\n/**\n * Scales `size` NxN dimensions to fit within `limit` NxN dimensions, without\n * changing aspect ratio. If `size` <= `limit` in all dimensions, returns `size`.\n * @hidden\n */\nexport function fitWithin(size: vec2, limit: vec2): vec2 {\n\tconst [maxWidth, maxHeight] = limit;\n\tconst [srcWidth, srcHeight] = size;\n\n\tif (srcWidth <= maxWidth && srcHeight <= maxHeight) return size;\n\n\tlet dstWidth = srcWidth;\n\tlet dstHeight = srcHeight;\n\n\tif (dstWidth > maxWidth) {\n\t\tdstHeight = Math.floor(dstHeight * (maxWidth / dstWidth));\n\t\tdstWidth = maxWidth;\n\t}\n\n\tif (dstHeight > maxHeight) {\n\t\tdstWidth = Math.floor(dstWidth * (maxHeight / dstHeight));\n\t\tdstHeight = maxHeight;\n\t}\n\n\treturn [dstWidth, dstHeight];\n}\n\ntype ResizePreset = 'nearest-pot' | 'ceil-pot' | 'floor-pot';\n\n/**\n * Scales `size` NxN dimensions to the specified power of two.\n * @hidden\n */\nexport function fitPowerOfTwo(size: vec2, method: ResizePreset): vec2 {\n\tif (isPowerOfTwo(size[0]) && isPowerOfTwo(size[1])) {\n\t\treturn size;\n\t}\n\n\tswitch (method) {\n\t\tcase 'nearest-pot':\n\t\t\treturn size.map(nearestPowerOfTwo) as vec2;\n\t\tcase 'ceil-pot':\n\t\t\treturn size.map(ceilPowerOfTwo) as vec2;\n\t\tcase 'floor-pot':\n\t\t\treturn size.map(floorPowerOfTwo) as vec2;\n\t}\n}\n\nfunction isPowerOfTwo(value: number): boolean {\n\tif (value <= 2) return true;\n\treturn (value & (value - 1)) === 0 && value !== 0;\n}\n\nfunction nearestPowerOfTwo(value: number): number {\n\tif (value <= 4) return 4;\n\n\tconst lo = floorPowerOfTwo(value);\n\tconst hi = ceilPowerOfTwo(value);\n\n\tif (hi - value > value - lo) return lo;\n\treturn hi;\n}\n\nexport function floorPowerOfTwo(value: number): number {\n\treturn Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\n\nexport function ceilPowerOfTwo(value: number): number {\n\treturn Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n\n/**\n * Mapping from any glTF primitive mode to its equivalent basic mode, as returned by\n * {@link convertPrimitiveMode}.\n * @hidden\n */\nexport const BASIC_MODE_MAPPING = {\n\t[POINTS]: POINTS,\n\t[LINES]: LINES,\n\t[LINE_STRIP]: LINES,\n\t[LINE_LOOP]: LINES,\n\t[TRIANGLES]: TRIANGLES,\n\t[TRIANGLE_STRIP]: TRIANGLES,\n\t[TRIANGLE_FAN]: TRIANGLES,\n} as Record<GLTF.MeshPrimitiveMode, GLTF.MeshPrimitiveMode>;\n", "import type { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { getBounds } from '@gltf-transform/core';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'center';\n\n/** Options for the {@link center} function. */\nexport interface CenterOptions {\n\t/** Location on the model to be considered the pivot, and recentered at the origin. */\n\tpivot?: 'center' | 'above' | 'below' | vec3;\n}\n\nconst CENTER_DEFAULTS: Required<CenterOptions> = { pivot: 'center' };\n\n/**\n * Centers the {@link Scene} at the origin, or above/below it. Transformations from animation,\n * skinning, and morph targets are not taken into account.\n *\n * Example:\n *\n * ```ts\n * await document.transform(center({pivot: 'below'}));\n * ```\n *\n * @category Transforms\n */\nexport function center(_options: CenterOptions = CENTER_DEFAULTS): Transform {\n\tconst options = assignDefaults(CENTER_DEFAULTS, _options);\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst isAnimated = root.listAnimations().length > 0 || root.listSkins().length > 0;\n\n\t\tdoc.getRoot()\n\t\t\t.listScenes()\n\t\t\t.forEach((scene, index) => {\n\t\t\t\tlogger.debug(`${NAME}: Scene ${index + 1} / ${root.listScenes().length}.`);\n\n\t\t\t\tlet pivot: vec3;\n\t\t\t\tif (typeof options.pivot === 'string') {\n\t\t\t\t\tconst bbox = getBounds(scene);\n\t\t\t\t\tpivot = [\n\t\t\t\t\t\t(bbox.max[0] - bbox.min[0]) / 2 + bbox.min[0],\n\t\t\t\t\t\t(bbox.max[1] - bbox.min[1]) / 2 + bbox.min[1],\n\t\t\t\t\t\t(bbox.max[2] - bbox.min[2]) / 2 + bbox.min[2],\n\t\t\t\t\t];\n\t\t\t\t\tif (options.pivot === 'above') pivot[1] = bbox.max[1];\n\t\t\t\t\tif (options.pivot === 'below') pivot[1] = bbox.min[1];\n\t\t\t\t} else {\n\t\t\t\t\tpivot = options.pivot as vec3;\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(`${NAME}: Pivot \"${pivot.join(', ')}\".`);\n\n\t\t\t\tconst offset: vec3 = [-1 * pivot[0], -1 * pivot[1], -1 * pivot[2]];\n\n\t\t\t\tif (isAnimated) {\n\t\t\t\t\tlogger.debug(`${NAME}: Model contains animation or skin. Adding a wrapper node.`);\n\t\t\t\t\tconst offsetNode = doc.createNode('Pivot').setTranslation(offset);\n\t\t\t\t\tscene.listChildren().forEach((child) => offsetNode.addChild(child));\n\t\t\t\t\tscene.addChild(offsetNode);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(`${NAME}: Skipping wrapper, offsetting all root nodes.`);\n\t\t\t\t\tscene.listChildren().forEach((child) => {\n\t\t\t\t\t\tconst t = child.getTranslation();\n\t\t\t\t\t\tchild.setTranslation([t[0] + offset[0], t[1] + offset[1], t[2] + offset[2]]);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import { type Node, Scene } from '@gltf-transform/core';\n\n/**\n * Finds the parent {@link Scene Scenes} associated with the given {@link Node}.\n * In most cases a Node is associated with only one Scene, but it is possible\n * for a Node to be located in two or more Scenes, or none at all.\n *\n * Example:\n *\n * ```typescript\n * import { listNodeScenes } from '@gltf-transform/functions';\n *\n * const node = document.getRoot().listNodes()\n *  .find((node) => node.getName() === 'MyNode');\n *\n * const scenes = listNodeScenes(node);\n * ```\n */\nexport function listNodeScenes(node: Node): Scene[] {\n\tconst visited = new Set<Node>();\n\n\tlet child = node;\n\tlet parent: Node | null;\n\n\twhile ((parent = child.getParentNode() as Node | null)) {\n\t\tif (visited.has(parent)) {\n\t\t\tthrow new Error('Circular dependency in scene graph.');\n\t\t}\n\t\tvisited.add(parent);\n\t\tchild = parent;\n\t}\n\n\treturn child.listParents().filter((parent) => parent instanceof Scene) as Scene[];\n}\n", "import type { Node } from '@gltf-transform/core';\nimport { listNodeScenes } from './list-node-scenes.js';\n\n/**\n * Clears the parent of the given {@link Node}, leaving it attached\n * directly to its {@link Scene}. Inherited transforms will be applied\n * to the Node. This operation changes the Node's local transform,\n * but leaves its world transform unchanged.\n *\n * Example:\n *\n * ```typescript\n * import { clearNodeParent } from '@gltf-transform/functions';\n *\n * scene.traverse((node) => { ... }); // Scene    Node\n *\n * clearNodeParent(node);\n *\n * scene.traverse((node) => { ... }); // Scene  Node\n * ```\n *\n * To clear _all_ transforms of a Node, first clear its inherited transforms with\n * {@link clearNodeParent}, then clear the local transform with {@link clearNodeTransform}.\n */\nexport function clearNodeParent(node: Node): Node {\n\tconst scenes = listNodeScenes(node);\n\tconst parent = node.getParentNode();\n\n\tif (!parent) return node;\n\n\t// Apply inherited transforms to local matrix. Skinned meshes are not affected\n\t// by the node parent's transform, and can be ignored. Updates to IBMs and TRS\n\t// animations are out of scope in this context.\n\tnode.setMatrix(node.getWorldMatrix());\n\n\t// Add to Scene roots.\n\tparent.removeChild(node);\n\tfor (const scene of scenes) scene.addChild(node);\n\n\treturn node;\n}\n", "/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};", "import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;", "import type { Accessor, Mesh, Node, Primitive, Scene } from '@gltf-transform/core';\nimport type { InstancedMesh } from '@gltf-transform/extensions';\n\n/**\n * Various methods of estimating a vertex count. For some background on why\n * multiple definitions of a vertex count should exist, see [_Vertex Count\n * Higher in Engine than in 3D Software_](https://shahriyarshahrabi.medium.com/vertex-count-higher-in-engine-than-in-3d-software-badc348ada66).\n * Totals for a {@link Scene}, {@link Node}, or {@link Mesh} will not\n * necessarily match the sum of the totals for each {@link Primitive}. Choose\n * the appropriate method for a relevant total or estimate:\n *\n * - {@link getSceneVertexCount}\n * - {@link getNodeVertexCount}\n * - {@link getMeshVertexCount}\n * - {@link getPrimitiveVertexCount}\n *\n * Many rendering features, such as volumetric transmission, may lead\n * to additional passes over some or all vertices. These tradeoffs are\n * implementation-dependent, and not considered here.\n */\nexport enum VertexCountMethod {\n\t/**\n\t * Expected number of vertices processed by the vertex shader for one render\n\t * pass, without considering the vertex cache.\n\t */\n\tRENDER = 'render',\n\n\t/**\n\t * Expected number of vertices processed by the vertex shader for one render\n\t * pass, assuming an Average Transform to Vertex Ratio (ATVR) of 1. Approaching\n\t * this result requires optimizing for locality of vertex references (see\n\t * {@link reorder}).\n\t *\n\t * References:\n\t * - [ACMR and ATVR](https://www.realtimerendering.com/blog/acmr-and-atvr/), Real-Time Rendering\n\t */\n\tRENDER_CACHED = 'render-cached',\n\n\t/**\n\t * Expected number of vertices uploaded to the GPU, assuming that a client\n\t * uploads each unique {@link Accessor} only once. Unless glTF vertex\n\t * attributes are pre-processed to a known buffer layout, and the client is\n\t * optimized for that buffer layout, this total will be optimistic.\n\t */\n\tUPLOAD = 'upload',\n\n\t/**\n\t * Expected number of vertices uploaded to the GPU, assuming that a client\n\t * uploads each unique {@link Primitive} individually, duplicating vertex\n\t * attribute {@link Accessor Accessors} shared by multiple primitives, but\n\t * never uploading the same Mesh or Primitive to GPU memory more than once.\n\t */\n\tUPLOAD_NAIVE = 'upload-naive',\n\n\t/**\n\t * Total number of unique vertices represented, considering all attributes of\n\t * each vertex, and removing any duplicates. Has no direct relationship to\n\t * runtime characteristics, but may be helpful in identifying asset\n\t * optimization opportunities.\n\t *\n\t * @hidden TODO(feat): Not yet implemented.\n\t * @internal\n\t */\n\tDISTINCT = 'distinct',\n\n\t/**\n\t * Total number of unique vertices represented, considering only vertex\n\t * positions, and removing any duplicates. Has no direct relationship to\n\t * runtime characteristics, but may be helpful in identifying asset\n\t * optimization opportunities.\n\t *\n\t * @hidden TODO(feat): Not yet implemented.\n\t * @internal\n\t */\n\tDISTINCT_POSITION = 'distinct-position',\n\n\t/**\n\t * Number of vertex positions never used by any {@link Primitive}. If all\n\t * vertices are unused, this total will match `UPLOAD`.\n\t */\n\tUNUSED = 'unused',\n}\n\n/**\n * Computes total number of vertices in a {@link Scene}, by the\n * specified method. Totals for the Scene will not necessarily match the sum\n * of the totals for each {@link Mesh} or {@link Primitive} within it. See\n * {@link VertexCountMethod} for available methods.\n */\nexport function getSceneVertexCount(scene: Scene, method: VertexCountMethod): number {\n\treturn _getSubtreeVertexCount(scene, method);\n}\n\n/**\n * Computes total number of vertices in a {@link Node}, by the\n * specified method. Totals for the node will not necessarily match the sum\n * of the totals for each {@link Mesh} or {@link Primitive} within it. See\n * {@link VertexCountMethod} for available methods.\n */\nexport function getNodeVertexCount(node: Node | Scene, method: VertexCountMethod): number {\n\treturn _getSubtreeVertexCount(node, method);\n}\n\nfunction _getSubtreeVertexCount(node: Node | Scene, method: VertexCountMethod): number {\n\tconst instancedMeshes: [number, Mesh][] = [];\n\tconst nonInstancedMeshes: Mesh[] = [];\n\tconst meshes: Mesh[] = [];\n\n\tnode.traverse((node) => {\n\t\tconst mesh = node.getMesh();\n\t\tconst batch = node.getExtension<InstancedMesh>('EXT_mesh_gpu_instancing');\n\t\tif (batch && mesh) {\n\t\t\tmeshes.push(mesh);\n\t\t\tinstancedMeshes.push([batch.listAttributes()[0]!.getCount(), mesh]);\n\t\t} else if (mesh) {\n\t\t\tmeshes.push(mesh);\n\t\t\tnonInstancedMeshes.push(mesh);\n\t\t}\n\t});\n\n\tconst prims = meshes.flatMap((mesh) => mesh.listPrimitives());\n\tconst positions = prims.map((prim) => prim.getAttribute('POSITION')!);\n\tconst uniquePositions = Array.from(new Set(positions));\n\tconst uniqueMeshes = Array.from(new Set(meshes));\n\tconst uniquePrims = Array.from(new Set(uniqueMeshes.flatMap((mesh) => mesh.listPrimitives())));\n\n\tswitch (method) {\n\t\tcase VertexCountMethod.RENDER:\n\t\tcase VertexCountMethod.RENDER_CACHED:\n\t\t\treturn (\n\t\t\t\t_sum(nonInstancedMeshes.map((mesh) => getMeshVertexCount(mesh, method))) +\n\t\t\t\t_sum(instancedMeshes.map(([batch, mesh]) => batch * getMeshVertexCount(mesh, method)))\n\t\t\t);\n\t\tcase VertexCountMethod.UPLOAD_NAIVE:\n\t\t\treturn _sum(uniqueMeshes.map((mesh) => getMeshVertexCount(mesh, method)));\n\t\tcase VertexCountMethod.UPLOAD:\n\t\t\treturn _sum(uniquePositions.map((attribute) => attribute.getCount()));\n\t\tcase VertexCountMethod.DISTINCT:\n\t\tcase VertexCountMethod.DISTINCT_POSITION:\n\t\t\treturn _assertNotImplemented(method);\n\t\tcase VertexCountMethod.UNUSED:\n\t\t\treturn _sumUnused(uniquePrims);\n\t\tdefault:\n\t\t\treturn _assertUnreachable(method);\n\t}\n}\n\n/**\n * Computes total number of vertices in a {@link Mesh}, by the\n * specified method. Totals for the Mesh will not necessarily match the sum\n * of the totals for each {@link Primitive} within it. See\n * {@link VertexCountMethod} for available methods.\n */\nexport function getMeshVertexCount(mesh: Mesh, method: VertexCountMethod): number {\n\tconst prims = mesh.listPrimitives();\n\tconst uniquePrims = Array.from(new Set(prims));\n\tconst uniquePositions = Array.from(new Set(uniquePrims.map((prim) => prim.getAttribute('POSITION')!)));\n\n\tswitch (method) {\n\t\tcase VertexCountMethod.RENDER:\n\t\tcase VertexCountMethod.RENDER_CACHED:\n\t\tcase VertexCountMethod.UPLOAD_NAIVE:\n\t\t\treturn _sum(prims.map((prim) => getPrimitiveVertexCount(prim, method)));\n\t\tcase VertexCountMethod.UPLOAD:\n\t\t\treturn _sum(uniquePositions.map((attribute) => attribute.getCount()));\n\t\tcase VertexCountMethod.DISTINCT:\n\t\tcase VertexCountMethod.DISTINCT_POSITION:\n\t\t\treturn _assertNotImplemented(method);\n\t\tcase VertexCountMethod.UNUSED:\n\t\t\treturn _sumUnused(uniquePrims);\n\t\tdefault:\n\t\t\treturn _assertUnreachable(method);\n\t}\n}\n\n/**\n * Computes total number of vertices in a {@link Primitive}, by the\n * specified method. See {@link VertexCountMethod} for available methods.\n */\nexport function getPrimitiveVertexCount(prim: Primitive, method: VertexCountMethod): number {\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst indices = prim.getIndices();\n\n\tswitch (method) {\n\t\tcase VertexCountMethod.RENDER:\n\t\t\treturn indices ? indices.getCount() : position.getCount();\n\t\tcase VertexCountMethod.RENDER_CACHED:\n\t\t\treturn indices ? new Set(indices.getArray()).size : position.getCount();\n\t\tcase VertexCountMethod.UPLOAD_NAIVE:\n\t\tcase VertexCountMethod.UPLOAD:\n\t\t\treturn position.getCount();\n\t\tcase VertexCountMethod.DISTINCT:\n\t\tcase VertexCountMethod.DISTINCT_POSITION:\n\t\t\treturn _assertNotImplemented(method);\n\t\tcase VertexCountMethod.UNUSED:\n\t\t\treturn indices ? position.getCount() - new Set(indices.getArray()).size : 0;\n\t\tdefault:\n\t\t\treturn _assertUnreachable(method);\n\t}\n}\n\nfunction _sum(values: number[]): number {\n\tlet total = 0;\n\tfor (let i = 0; i < values.length; i++) {\n\t\ttotal += values[i];\n\t}\n\treturn total;\n}\n\nfunction _sumUnused(prims: Primitive[]) {\n\tconst attributeIndexMap = new Map<Accessor, Set<Accessor | null>>();\n\tfor (const prim of prims) {\n\t\tconst position = prim.getAttribute('POSITION')!;\n\t\tconst indices = prim.getIndices();\n\t\tconst indicesSet = attributeIndexMap.get(position) || new Set();\n\t\tindicesSet.add(indices);\n\t\tattributeIndexMap.set(position, indicesSet);\n\t}\n\n\tlet unused = 0;\n\tfor (const [position, indicesSet] of attributeIndexMap) {\n\t\tif (indicesSet.has(null)) continue;\n\n\t\tconst usedIndices = new Uint8Array(position.getCount());\n\t\tfor (const indices of indicesSet as Set<Accessor>) {\n\t\t\tconst indicesArray = indices.getArray()!;\n\t\t\tfor (let i = 0, il = indicesArray.length; i < il; i++) {\n\t\t\t\tusedIndices[indicesArray[i]] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, il = position.getCount(); i < il; i++) {\n\t\t\tif (usedIndices[i] === 0) unused++;\n\t\t}\n\t}\n\n\treturn unused;\n}\n\nfunction _assertNotImplemented<T>(x: unknown): T {\n\tthrow new Error(`Not implemented: ${x}`);\n}\n\nfunction _assertUnreachable<T>(x: never): T {\n\tthrow new Error(`Unexpected value: ${x}`);\n}\n", "import { type Accessor, BufferUtils, type Primitive } from '@gltf-transform/core';\nimport { deepListAttributes } from './utils.js';\n\n/** Flags 'empty' values in a Uint32Array index. */\nexport const EMPTY_U32: number = 2 ** 32 - 1;\n\nexport class VertexStream {\n\tprivate attributes: { u8: Uint8Array; byteStride: number; paddedByteStride: number }[] = [];\n\n\t/** Temporary vertex views in 4-byte-aligned memory. */\n\tprivate u8: Uint8Array;\n\tprivate u32: Uint32Array;\n\n\tconstructor(prim: Primitive) {\n\t\tlet byteStride = 0;\n\t\tfor (const attribute of deepListAttributes(prim)) {\n\t\t\tbyteStride += this._initAttribute(attribute);\n\t\t}\n\t\tthis.u8 = new Uint8Array(byteStride);\n\t\tthis.u32 = new Uint32Array(this.u8.buffer);\n\t}\n\n\tprivate _initAttribute(attribute: Accessor): number {\n\t\tconst array = attribute.getArray()!;\n\t\tconst u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n\t\tconst byteStride = attribute.getElementSize() * attribute.getComponentSize();\n\t\tconst paddedByteStride = BufferUtils.padNumber(byteStride);\n\t\tthis.attributes.push({ u8, byteStride, paddedByteStride });\n\t\treturn paddedByteStride;\n\t}\n\n\thash(index: number): number {\n\t\t// Load vertex into 4-byte-aligned view.\n\t\tlet byteOffset = 0;\n\t\tfor (const { u8, byteStride, paddedByteStride } of this.attributes) {\n\t\t\tfor (let i = 0; i < paddedByteStride; i++) {\n\t\t\t\tif (i < byteStride) {\n\t\t\t\t\tthis.u8[byteOffset + i] = u8[index * byteStride + i];\n\t\t\t\t} else {\n\t\t\t\t\tthis.u8[byteOffset + i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbyteOffset += paddedByteStride;\n\t\t}\n\n\t\t// Compute hash.\n\t\treturn murmurHash2(0, this.u32);\n\t}\n\n\tequal(a: number, b: number): boolean {\n\t\tfor (const { u8, byteStride } of this.attributes) {\n\t\t\tfor (let j = 0; j < byteStride; j++) {\n\t\t\t\tif (u8[a * byteStride + j] !== u8[b * byteStride + j]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\n/**\n * References:\n * - https://github.com/mikolalysenko/murmurhash-js/blob/f19136e9f9c17f8cddc216ca3d44ec7c5c502f60/murmurhash2_gc.js#L14\n * - https://github.com/zeux/meshoptimizer/blob/e47e1be6d3d9513153188216455bdbed40a206ef/src/indexgenerator.cpp#L12\n */\nfunction murmurHash2(h: number, key: Uint32Array): number {\n\t// MurmurHash2\n\tconst m = 0x5bd1e995;\n\tconst r = 24;\n\n\tfor (let i = 0, il = key.length; i < il; i++) {\n\t\tlet k = key[i];\n\n\t\tk = Math.imul(k, m) >>> 0;\n\t\tk = (k ^ (k >> r)) >>> 0;\n\t\tk = Math.imul(k, m) >>> 0;\n\n\t\th = Math.imul(h, m) >>> 0;\n\t\th = (h ^ k) >>> 0;\n\t}\n\n\treturn h;\n}\n\nexport function hashLookup(\n\ttable: Uint32Array,\n\tbuckets: number,\n\tstream: VertexStream,\n\tkey: number,\n\tempty: number = EMPTY_U32,\n): number {\n\tconst hashmod = buckets - 1;\n\tconst hashval = stream.hash(key);\n\tlet bucket = hashval & hashmod;\n\n\tfor (let probe = 0; probe <= hashmod; probe++) {\n\t\tconst item = table[bucket];\n\n\t\tif (item === empty || stream.equal(item, key)) {\n\t\t\treturn bucket;\n\t\t}\n\n\t\tbucket = (bucket + probe + 1) & hashmod; // Hash collision.\n\t}\n\n\tthrow new Error('Hash table full.');\n}\n", "import {\n\ttype Accessor,\n\tDocument,\n\ttype Primitive,\n\ttype TypedArray,\n\ttype TypedArrayConstructor,\n} from '@gltf-transform/core';\nimport { getPrimitiveVertexCount, VertexCountMethod } from './get-vertex-count.js';\nimport { EMPTY_U32 } from './hash-table.js';\nimport { createIndices, createIndicesEmpty, deepListAttributes, shallowCloneAccessor } from './utils.js';\n\n/**\n * Rewrites a {@link Primitive} such that all unused vertices in its vertex\n * attributes are removed. When multiple Primitives share vertex attributes,\n * each indexing only a few, compaction can be used to produce Primitives\n * each having smaller, independent vertex streams instead.\n *\n * Regardless of whether the Primitive is indexed or contains unused vertices,\n * compaction will clone every {@link Accessor}. The resulting Primitive will\n * share no Accessors with other Primitives, allowing later changes to\n * the vertex stream to be applied in isolation.\n *\n * Example:\n *\n * ```javascript\n * import { compactPrimitive, transformMesh } from '@gltf-transform/functions';\n * import { fromTranslation } from 'gl-matrix/mat4';\n *\n * const mesh = document.getRoot().listMeshes().find((mesh) => mesh.getName() === 'MyMesh');\n * const prim = mesh.listPrimitives().find((prim) => { ... });\n *\n * // Compact primitive, removing unused vertices and detaching shared vertex\n * // attributes. Without compaction, `transformPrimitive` might affect other\n * // primitives sharing the same vertex attributes.\n * compactPrimitive(prim);\n *\n * // Transform primitive vertices, y += 10.\n * transformPrimitive(prim, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * Parameters 'remap' and 'dstVertexCount' are optional. When either is\n * provided, the other must be provided as well. If one or both are missing,\n * both will be computed from the mesh indices.\n *\n * @param remap - Mapping. Array index represents vertex index in the source\n *\t\tattributes, array value represents index in the resulting compacted\n *\t\tprimitive. When omitted, calculated from indices.\n * @param dstVertexcount - Number of unique vertices in compacted primitive.\n *\t\tWhen omitted, calculated from indices.\n */\n// TODO(cleanup): Additional signatures currently break greendoc/parse.\n// export function compactPrimitive(prim: Primitive): Primitive;\n// export function compactPrimitive(prim: Primitive, remap: TypedArray, dstVertexCount: number): Primitive;\nexport function compactPrimitive(prim: Primitive, remap?: TypedArray, dstVertexCount?: number): Primitive {\n\tconst document = Document.fromGraph(prim.getGraph())!;\n\n\tif (!remap || !dstVertexCount) {\n\t\t[remap, dstVertexCount] = createCompactPlan(prim);\n\t}\n\n\t// Remap indices.\n\n\tconst srcIndices = prim.getIndices();\n\tconst srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n\tconst srcIndicesCount = getPrimitiveVertexCount(prim, VertexCountMethod.RENDER);\n\n\tconst dstIndices = document.createAccessor();\n\tconst dstIndicesCount = srcIndicesCount; // primitive count does not change.\n\tconst dstIndicesArray = createIndicesEmpty(dstIndicesCount, dstVertexCount);\n\n\tfor (let i = 0; i < dstIndicesCount; i++) {\n\t\tdstIndicesArray[i] = remap[srcIndicesArray ? srcIndicesArray[i] : i];\n\t}\n\n\tprim.setIndices(dstIndices.setArray(dstIndicesArray));\n\n\t// Remap vertices.\n\n\tconst srcAttributesPrev = deepListAttributes(prim);\n\n\tfor (const srcAttribute of prim.listAttributes()) {\n\t\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute);\n\t\tcompactAttribute(srcAttribute, srcIndices, remap, dstAttribute, dstVertexCount);\n\t\tprim.swap(srcAttribute, dstAttribute);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const srcAttribute of target.listAttributes()) {\n\t\t\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute);\n\t\t\tcompactAttribute(srcAttribute, srcIndices, remap, dstAttribute, dstVertexCount);\n\t\t\ttarget.swap(srcAttribute, dstAttribute);\n\t\t}\n\t}\n\n\t// Clean up accessors.\n\n\tif (srcIndices && srcIndices.listParents().length === 1) {\n\t\tsrcIndices.dispose();\n\t}\n\tfor (const srcAttribute of srcAttributesPrev) {\n\t\tif (srcAttribute.listParents().length === 1) {\n\t\t\tsrcAttribute.dispose();\n\t\t}\n\t}\n\n\treturn prim;\n}\n\n/**\n * Copies srcAttribute to dstAttribute, using the given indices and remap (srcIndex -> dstIndex).\n * Any existing array in dstAttribute is replaced. Vertices not used by the index are eliminated,\n * leaving a compact attribute.\n * @hidden\n * @internal\n */\nexport function compactAttribute(\n\tsrcAttribute: Accessor,\n\tsrcIndices: Accessor | null,\n\tremap: TypedArray,\n\tdstAttribute: Accessor,\n\tdstVertexCount: number,\n): Accessor {\n\tconst elementSize = srcAttribute.getElementSize();\n\tconst srcArray = srcAttribute.getArray()!;\n\tconst srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n\tconst srcIndicesCount = srcIndices ? srcIndices.getCount() : srcAttribute.getCount();\n\tconst dstArray = new (srcArray.constructor as TypedArrayConstructor)(dstVertexCount * elementSize);\n\tconst dstDone = new Uint8Array(dstVertexCount);\n\n\tfor (let i = 0; i < srcIndicesCount; i++) {\n\t\tconst srcIndex = srcIndicesArray ? srcIndicesArray[i] : i;\n\t\tconst dstIndex = remap[srcIndex];\n\t\tif (dstDone[dstIndex]) continue;\n\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[dstIndex * elementSize + j] = srcArray[srcIndex * elementSize + j];\n\t\t}\n\n\t\tdstDone[dstIndex] = 1;\n\t}\n\n\treturn dstAttribute.setArray(dstArray);\n}\n\n/**\n * Creates a 'remap' and 'dstVertexCount' plan for indexed primitives,\n * such that they can be rewritten with {@link compactPrimitive} removing\n * any non-rendered vertices.\n * @hidden\n * @internal\n */\nfunction createCompactPlan(prim: Primitive): [Uint32Array, number] {\n\tconst srcVertexCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n\n\tconst indices = prim.getIndices();\n\tconst indicesArray = indices ? indices.getArray() : null;\n\tif (!indices || !indicesArray) {\n\t\treturn [createIndices(srcVertexCount, 1_000_000) as Uint32Array, srcVertexCount];\n\t}\n\n\tconst remap = new Uint32Array(srcVertexCount).fill(EMPTY_U32);\n\n\tlet dstVertexCount = 0;\n\n\tfor (let i = 0; i < indicesArray.length; i++) {\n\t\tconst srcIndex = indicesArray[i];\n\t\tif (remap[srcIndex] === EMPTY_U32) {\n\t\t\tremap[srcIndex] = dstVertexCount++;\n\t\t}\n\t}\n\n\treturn [remap, dstVertexCount];\n}\n", "import * as glMatrix from \"./common.js\";\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\n\nexport function translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nexport var sub = subtract;", "import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();", "import { Document, Primitive, type Transform } from '@gltf-transform/core';\nimport { compactPrimitive } from './compact-primitive.js';\nimport { getPrimitiveVertexCount, VertexCountMethod } from './get-vertex-count.js';\nimport { EMPTY_U32, hashLookup, VertexStream } from './hash-table.js';\nimport { assignDefaults, ceilPowerOfTwo, createTransform, deepDisposePrimitive, formatDeltaOp } from './utils.js';\n\n/**\n * CONTRIBUTOR NOTES\n *\n * Ideally a weld() implementation should be fast, robust, and tunable. The\n * writeup below tracks my attempts to solve for these constraints.\n *\n * (Approach #1) Follow the mergeVertices() implementation of three.js,\n * hashing vertices with a string concatenation of all vertex attributes.\n * The approach does not allow per-attribute tolerance in local units.\n *\n * (Approach #2) Sort points along the X axis, then make cheaper\n * searches up/down the sorted list for merge candidates. While this allows\n * simpler comparison based on specified tolerance, it's much slower, even\n * for cases where choice of the X vs. Y or Z axes is reasonable.\n *\n * (Approach #3) Attempted a Delaunay triangulation in three dimensions,\n * expecting it would be an n * log(n) algorithm, but the only implementation\n * I found (with delaunay-triangulate) appeared to be much slower than that,\n * and was notably slower than the sort-based approach, just building the\n * Delaunay triangulation alone.\n *\n * (Approach #4) Hybrid of (1) and (2), assigning vertices to a spatial\n * grid, then searching the local neighborhood (27 cells) for weld candidates.\n *\n * (Approach #5) Based on Meshoptimizer's implementation, when tolerance=0\n * use a hashtable to find bitwise-equal vertices quickly. Vastly faster than\n * previous approaches, but without tolerance options.\n *\n * RESULTS: For the \"Lovecraftian\" sample model linked below, after joining,\n * a primitive with 873,000 vertices can be welded down to 230,000 vertices.\n * https://sketchfab.com/3d-models/sculpt-january-day-19-lovecraftian-34ad2501108e4fceb9394f5b816b9f42\n *\n * - (1) Not tested, but prior results suggest not robust enough.\n * - (2) 30s\n * - (3) 660s\n * - (4) 5s exhaustive, 1.5s non-exhaustive\n * - (5) 0.2s\n *\n * As of April 2024, the lossy weld was removed, leaving only approach #5. An\n * upcoming Meshoptimizer release will include a simplifyWithAttributes\n * function allowing simplification with weighted consideration of vertex\n * attributes, which I hope to support. With that, weld() may remain faster,\n * simpler, and more maintainable.\n */\n\nconst NAME = 'weld';\n\n/** Options for the {@link weld} function. */\nexport interface WeldOptions {\n\t/** Whether to overwrite existing indices. */\n\toverwrite?: boolean;\n}\n\nexport const WELD_DEFAULTS: Required<WeldOptions> = {\n\toverwrite: true,\n};\n\n/**\n * Welds {@link Primitive Primitives}, merging bitwise identical vertices. When\n * merged and indexed, data is shared more efficiently between vertices. File size\n * can be reduced, and the GPU uses the vertex cache more efficiently.\n *\n * Example:\n *\n * ```javascript\n * import { weld, getSceneVertexCount, VertexCountMethod } from '@gltf-transform/functions';\n *\n * const scene = document.getDefaultScene();\n * const srcVertexCount = getSceneVertexCount(scene, VertexCountMethod.UPLOAD);\n * await document.transform(weld());\n * const dstVertexCount = getSceneVertexCount(scene, VertexCountMethod.UPLOAD);\n * ```\n *\n * @category Transforms\n */\nexport function weld(_options: WeldOptions = WELD_DEFAULTS): Transform {\n\tconst options = assignDefaults(WELD_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tweldPrimitive(prim, options);\n\n\t\t\t\tif (getPrimitiveVertexCount(prim, VertexCountMethod.RENDER) === 0) {\n\t\t\t\t\tdeepDisposePrimitive(prim);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mesh.listPrimitives().length === 0) mesh.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Welds a {@link Primitive}, merging bitwise identical vertices. When merged\n * and indexed, data is shared more efficiently between vertices. File size can\n * be reduced, and the GPU uses the vertex cache more efficiently.\n *\n * Example:\n *\n * ```javascript\n * import { weldPrimitive, getMeshVertexCount, VertexCountMethod } from '@gltf-transform/functions';\n *\n * const mesh = document.getRoot().listMeshes()\n * \t.find((mesh) => mesh.getName() === 'Gizmo');\n *\n * const srcVertexCount = getMeshVertexCount(mesh, VertexCountMethod.UPLOAD);\n *\n * for (const prim of mesh.listPrimitives()) {\n *   weldPrimitive(prim);\n * }\n *\n * const dstVertexCount = getMeshVertexCount(mesh, VertexCountMethod.UPLOAD);\n * ```\n */\nexport function weldPrimitive(prim: Primitive, _options: WeldOptions = WELD_DEFAULTS): void {\n\tconst graph = prim.getGraph();\n\tconst document = Document.fromGraph(graph)!;\n\tconst logger = document.getLogger();\n\tconst options = { ...WELD_DEFAULTS, ..._options };\n\n\tif (prim.getIndices() && !options.overwrite) return;\n\tif (prim.getMode() === Primitive.Mode.POINTS) return;\n\n\tconst srcVertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst srcIndices = prim.getIndices();\n\tconst srcIndicesArray = srcIndices?.getArray();\n\tconst srcIndicesCount = srcIndices ? srcIndices.getCount() : srcVertexCount;\n\n\tconst stream = new VertexStream(prim);\n\tconst tableSize = ceilPowerOfTwo(srcVertexCount + srcVertexCount / 4);\n\tconst table = new Uint32Array(tableSize).fill(EMPTY_U32);\n\tconst writeMap = new Uint32Array(srcVertexCount).fill(EMPTY_U32); // oldIndex  newIndex\n\n\t// (1) Compare and identify indices to weld.\n\n\tlet dstVertexCount = 0;\n\n\tfor (let i = 0; i < srcIndicesCount; i++) {\n\t\tconst srcIndex = srcIndicesArray ? srcIndicesArray[i] : i;\n\t\tif (writeMap[srcIndex] !== EMPTY_U32) continue;\n\n\t\tconst hashIndex = hashLookup(table, tableSize, stream, srcIndex, EMPTY_U32);\n\t\tconst dstIndex = table[hashIndex];\n\n\t\tif (dstIndex === EMPTY_U32) {\n\t\t\ttable[hashIndex] = srcIndex;\n\t\t\twriteMap[srcIndex] = dstVertexCount++;\n\t\t} else {\n\t\t\twriteMap[srcIndex] = writeMap[dstIndex];\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n\n\tcompactPrimitive(prim, writeMap, dstVertexCount);\n}\n", "import { Accessor, MathUtils, type mat4, Primitive, type vec3 } from '@gltf-transform/core';\nimport { create as createMat3, fromMat4, invert, transpose } from 'gl-matrix/mat3';\nimport { determinant } from 'gl-matrix/mat4';\nimport { create as createVec3, normalize as normalizeVec3, transformMat3, transformMat4 } from 'gl-matrix/vec3';\nimport { weldPrimitive } from './weld.js';\n\nconst { FLOAT } = Accessor.ComponentType;\n\n/**\n * Applies a transform matrix to a {@link Primitive}.\n *\n * All vertex attributes on the Primitive and its\n * {@link PrimitiveTarget PrimitiveTargets} are modified in place. If vertex\n * streams are shared with other Primitives, and overwriting the shared vertex\n * attributes is not desired, use {@link compactPrimitive} to pre-process\n * the Primitive or call {@link transformMesh} instead.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformPrimitive } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformPrimitive(prim, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param prim\n * @param matrix\n */\nexport function transformPrimitive(prim: Primitive, matrix: mat4): void {\n\t// Apply transform to base attributes.\n\tconst position = prim.getAttribute('POSITION');\n\tif (position) {\n\t\tapplyMatrix(matrix, position);\n\t}\n\n\tconst normal = prim.getAttribute('NORMAL');\n\tif (normal) {\n\t\tapplyNormalMatrix(matrix, normal);\n\t}\n\n\tconst tangent = prim.getAttribute('TANGENT');\n\tif (tangent) {\n\t\tapplyTangentMatrix(matrix, tangent);\n\t}\n\n\t// Apply transform to morph attributes.\n\tfor (const target of prim.listTargets()) {\n\t\tconst position = target.getAttribute('POSITION');\n\t\tif (position) {\n\t\t\tapplyMatrix(matrix, position);\n\t\t}\n\n\t\tconst normal = target.getAttribute('NORMAL');\n\t\tif (normal) {\n\t\t\tapplyNormalMatrix(matrix, normal);\n\t\t}\n\n\t\tconst tangent = target.getAttribute('TANGENT');\n\t\tif (tangent) {\n\t\t\tapplyTangentMatrix(matrix, tangent);\n\t\t}\n\t}\n\n\t// Reverse winding order if scale is negative.\n\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/NegativeScaleTest\n\tif (determinant(matrix) < 0) {\n\t\treversePrimitiveWindingOrder(prim);\n\t}\n}\n\nfunction applyMatrix(matrix: mat4, attribute: Accessor) {\n\tconst componentType = attribute.getComponentType();\n\tconst normalized = attribute.getNormalized();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = componentType === FLOAT ? srcArray : new Float32Array(srcArray.length);\n\n\tconst vector = createVec3() as vec3;\n\tfor (let i = 0, il = attribute.getCount(); i < il; i++) {\n\t\tif (normalized) {\n\t\t\tvector[0] = MathUtils.decodeNormalizedInt(srcArray[i * 3], componentType);\n\t\t\tvector[1] = MathUtils.decodeNormalizedInt(srcArray[i * 3 + 1], componentType);\n\t\t\tvector[2] = MathUtils.decodeNormalizedInt(srcArray[i * 3 + 2], componentType);\n\t\t} else {\n\t\t\tvector[0] = srcArray[i * 3];\n\t\t\tvector[1] = srcArray[i * 3 + 1];\n\t\t\tvector[2] = srcArray[i * 3 + 2];\n\t\t}\n\n\t\ttransformMat4(vector, vector, matrix);\n\n\t\tdstArray[i * 3] = vector[0];\n\t\tdstArray[i * 3 + 1] = vector[1];\n\t\tdstArray[i * 3 + 2] = vector[2];\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n\nfunction applyNormalMatrix(matrix: mat4, attribute: Accessor) {\n\tconst array = attribute.getArray()!;\n\tconst normalized = attribute.getNormalized();\n\tconst componentType = attribute.getComponentType();\n\n\tconst normalMatrix = createMat3();\n\tfromMat4(normalMatrix, matrix);\n\tinvert(normalMatrix, normalMatrix);\n\ttranspose(normalMatrix, normalMatrix);\n\n\tconst vector = createVec3() as vec3;\n\tfor (let i = 0, il = attribute.getCount(); i < il; i++) {\n\t\tif (normalized) {\n\t\t\tvector[0] = MathUtils.decodeNormalizedInt(array[i * 3], componentType);\n\t\t\tvector[1] = MathUtils.decodeNormalizedInt(array[i * 3 + 1], componentType);\n\t\t\tvector[2] = MathUtils.decodeNormalizedInt(array[i * 3 + 2], componentType);\n\t\t} else {\n\t\t\tvector[0] = array[i * 3];\n\t\t\tvector[1] = array[i * 3 + 1];\n\t\t\tvector[2] = array[i * 3 + 2];\n\t\t}\n\n\t\ttransformMat3(vector, vector, normalMatrix);\n\t\tnormalizeVec3(vector, vector);\n\n\t\tif (normalized) {\n\t\t\tarray[i * 3] = MathUtils.decodeNormalizedInt(vector[0], componentType);\n\t\t\tarray[i * 3 + 1] = MathUtils.decodeNormalizedInt(vector[1], componentType);\n\t\t\tarray[i * 3 + 2] = MathUtils.decodeNormalizedInt(vector[2], componentType);\n\t\t} else {\n\t\t\tarray[i * 3] = vector[0];\n\t\t\tarray[i * 3 + 1] = vector[1];\n\t\t\tarray[i * 3 + 2] = vector[2];\n\t\t}\n\t}\n}\n\nfunction applyTangentMatrix(matrix: mat4, attribute: Accessor) {\n\tconst array = attribute.getArray()!;\n\tconst normalized = attribute.getNormalized();\n\tconst componentType = attribute.getComponentType();\n\n\tconst v3 = createVec3() as vec3;\n\tfor (let i = 0, il = attribute.getCount(); i < il; i++) {\n\t\tif (normalized) {\n\t\t\tv3[0] = MathUtils.decodeNormalizedInt(array[i * 4], componentType);\n\t\t\tv3[1] = MathUtils.decodeNormalizedInt(array[i * 4 + 1], componentType);\n\t\t\tv3[2] = MathUtils.decodeNormalizedInt(array[i * 4 + 2], componentType);\n\t\t} else {\n\t\t\tv3[0] = array[i * 4];\n\t\t\tv3[1] = array[i * 4 + 1];\n\t\t\tv3[2] = array[i * 4 + 2];\n\t\t}\n\n\t\t// mat4 affine matrix applied to vector, vector interpreted as a direction.\n\t\t// Reference: https://github.com/mrdoob/three.js/blob/9f4de99828c05e71c47e6de0beb4c6e7652e486a/src/math/Vector3.js#L286-L300\n\t\tv3[0] = matrix[0] * v3[0] + matrix[4] * v3[1] + matrix[8] * v3[2];\n\t\tv3[1] = matrix[1] * v3[0] + matrix[5] * v3[1] + matrix[9] * v3[2];\n\t\tv3[2] = matrix[2] * v3[0] + matrix[6] * v3[1] + matrix[10] * v3[2];\n\t\tnormalizeVec3(v3, v3);\n\n\t\tif (normalized) {\n\t\t\tarray[i * 4] = MathUtils.decodeNormalizedInt(v3[0], componentType);\n\t\t\tarray[i * 4 + 1] = MathUtils.decodeNormalizedInt(v3[1], componentType);\n\t\t\tarray[i * 4 + 2] = MathUtils.decodeNormalizedInt(v3[2], componentType);\n\t\t} else {\n\t\t\tarray[i * 4] = v3[0];\n\t\t\tarray[i * 4 + 1] = v3[1];\n\t\t\tarray[i * 4 + 2] = v3[2];\n\t\t}\n\t}\n}\n\nfunction reversePrimitiveWindingOrder(prim: Primitive) {\n\tif (prim.getMode() !== Primitive.Mode.TRIANGLES) return;\n\tif (!prim.getIndices()) weldPrimitive(prim);\n\n\tconst indices = prim.getIndices()!;\n\tfor (let i = 0, il = indices.getCount(); i < il; i += 3) {\n\t\tconst a = indices.getScalar(i);\n\t\tconst c = indices.getScalar(i + 2);\n\t\tindices.setScalar(i, c);\n\t\tindices.setScalar(i + 2, a);\n\t}\n}\n", "import { Mesh, type mat4, Primitive } from '@gltf-transform/core';\nimport { compactPrimitive } from './compact-primitive.js';\nimport { transformPrimitive } from './transform-primitive.js';\n\n/**\n * Applies a transform matrix to every {@link Primitive} in the given {@link Mesh}.\n *\n * For every Primitive in the Mesh, the operation first applies\n * {@link compactPrimitive} to isolate vertex streams, then calls\n * {@link transformPrimitive}. Transformed Mesh will no longer share vertex\n * attributes with any other Meshes  attributes are cloned before\n * transformation.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformMesh } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformMesh(mesh, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param mesh\n * @param matrix\n */\nexport function transformMesh(mesh: Mesh, matrix: mat4): void {\n\t// If primitives or morph targets are shared by other meshes, detach them.\n\tfor (const srcPrim of mesh.listPrimitives()) {\n\t\tconst dstPrim = shallowClonePrimitive(srcPrim, mesh);\n\t\tif (srcPrim !== dstPrim) {\n\t\t\tmesh.removePrimitive(srcPrim).addPrimitive(dstPrim);\n\t\t}\n\t}\n\n\t// Isolate vertex streams, remove unused vertices, and transform.\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tcompactPrimitive(prim);\n\t\ttransformPrimitive(prim, matrix);\n\t}\n}\n\n/**\n * Conditionally clones a {@link Primitive} and its\n * {@link PrimitiveTarget PrimitiveTargets}, if any are shared with other\n * parents. If nothing is shared, nothing is cloned. Accessors and materials\n * are not cloned.\n *\n * @hidden\n * @internal\n */\nfunction shallowClonePrimitive(prim: Primitive, parentMesh: Mesh): Primitive {\n\tconst isSharedPrimitive = prim.listParents().some((parent) => parent instanceof Mesh && parent !== parentMesh);\n\tif (isSharedPrimitive) {\n\t\tprim = prim.clone();\n\t}\n\n\tfor (const target of prim.listTargets()) {\n\t\tconst isSharedTarget = target.listParents().some((parent) => parent instanceof Primitive && parent !== prim);\n\t\tif (isSharedTarget) {\n\t\t\tprim.removeTarget(target).addTarget(target.clone());\n\t\t}\n\t}\n\n\treturn prim;\n}\n", "import { MathUtils, type mat4, type Node } from '@gltf-transform/core';\nimport { multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { transformMesh } from './transform-mesh.js';\n\n// biome-ignore format: Readability.\nconst IDENTITY: mat4 = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n];\n\n/**\n * Clears local transform of the {@link Node}, applying the transform to children and meshes.\n *\n * - Applies transform to children\n * - Applies transform to {@link Mesh mesh}\n * - Resets {@link Light lights}, {@link Camera cameras}, and other attachments to the origin\n *\n * Example:\n *\n * ```typescript\n * import { clearNodeTransform } from '@gltf-transform/functions';\n *\n * node.getTranslation(); //  [ 5, 0, 0 ]\n * node.getMesh(); //  vertex data centered at origin\n *\n * clearNodeTransform(node);\n *\n * node.getTranslation(); //  [ 0, 0, 0 ]\n * node.getMesh(); //  vertex data centered at [ 5, 0, 0 ]\n * ```\n *\n * To clear _all_ transforms of a Node, first clear its inherited transforms with\n * {@link clearNodeParent}, then clear the local transform with {@link clearNodeTransform}.\n */\nexport function clearNodeTransform(node: Node): Node {\n\tconst mesh = node.getMesh();\n\tconst localMatrix = node.getMatrix();\n\n\tif (mesh && !MathUtils.eq(localMatrix, IDENTITY)) {\n\t\ttransformMesh(mesh, localMatrix);\n\t}\n\n\tfor (const child of node.listChildren()) {\n\t\tconst matrix = child.getMatrix();\n\t\tmultiplyMat4(matrix, matrix, localMatrix);\n\t\tchild.setMatrix(matrix);\n\t}\n\n\treturn node.setMatrix(IDENTITY);\n}\n", "import { ComponentTypeToTypedArray, Document, Primitive } from '@gltf-transform/core';\nimport { getGLPrimitiveCount, shallowCloneAccessor } from './utils.js';\nimport { weldPrimitive } from './weld.js';\n\nconst { LINES, LINE_STRIP, LINE_LOOP, TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN } = Primitive.Mode;\n\n/**\n * Converts a LINE_STRIP or LINE_LOOP {@link Primitive} to LINES, which is\n * more widely supported. Any other topology given as input (points or\n * triangles) will throw an error.\n *\n * Example:\n *\n * ```javascript\n * import { convertPrimitiveToLines } from '@gltf-transform/functions';\n *\n * console.log(prim.getMode()); // 2 (LINE_LOOP)\n * convertPrimitiveToLines(prim);\n * console.log(prim.getMode()); // 1 (LINES)\n * ```\n */\nexport function convertPrimitiveToLines(prim: Primitive): void {\n\tconst graph = prim.getGraph();\n\tconst document = Document.fromGraph(graph)!;\n\n\t// Ensure indexed primitive.\n\tif (!prim.getIndices()) {\n\t\tweldPrimitive(prim);\n\t}\n\n\t// Allocate indices new GL primitives.\n\tconst srcIndices = prim.getIndices()!;\n\tconst srcIndicesArray = srcIndices.getArray()!;\n\tconst dstGLPrimitiveCount = getGLPrimitiveCount(prim);\n\tconst IndicesArray = ComponentTypeToTypedArray[srcIndices.getComponentType()];\n\tconst dstIndicesArray = new IndicesArray(dstGLPrimitiveCount * 2);\n\n\t// Generate GL primitives.\n\tconst srcMode = prim.getMode();\n\tif (srcMode === LINE_STRIP) {\n\t\t// https://glasnost.itcarlow.ie/~powerk/opengl/primitives/primitives.htm\n\t\tfor (let i = 0; i < dstGLPrimitiveCount; i++) {\n\t\t\tdstIndicesArray[i * 2] = srcIndicesArray[i];\n\t\t\tdstIndicesArray[i * 2 + 1] = srcIndicesArray[i + 1];\n\t\t}\n\t} else if (srcMode === LINE_LOOP) {\n\t\t// https://glasnost.itcarlow.ie/~powerk/opengl/primitives/primitives.htm\n\t\tfor (let i = 0; i < dstGLPrimitiveCount; i++) {\n\t\t\tif (i < dstGLPrimitiveCount - 1) {\n\t\t\t\tdstIndicesArray[i * 2] = srcIndicesArray[i];\n\t\t\t\tdstIndicesArray[i * 2 + 1] = srcIndicesArray[i + 1];\n\t\t\t} else {\n\t\t\t\tdstIndicesArray[i * 2] = srcIndicesArray[i];\n\t\t\t\tdstIndicesArray[i * 2 + 1] = srcIndicesArray[0];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tthrow new Error('Only LINE_STRIP and LINE_LOOP may be converted to LINES.');\n\t}\n\n\t// Update prim mode and indices.\n\tprim.setMode(LINES);\n\tconst root = document.getRoot();\n\tif (srcIndices.listParents().some((parent) => parent !== root && parent !== prim)) {\n\t\tprim.setIndices(shallowCloneAccessor(document, srcIndices).setArray(dstIndicesArray));\n\t} else {\n\t\tsrcIndices.setArray(dstIndicesArray);\n\t}\n}\n\n/**\n * Converts a TRIANGLE_STRIP or TRIANGLE_LOOP {@link Primitive} to TRIANGLES,\n * which is more widely supported. Any other topology given as input (points or\n * lines) will throw an error.\n *\n * Example:\n *\n * ```javascript\n * import { convertPrimitiveToTriangles } from '@gltf-transform/functions';\n *\n * console.log(prim.getMode()); // 5 (TRIANGLE_STRIP)\n * convertPrimitiveToTriangles(prim);\n * console.log(prim.getMode()); // 4 (TRIANGLES)\n * ```\n */\nexport function convertPrimitiveToTriangles(prim: Primitive): void {\n\tconst graph = prim.getGraph();\n\tconst document = Document.fromGraph(graph)!;\n\n\t// Ensure indexed primitive.\n\tif (!prim.getIndices()) {\n\t\tweldPrimitive(prim);\n\t}\n\n\t// Allocate indices new GL primitives.\n\tconst srcIndices = prim.getIndices()!;\n\tconst srcIndicesArray = srcIndices.getArray()!;\n\tconst dstGLPrimitiveCount = getGLPrimitiveCount(prim);\n\tconst IndicesArray = ComponentTypeToTypedArray[srcIndices.getComponentType()];\n\tconst dstIndicesArray = new IndicesArray(dstGLPrimitiveCount * 3);\n\n\t// Generate GL primitives.\n\tconst srcMode = prim.getMode();\n\tif (srcMode === TRIANGLE_STRIP) {\n\t\t// https://en.wikipedia.org/wiki/Triangle_strip\n\t\tfor (let i = 0, il = srcIndicesArray.length; i < il - 2; i++) {\n\t\t\tif (i % 2) {\n\t\t\t\tdstIndicesArray[i * 3] = srcIndicesArray[i + 1];\n\t\t\t\tdstIndicesArray[i * 3 + 1] = srcIndicesArray[i];\n\t\t\t\tdstIndicesArray[i * 3 + 2] = srcIndicesArray[i + 2];\n\t\t\t} else {\n\t\t\t\tdstIndicesArray[i * 3] = srcIndicesArray[i];\n\t\t\t\tdstIndicesArray[i * 3 + 1] = srcIndicesArray[i + 1];\n\t\t\t\tdstIndicesArray[i * 3 + 2] = srcIndicesArray[i + 2];\n\t\t\t}\n\t\t}\n\t} else if (srcMode === TRIANGLE_FAN) {\n\t\t// https://en.wikipedia.org/wiki/Triangle_fan\n\t\tfor (let i = 0; i < dstGLPrimitiveCount; i++) {\n\t\t\tdstIndicesArray[i * 3] = srcIndicesArray[0];\n\t\t\tdstIndicesArray[i * 3 + 1] = srcIndicesArray[i + 1];\n\t\t\tdstIndicesArray[i * 3 + 2] = srcIndicesArray[i + 2];\n\t\t}\n\t} else {\n\t\tthrow new Error('Only TRIANGLE_STRIP and TRIANGLE_FAN may be converted to TRIANGLES.');\n\t}\n\n\t// Update prim mode and indices.\n\tprim.setMode(TRIANGLES);\n\tconst root = document.getRoot();\n\tif (srcIndices.listParents().some((parent) => parent !== root && parent !== prim)) {\n\t\tprim.setIndices(shallowCloneAccessor(document, srcIndices).setArray(dstIndicesArray));\n\t} else {\n\t\tsrcIndices.setArray(dstIndicesArray);\n\t}\n}\n", "import {\n\ttype Accessor,\n\tBufferUtils,\n\ttype Document,\n\ttype Material,\n\ttype Mesh,\n\tPrimitive,\n\ttype PrimitiveTarget,\n\ttype Property,\n\tPropertyType,\n\tRoot,\n\ttype Skin,\n\ttype Texture,\n\ttype Transform,\n} from '@gltf-transform/core';\nimport { assignDefaults, createTransform, shallowEqualsArray } from './utils.js';\n\nconst NAME = 'dedup';\n\nexport interface DedupOptions {\n\t/** Keep properties with unique names, even if they are duplicates. */\n\tkeepUniqueNames?: boolean;\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes?: string[];\n}\n\nconst DEDUP_DEFAULTS: Required<DedupOptions> = {\n\tkeepUniqueNames: false,\n\tpropertyTypes: [\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.MESH,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.MATERIAL,\n\t\tPropertyType.SKIN,\n\t],\n};\n\n/**\n * Removes duplicate {@link Accessor}, {@link Mesh}, {@link Texture}, and {@link Material}\n * properties. Partially based on a\n * [gist by mattdesl](https://gist.github.com/mattdesl/aea40285e2d73916b6b9101b36d84da8). Only\n * accessors in mesh primitives, morph targets, and animation samplers are processed.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listMeshes(); //  [Mesh, Mesh, Mesh]\n *\n * await document.transform(dedup({propertyTypes: [PropertyType.MESH]}));\n *\n * document.getRoot().listMeshes(); //  [Mesh]\n * ```\n *\n * @category Transforms\n */\nexport function dedup(_options: DedupOptions = DEDUP_DEFAULTS): Transform {\n\tconst options = assignDefaults(DEDUP_DEFAULTS, _options);\n\n\tconst propertyTypes = new Set(options.propertyTypes);\n\tfor (const propertyType of options.propertyTypes) {\n\t\tif (!DEDUP_DEFAULTS.propertyTypes.includes(propertyType)) {\n\t\t\tthrow new Error(`${NAME}: Unsupported deduplication on type \"${propertyType}\".`);\n\t\t}\n\t}\n\n\treturn createTransform(NAME, (document: Document): void => {\n\t\tconst logger = document.getLogger();\n\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) dedupAccessors(document);\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) dedupImages(document, options);\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) dedupMaterials(document, options);\n\t\tif (propertyTypes.has(PropertyType.MESH)) dedupMeshes(document, options);\n\t\tif (propertyTypes.has(PropertyType.SKIN)) dedupSkins(document, options);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction dedupAccessors(document: Document): void {\n\tconst logger = document.getLogger();\n\n\t// Find all accessors used for mesh and animation data.\n\tconst indicesMap = new Map<string, Set<Accessor>>();\n\tconst attributeMap = new Map<string, Set<Accessor>>();\n\tconst inputMap = new Map<string, Set<Accessor>>();\n\tconst outputMap = new Map<string, Set<Accessor>>();\n\n\tconst meshes = document.getRoot().listMeshes();\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => hashAccessor(accessor, attributeMap));\n\t\t\thashAccessor(primitive.getIndices(), indicesMap);\n\t\t});\n\t});\n\n\tfor (const animation of document.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\thashAccessor(sampler.getInput(), inputMap);\n\t\t\thashAccessor(sampler.getOutput(), outputMap);\n\t\t}\n\t}\n\n\t// Add accessor to the appropriate hash group. Hashes are _non-unique_,\n\t// intended to quickly compare everything accept the underlying array.\n\tfunction hashAccessor(accessor: Accessor | null, group: Map<string, Set<Accessor>>): void {\n\t\tif (!accessor) return;\n\n\t\tconst hash = [\n\t\t\taccessor.getCount(),\n\t\t\taccessor.getType(),\n\t\t\taccessor.getComponentType(),\n\t\t\taccessor.getNormalized(),\n\t\t\taccessor.getSparse(),\n\t\t].join(':');\n\n\t\tlet hashSet = group.get(hash);\n\t\tif (!hashSet) group.set(hash, (hashSet = new Set<Accessor>()));\n\t\thashSet.add(accessor);\n\t}\n\n\t// Find duplicate accessors of a given type.\n\tfunction detectDuplicates(accessors: Accessor[], duplicates: Map<Accessor, Accessor>): void {\n\t\tfor (let i = 0; i < accessors.length; i++) {\n\t\t\tconst a = accessors[i];\n\t\t\tconst aData = BufferUtils.toView(a.getArray()!);\n\n\t\t\tif (duplicates.has(a)) continue;\n\n\t\t\tfor (let j = i + 1; j < accessors.length; j++) {\n\t\t\t\tconst b = accessors[j];\n\n\t\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t\t// Just compare the arrays  everything else was covered by the\n\t\t\t\t// hash. Comparing uint8 views is faster than comparing the\n\t\t\t\t// original typed arrays.\n\t\t\t\tif (BufferUtils.equals(aData, BufferUtils.toView(b.getArray()!))) {\n\t\t\t\t\tduplicates.set(b, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlet total = 0;\n\tconst duplicates = new Map<Accessor, Accessor>();\n\tfor (const group of [attributeMap, indicesMap, inputMap, outputMap]) {\n\t\tfor (const hashGroup of group.values()) {\n\t\t\ttotal += hashGroup.size;\n\t\t\tdetectDuplicates(Array.from(hashGroup), duplicates);\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${total} accessors.`);\n\n\t// Dissolve duplicate vertex attributes and indices.\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => {\n\t\t\t\tif (duplicates.has(accessor)) {\n\t\t\t\t\tprimitive.swap(accessor, duplicates.get(accessor) as Accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices && duplicates.has(indices)) {\n\t\t\t\tprimitive.swap(indices, duplicates.get(indices) as Accessor);\n\t\t\t}\n\t\t});\n\t});\n\n\t// Dissolve duplicate animation sampler inputs and outputs.\n\tfor (const animation of document.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (input && duplicates.has(input)) {\n\t\t\t\tsampler.swap(input, duplicates.get(input) as Accessor);\n\t\t\t}\n\t\t\tif (output && duplicates.has(output)) {\n\t\t\t\tsampler.swap(output, duplicates.get(output) as Accessor);\n\t\t\t}\n\t\t}\n\t}\n\n\tArray.from(duplicates.keys()).forEach((accessor) => accessor.dispose());\n}\n\nfunction dedupMeshes(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\n\t// Create Reference -> ID lookup table.\n\tconst refs = new Map<Accessor | Material, number>();\n\troot.listAccessors().forEach((accessor, index) => refs.set(accessor, index));\n\troot.listMaterials().forEach((material, index) => refs.set(material, index));\n\n\t// For each mesh, create a hashkey.\n\tconst numMeshes = root.listMeshes().length;\n\tconst uniqueMeshes = new Map<string, Mesh>();\n\tfor (const src of root.listMeshes()) {\n\t\t// For each mesh, create a hashkey.\n\t\tconst srcKeyItems = [];\n\t\tfor (const prim of src.listPrimitives()) {\n\t\t\tsrcKeyItems.push(createPrimitiveKey(prim, refs));\n\t\t}\n\n\t\t// If another mesh exists with the same key, replace all instances with that, and dispose\n\t\t// of the duplicate. If not, just cache it.\n\t\tlet meshKey = '';\n\t\tif (options.keepUniqueNames) meshKey += src.getName() + ';';\n\t\tmeshKey += srcKeyItems.join(';');\n\n\t\tif (uniqueMeshes.has(meshKey)) {\n\t\t\tconst targetMesh = uniqueMeshes.get(meshKey)!;\n\t\t\tsrc.listParents().forEach((parent) => {\n\t\t\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\t\t\tparent.swap(src, targetMesh);\n\t\t\t\t}\n\t\t\t});\n\t\t\tsrc.dispose();\n\t\t} else {\n\t\t\tuniqueMeshes.set(meshKey, src);\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${numMeshes - uniqueMeshes.size} of ${numMeshes} meshes.`);\n}\n\nfunction dedupImages(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\tconst textures = root.listTextures();\n\tconst duplicates: Map<Texture, Texture> = new Map();\n\n\t// Compare each texture to every other texture  O(n)  and mark duplicates for replacement.\n\tfor (let i = 0; i < textures.length; i++) {\n\t\tconst a = textures[i];\n\t\tconst aData = a.getImage();\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = i + 1; j < textures.length; j++) {\n\t\t\tconst b = textures[j];\n\t\t\tconst bData = b.getImage();\n\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// URIs are intentionally not compared.\n\t\t\tif (a.getMimeType() !== b.getMimeType()) continue;\n\t\t\tif (options.keepUniqueNames && a.getName() !== b.getName()) continue;\n\n\t\t\tconst aSize = a.getSize();\n\t\t\tconst bSize = b.getSize();\n\t\t\tif (!aSize || !bSize) continue;\n\t\t\tif (aSize[0] !== bSize[0]) continue;\n\t\t\tif (aSize[1] !== bSize[1]) continue;\n\t\t\tif (!aData || !bData) continue;\n\t\t\tif (BufferUtils.equals(aData, bData)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${root.listTextures().length} textures.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\nfunction dedupMaterials(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\tconst materials = root.listMaterials();\n\tconst duplicates = new Map<Material, Material>();\n\tconst modifierCache = new Map<Material, boolean>();\n\tconst skip = new Set<string>();\n\n\tif (!options.keepUniqueNames) {\n\t\tskip.add('name');\n\t}\n\n\t// Compare each material to every other material  O(n)  and mark duplicates for replacement.\n\tfor (let i = 0; i < materials.length; i++) {\n\t\tconst a = materials[i];\n\n\t\tif (duplicates.has(a)) continue;\n\t\tif (hasModifier(a, modifierCache)) continue;\n\n\t\tfor (let j = i + 1; j < materials.length; j++) {\n\t\t\tconst b = materials[j];\n\n\t\t\tif (duplicates.has(b)) continue;\n\t\t\tif (hasModifier(b, modifierCache)) continue;\n\n\t\t\tif (a.equals(b, skip)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${materials.length} materials.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\nfunction dedupSkins(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\tconst skins = root.listSkins();\n\tconst duplicates = new Map<Skin, Skin>();\n\tconst skip = new Set(['joints']);\n\n\tif (!options.keepUniqueNames) {\n\t\tskip.add('name');\n\t}\n\n\tfor (let i = 0; i < skins.length; i++) {\n\t\tconst a = skins[i];\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = i + 1; j < skins.length; j++) {\n\t\t\tconst b = skins[j];\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// Check joints with shallow equality, not deep equality.\n\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/RecursiveSkeletons\n\t\t\tif (a.equals(b, skip) && shallowEqualsArray(a.listJoints(), b.listJoints())) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${skins.length} skins.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\n/** Generates a key unique to the content of a primitive or target. */\nfunction createPrimitiveKey(prim: Primitive | PrimitiveTarget, refs: Map<Accessor | Material, number>): string {\n\tconst primKeyItems = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tprimKeyItems.push(semantic + ':' + refs.get(attribute));\n\t}\n\tif (prim instanceof Primitive) {\n\t\tconst indices = prim.getIndices();\n\t\tif (indices) {\n\t\t\tprimKeyItems.push('indices:' + refs.get(indices));\n\t\t}\n\t\tconst material = prim.getMaterial();\n\t\tif (material) {\n\t\t\tprimKeyItems.push('material:' + refs.get(material));\n\t\t}\n\t\tprimKeyItems.push('mode:' + prim.getMode());\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tprimKeyItems.push('target:' + createPrimitiveKey(target, refs));\n\t\t}\n\t}\n\treturn primKeyItems.join(',');\n}\n\n/**\n * Detects dependencies modified by a parent reference, to conservatively prevent merging. When\n * implementing extensions like KHR_animation_pointer, the 'modifyChild' attribute should be added\n * to graph edges connecting the animation channel to the animated target property.\n *\n * NOTICE: Implementation is conservative, and could prevent merging two materials sharing the\n * same animated \"Clearcoat\" ExtensionProperty. While that scenario is possible for an in-memory\n * glTF Transform graph, valid glTF input files do not have that risk.\n */\nfunction hasModifier(prop: Property, cache: Map<Property, boolean>): boolean {\n\tif (cache.has(prop)) return cache.get(prop)!;\n\n\tconst graph = prop.getGraph();\n\tconst visitedNodes = new Set<Property>();\n\tconst edgeQueue = graph.listParentEdges(prop);\n\n\t// Search dependency subtree for 'modifyChild' attribute.\n\twhile (edgeQueue.length > 0) {\n\t\tconst edge = edgeQueue.pop()!;\n\t\tif (edge.getAttributes().modifyChild === true) {\n\t\t\tcache.set(prop, true);\n\t\t\treturn true;\n\t\t}\n\n\t\tconst child = edge.getChild();\n\t\tif (visitedNodes.has(child)) continue;\n\n\t\tfor (const childEdge of graph.listChildEdges(child)) {\n\t\t\tedgeQueue.push(childEdge);\n\t\t}\n\t}\n\n\tcache.set(prop, false);\n\treturn false;\n}\n", "import {\n\ttype Accessor,\n\ttype Document,\n\ttype GLTF,\n\tMathUtils,\n\ttype Primitive,\n\ttype Transform,\n\ttype TypedArray,\n} from '@gltf-transform/core';\nimport { KHRMeshQuantization } from '@gltf-transform/extensions';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'dequantize';\n\n/** Options for the {@link dequantize} function. */\nexport interface DequantizeOptions {\n\t/**\n\t * Pattern (regex) used to filter vertex attribute semantics for quantization.\n\t * Default: `/^((?!JOINTS_).)*$/`.\n\t */\n\tpattern?: RegExp;\n}\n\nconst DEQUANTIZE_DEFAULTS: Required<DequantizeOptions> = {\n\tpattern: /^((?!JOINTS_).)*$/,\n};\n\n/**\n * Dequantize {@link Primitive Primitives}, removing {@link KHRMeshQuantization `KHR_mesh_quantization`}\n * if present. Dequantization will increase the size of the mesh on disk and in memory, but may be\n * necessary for compatibility with applications that don't support quantization.\n *\n * Example:\n *\n * ```javascript\n * import { dequantizePrimitive } from '@gltf-transform/functions';\n *\n * await document.transform(dequantize());\n * ```\n *\n * @category Transforms\n */\nexport function dequantize(_options: DequantizeOptions = DEQUANTIZE_DEFAULTS): Transform {\n\tconst options = assignDefaults(DEQUANTIZE_DEFAULTS, _options);\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tdequantizePrimitive(prim, options);\n\t\t\t}\n\t\t}\n\t\tdoc.createExtension(KHRMeshQuantization).dispose();\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Dequantize a single {@link Primitive}, converting all vertex attributes to float32. Dequantization\n * will increase the size of the mesh on disk and in memory, but may be necessary for compatibility\n * with applications that don't support quantization.\n *\n * Example:\n *\n * ```javascript\n * import { dequantizePrimitive } from '@gltf-transform/functions';\n *\n * const mesh = document.getRoot().listMeshes().find((mesh) => mesh.getName() === 'MyMesh');\n *\n * for (const prim of mesh.listPrimitives()) {\n * \tdequantizePrimitive(prim);\n * }\n * ```\n */\nexport function dequantizePrimitive(prim: Primitive, _options: DequantizeOptions = DEQUANTIZE_DEFAULTS): void {\n\tconst options = assignDefaults(DEQUANTIZE_DEFAULTS, _options);\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (options.pattern.test(semantic)) {\n\t\t\tdequantizeAttribute(prim.getAttribute(semantic)!);\n\t\t}\n\t}\n\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const semantic of target.listSemantics()) {\n\t\t\tif (options.pattern.test(semantic)) {\n\t\t\t\tdequantizeAttribute(target.getAttribute(semantic)!);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function dequantizeAttribute(attribute: Accessor): void {\n\tconst srcArray = attribute.getArray();\n\tif (!srcArray) return;\n\n\tconst dstArray = dequantizeAttributeArray(srcArray, attribute.getComponentType(), attribute.getNormalized());\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n\nexport function dequantizeAttributeArray(\n\tsrcArray: TypedArray,\n\tcomponentType: GLTF.AccessorComponentType,\n\tnormalized: boolean,\n): Float32Array {\n\tconst dstArray = new Float32Array(srcArray.length);\n\n\tfor (let i = 0, il = srcArray.length; i < il; i++) {\n\t\tif (normalized) {\n\t\t\tdstArray[i] = MathUtils.decodeNormalizedInt(srcArray[i], componentType);\n\t\t} else {\n\t\t\tdstArray[i] = srcArray[i];\n\t\t}\n\t}\n\n\treturn dstArray;\n}\n", "import {\n\tDocument,\n\ttype Extension,\n\ttype Graph,\n\ttype Property,\n\ttype PropertyResolver,\n\tPropertyType,\n} from '@gltf-transform/core';\n\nconst { TEXTURE_INFO, ROOT } = PropertyType;\ntype PropertyConstructor = new (g: Graph<Property>) => Property;\n\nconst NO_TRANSFER_TYPES = new Set<string>([TEXTURE_INFO, ROOT]);\n\n/**\n * Clones source {@link Document}, copying all properties and extensions within\n * it. Source document remains unchanged, and the two may be modified\n * independently after cloning.\n *\n * Example:\n *\n * ```javascript\n *\timport { cloneDocument } from '@gltf-transform/functions';\n *\n *\tconst targetDocument = cloneDocument(sourceDocument);\n * ```\n */\nexport function cloneDocument(source: Document): Document {\n\tconst target = new Document().setLogger(source.getLogger());\n\tconst resolve = createDefaultPropertyResolver(target, source);\n\tmergeDocuments(target, source, resolve);\n\n\t// Root properties (name, asset, default scene, extras) are not overwritten by\n\t// mergeDocuments(), and should be explicitly copied when cloning.\n\t// biome-ignore lint/suspicious/noExplicitAny: TODO\n\ttarget.getRoot().copy(source.getRoot(), resolve as any);\n\n\treturn target;\n}\n\n/**\n * Merges contents of source {@link Document} into target Document, without\n * modifying the source. Any extensions missing from the target will be added\n * {@link Scene Scenes} and {@link Buffer Buffers} are not combined \n * the target Document may contain multiple Scenes and Buffers after this\n * operation. These may be cleaned up manually (see {@link unpartition}),\n * or document contents may be merged more granularly using\n * {@link copyToDocument}.\n *\n * Example:\n *\n * ```javascript\n *\timport { mergeDocuments, unpartition } from '@gltf-transform/functions';\n *\n *\t// Merge contents of sourceDocument into targetDocument.\n *\tmergeDocuments(targetDocument, sourceDocument);\n *\n *\t// (Optional) Remove all but one Buffer from the target Document.\n *\tawait targetDocument.transform(unpartition());\n * ```\n *\n * To merge several Scenes into one:\n *\n * ```javascript\n * import { mergeDocuments } from '@gltf-transform/functions';\n *\n * const map = mergeDocuments(targetDocument, sourceDocument);\n *\n * // Find original Scene.\n * const sceneA = targetDocument.getRoot().listScenes()[0];\n *\n * // Find counterpart of the source Scene in the target Document.\n * const sceneB = map.get(sourceDocument.getRoot().listScenes()[0]);\n *\n * // Create a Node, and append source Scene's direct children.\n * const rootNode = targetDocument.createNode()\n *\t\t.setName('SceneB')\n *\t\t.setPosition([10, 0, 0]);\n * for (const node of sceneB.listChildren()) {\n *\t\trootNode.addChild(node);\n * }\n *\n * // Append Node to original Scene, and dispose the empty Scene.\n * sceneA.addChild(rootNode);\n * sceneB.dispose();\n * ```\n */\nexport function mergeDocuments(\n\ttarget: Document,\n\tsource: Document,\n\tresolve?: PropertyResolver<Property>,\n): Map<Property, Property> {\n\tresolve ||= createDefaultPropertyResolver(target, source);\n\n\tfor (const sourceExtension of source.getRoot().listExtensionsUsed()) {\n\t\tconst targetExtension = target.createExtension(sourceExtension.constructor as new (doc: Document) => Extension);\n\t\tif (sourceExtension.isRequired()) targetExtension.setRequired(true);\n\t}\n\n\t// Root properties (name, asset, default scene, extras) are not overwritten.\n\treturn _copyToDocument(target, source, listNonRootProperties(source), resolve);\n}\n\n/**\n * Moves the specified {@link Property Properties} from the source\n * {@link Document} to the target Document, and removes them from the source.\n * Dependencies of the source properties will be copied into the\n * target, but not removed from the source. Returns a Map from source\n * properties to their counterparts in the target Document.\n *\n * Example:\n *\n * ```javascript\n *\timport { moveToDocument, prune } from '@gltf-transform/functions';\n *\n *\t// Move all materials from sourceDocument to targetDocument.\n *\tconst map = moveToDocument(targetDocument, sourceDocument, sourceDocument.listMaterials());\n *\n *\t// Find the new counterpart of `sourceMaterial` in the target Document.\n *\tconst targetMaterial = map.get(sourceMaterial);\n *\n *\t// (Optional) Remove any resources (like Textures) that may now be unused\n *\t// in the source Document after their parent Materials have been moved.\n *\tawait sourceDocument.transform(prune());\n * ```\n *\n * Moving a {@link Mesh}, {@link Animation}, or another resource depending on\n * a {@link Buffer} will create a copy of the source Buffer in the target\n * Document. If the target Document should contain only one Buffer, call\n * {@link unpartition} after moving properties.\n *\n * Repeated use of `moveToDocument` may create multiple copies of some\n * resources, particularly shared dependencies like {@link Texture Textures} or\n * {@link Accessor Accessors}. While duplicates can be cleaned up with\n * {@link dedup}, it is also possible to prevent duplicates by creating and\n * reusing the same resolver for all calls to `moveToDocument`:\n *\n * ```javascript\n *\timport { moveToDocument, createDefaultPropertyResolver } from '@gltf-transform/functions';\n *\n *\tconst resolve = createDefaultPropertyResolver(targetDocument, sourceDocument);\n *\n *\t// Move materials individually, without creating duplicates of shared textures.\n *\tmoveToDocument(targetDocument, sourceDocument, materialA, resolve);\n *\tmoveToDocument(targetDocument, sourceDocument, materialB, resolve);\n *\tmoveToDocument(targetDocument, sourceDocument, materialC, resolve);\n * ```\n *\n * If the transferred properties include {@link ExtensionProperty ExtensionProperties},\n * the associated {@link Extension Extensions} must be added to the target\n * Document first:\n *\n * ```javascript\n *\tfor (const sourceExtension of source.getRoot().listExtensionsUsed()) {\n *\t\tconst targetExtension = target.createExtension(sourceExtension.constructor);\n *\t\tif (sourceExtension.isRequired()) targetExtension.setRequired(true);\n *\t}\n * ```\n *\n * {@link Root} properties cannot be moved.\n *\n * {@link TextureInfo} properties cannot be given in the property list, but\n * are handled automatically when moving a {@link Material}.\n *\n * To copy properties without removing them from the source Document, see\n * {@link copyToDocument}.\n *\n * @experimental\n */\nexport function moveToDocument(\n\ttarget: Document,\n\tsource: Document,\n\tsourceProperties: Property[],\n\tresolve?: PropertyResolver<Property>,\n): Map<Property, Property> {\n\tconst targetProperties = copyToDocument(target, source, sourceProperties, resolve);\n\n\tfor (const property of sourceProperties) {\n\t\tproperty.dispose();\n\t}\n\n\treturn targetProperties;\n}\n\n/**\n * Copies the specified {@link Property Properties} from the source\n * {@link Document} to the target Document, leaving originals in the source.\n * Dependencies of the source properties will also be copied into the\n * target. Returns a Map from source properties to their counterparts in the\n * target Document.\n *\n * Example:\n *\n * ```javascript\n *\timport { copyToDocument } from '@gltf-transform/functions';\n *\n *\t// Copy all materials from sourceDocument to targetDocument.\n *\tconst map = copyToDocument(targetDocument, sourceDocument, sourceDocument.listMaterials());\n *\n *\t// Find the new counterpart of `sourceMaterial` in the target Document.\n *\tconst targetMaterial = map.get(sourceMaterial);\n * ```\n *\n * Copying a {@link Mesh}, {@link Animation}, or another resource depending on\n * a {@link Buffer} will create a copy of the source Buffer in the target\n * Document. If the target Document should contain only one Buffer, call\n * {@link unpartition} after copying properties.\n *\n * Repeated use of `copyToDocument` may create multiple copies of some\n * resources, particularly shared dependencies like {@link Texture Textures} or\n * {@link Accessor Accessors}. While duplicates can be cleaned up with\n * {@link dedup}, it is also possible to prevent duplicates by creating and\n * reusing the same resolver for all calls to `copyToDocument`:\n *\n * ```javascript\n *\timport { copyToDocument, createDefaultPropertyResolver } from '@gltf-transform/functions';\n *\n *\tconst resolve = createDefaultPropertyResolver(targetDocument, sourceDocument);\n *\n *\t// Copy materials individually, without creating duplicates of shared textures.\n *\tcopyToDocument(targetDocument, sourceDocument, materialA, resolve);\n *\tcopyToDocument(targetDocument, sourceDocument, materialB, resolve);\n *\tcopyToDocument(targetDocument, sourceDocument, materialC, resolve);\n * ```\n *\n * If the transferred properties include {@link ExtensionProperty ExtensionProperties},\n * the associated {@link Extension Extensions} must be added to the target\n * Document first:\n *\n * ```javascript\n *\tfor (const sourceExtension of source.getRoot().listExtensionsUsed()) {\n *\t\tconst targetExtension = target.createExtension(sourceExtension.constructor);\n *\t\tif (sourceExtension.isRequired()) targetExtension.setRequired(true);\n *\t}\n * ```\n *\n * {@link Root} properties cannot be copied.\n *\n * {@link TextureInfo} properties cannot be given in the property list, but\n * are handled automatically when copying a {@link Material}.\n *\n * To move properties to the target Document without leaving copies behind in\n * the source Document, use {@link moveToDocument} or dispose the properties\n * after copying.\n *\n * @experimental\n */\nexport function copyToDocument(\n\ttarget: Document,\n\tsource: Document,\n\tsourceProperties: Property[],\n\tresolve?: PropertyResolver<Property>,\n): Map<Property, Property> {\n\tconst sourcePropertyDependencies = new Set<Property>();\n\tfor (const property of sourceProperties) {\n\t\tif (NO_TRANSFER_TYPES.has(property.propertyType)) {\n\t\t\tthrow new Error(`Type \"${property.propertyType}\" cannot be transferred.`);\n\t\t}\n\t\tlistPropertyDependencies(property, sourcePropertyDependencies);\n\t}\n\treturn _copyToDocument(target, source, Array.from(sourcePropertyDependencies), resolve);\n}\n\n/** @internal */\nfunction _copyToDocument(\n\ttarget: Document,\n\tsource: Document,\n\tsourceProperties: Property[],\n\tresolve?: PropertyResolver<Property>,\n): Map<Property, Property> {\n\tresolve ||= createDefaultPropertyResolver(target, source);\n\n\t// Create stub classes for every Property in other Document.\n\tconst propertyMap = new Map<Property, Property>();\n\tfor (const sourceProp of sourceProperties) {\n\t\t// TextureInfo copy handled by Material or ExtensionProperty.\n\t\tif (!propertyMap.has(sourceProp) && sourceProp.propertyType !== TEXTURE_INFO) {\n\t\t\tpropertyMap.set(sourceProp, resolve(sourceProp));\n\t\t}\n\t}\n\n\t// Assemble relationships between Properties.\n\tfor (const [sourceProp, targetProp] of propertyMap.entries()) {\n\t\ttargetProp.copy(sourceProp, resolve);\n\t}\n\n\treturn propertyMap;\n}\n\n/**\n * Creates a default `resolve` implementation. May be used when moving\n * properties between {@link Document Documents} with {@link mergeDocuments},\n * {@link copyToDocument}, and {@link moveToDocument}. When the same resolver\n * is passed to multiple invocations, these functions will reuse previously-\n * transferred resources.\n *\n * @experimental\n */\nexport function createDefaultPropertyResolver(target: Document, source: Document): PropertyResolver<Property> {\n\tconst propertyMap = new Map<Property, Property>([[source.getRoot(), target.getRoot()]]);\n\n\treturn (sourceProp: Property): Property => {\n\t\t// TextureInfo lifecycle is bound to a Material or ExtensionProperty.\n\t\tif (sourceProp.propertyType === TEXTURE_INFO) return sourceProp;\n\n\t\tlet targetProp = propertyMap.get(sourceProp);\n\t\tif (!targetProp) {\n\t\t\t// Create stub class, defer copying properties.\n\t\t\tconst PropertyClass = sourceProp.constructor as PropertyConstructor;\n\t\t\ttargetProp = new PropertyClass(target.getGraph());\n\t\t\tpropertyMap.set(sourceProp, targetProp);\n\t\t}\n\n\t\treturn targetProp;\n\t};\n}\n\n/** @internal */\nfunction listPropertyDependencies(parent: Property, visited: Set<Property>): Set<Property> {\n\tconst graph = parent.getGraph();\n\tconst queue: Property[] = [parent];\n\n\tlet next: Property | undefined;\n\twhile ((next = queue.pop())) {\n\t\tvisited.add(next);\n\t\tfor (const child of graph.listChildren(next)) {\n\t\t\tif (!visited.has(child)) {\n\t\t\t\tqueue.push(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn visited;\n}\n\n/** @internal */\nfunction listNonRootProperties(document: Document): Property[] {\n\tconst visited = new Set<Property>();\n\tfor (const edge of document.getGraph().listEdges()) {\n\t\tvisited.add(edge.getChild());\n\t}\n\treturn Array.from(visited);\n}\n", "import type { Document, Transform } from '@gltf-transform/core';\nimport { KHRDracoMeshCompression } from '@gltf-transform/extensions';\nimport { assignDefaults, createTransform } from './utils.js';\nimport { weld } from './weld.js';\n\nconst NAME = 'draco';\n\nexport interface DracoOptions {\n\tmethod?: 'edgebreaker' | 'sequential';\n\tencodeSpeed?: number;\n\tdecodeSpeed?: number;\n\tquantizePosition?: number;\n\tquantizeNormal?: number;\n\tquantizeColor?: number;\n\tquantizeTexcoord?: number;\n\tquantizeGeneric?: number;\n\tquantizationVolume?: 'mesh' | 'scene';\n}\n\nexport const DRACO_DEFAULTS: Required<DracoOptions> = {\n\tmethod: 'edgebreaker',\n\tencodeSpeed: 5,\n\tdecodeSpeed: 5,\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeColor: 8,\n\tquantizeTexcoord: 12,\n\tquantizeGeneric: 12,\n\tquantizationVolume: 'mesh',\n};\n\n/**\n * Applies Draco compression using {@link KHRDracoMeshCompression KHR_draco_mesh_compression}.\n * Draco compression can reduce the size of triangle geometry.\n *\n * This function is a thin wrapper around the {@link KHRDracoMeshCompression} extension.\n *\n * ### Example\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n * import { KHRDracoMeshCompression } from '@gltf-transform/extensions';\n * import { draco } from '@gltf-transform/functions';\n * import draco3d from 'draco3dgltf';\n *\n * const io = new NodeIO()\n * \t.registerExtensions([KHRDracoMeshCompression])\n * \t.registerDependencies({\n * \t\t'draco3d.encoder': await draco3d.createEncoderModule()\n * \t});\n *\n * await document.transform(\n *   draco({method: 'edgebreaker'})\n * );\n *\n * await io.write('compressed.glb', document);\n * ```\n *\n * Compression is deferred until generating output with an I/O class.\n *\n * @category Transforms\n */\nexport function draco(_options: DracoOptions = DRACO_DEFAULTS): Transform {\n\tconst options = assignDefaults(DRACO_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tawait document.transform(weld());\n\t\tdocument\n\t\t\t.createExtension(KHRDracoMeshCompression)\n\t\t\t.setRequired(true)\n\t\t\t.setEncoderOptions({\n\t\t\t\tmethod:\n\t\t\t\t\toptions.method === 'edgebreaker'\n\t\t\t\t\t\t? KHRDracoMeshCompression.EncoderMethod.EDGEBREAKER\n\t\t\t\t\t\t: KHRDracoMeshCompression.EncoderMethod.SEQUENTIAL,\n\t\t\t\tencodeSpeed: options.encodeSpeed,\n\t\t\t\tdecodeSpeed: options.decodeSpeed,\n\t\t\t\tquantizationBits: {\n\t\t\t\t\tPOSITION: options.quantizePosition,\n\t\t\t\t\tNORMAL: options.quantizeNormal,\n\t\t\t\t\tCOLOR: options.quantizeColor,\n\t\t\t\t\tTEX_COORD: options.quantizeTexcoord,\n\t\t\t\t\tGENERIC: options.quantizeGeneric,\n\t\t\t\t},\n\t\t\t\tquantizationVolume: options.quantizationVolume,\n\t\t\t});\n\t});\n}\n", "import * as glMatrix from \"./common.js\";\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();", "import type { Texture } from '@gltf-transform/core';\n\nconst SRGB_PATTERN = /color|emissive|diffuse/i;\n\n/**\n * Returns the color space (if any) implied by the {@link Material} slots to\n * which a texture is assigned, or null for non-color textures. If the texture\n * is not connected to any {@link Material}, this function will also return\n * null  any metadata in the image file will be ignored.\n *\n * Under current glTF specifications, only 'srgb' and non-color (null) textures\n * are used.\n *\n * Example:\n *\n * ```typescript\n * import { getTextureColorSpace } from '@gltf-transform/functions';\n *\n * const baseColorTexture = material.getBaseColorTexture();\n * const normalTexture = material.getNormalTexture();\n *\n * getTextureColorSpace(baseColorTexture); //  'srgb'\n * getTextureColorSpace(normalTexture); //  null\n * ```\n */\nexport function getTextureColorSpace(texture: Texture): string | null {\n\tconst graph = texture.getGraph();\n\tconst edges = graph.listParentEdges(texture);\n\tconst isSRGB = edges.some((edge) => {\n\t\treturn edge.getAttributes().isColor || SRGB_PATTERN.test(edge.getName());\n\t});\n\treturn isSRGB ? 'srgb' : null;\n}\n", "import { ExtensionProperty, type Material, type Property, Texture, TextureInfo } from '@gltf-transform/core';\n\n/**\n * Lists all {@link TextureInfo} definitions associated with a given\n * {@link Texture}. May be used to determine which UV transforms\n * and texCoord indices are applied to the material, without explicitly\n * checking the material properties and extensions.\n *\n * Example:\n *\n * ```typescript\n * // Find TextureInfo instances associated with the texture.\n * const results = listTextureInfo(texture);\n *\n * // Find which UV sets (TEXCOORD_0, TEXCOORD_1, ...) are required.\n * const texCoords = results.map((info) => info.getTexCoord());\n * //  [0, 1]\n * ```\n */\nexport function listTextureInfo(texture: Texture): TextureInfo[] {\n\tconst graph = texture.getGraph();\n\tconst results = new Set<TextureInfo>();\n\n\tfor (const textureEdge of graph.listParentEdges(texture)) {\n\t\tconst parent = textureEdge.getParent();\n\t\tconst name = textureEdge.getName() + 'Info';\n\n\t\tfor (const edge of graph.listChildEdges(parent)) {\n\t\t\tconst child = edge.getChild();\n\t\t\tif (child instanceof TextureInfo && edge.getName() === name) {\n\t\t\t\tresults.add(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Array.from(results);\n}\n\n/**\n * Lists all {@link TextureInfo} definitions associated with any {@link Texture}\n * on the given {@link Material}. May be used to determine which UV transforms\n * and texCoord indices are applied to the material, without explicitly\n * checking the material properties and extensions.\n *\n * Example:\n *\n * ```typescript\n * const results = listTextureInfoByMaterial(material);\n *\n * const texCoords = results.map((info) => info.getTexCoord());\n * //  [0, 1]\n * ```\n */\nexport function listTextureInfoByMaterial(material: Material): TextureInfo[] {\n\tconst graph = material.getGraph();\n\tconst visited = new Set<Property>();\n\tconst results = new Set<TextureInfo>();\n\n\tfunction traverse(prop: Material | ExtensionProperty) {\n\t\tconst textureInfoNames = new Set<string>();\n\n\t\tfor (const edge of graph.listChildEdges(prop)) {\n\t\t\tif (edge.getChild() instanceof Texture) {\n\t\t\t\ttextureInfoNames.add(edge.getName() + 'Info');\n\t\t\t}\n\t\t}\n\n\t\tfor (const edge of graph.listChildEdges(prop)) {\n\t\t\tconst child = edge.getChild();\n\t\t\tif (visited.has(child)) continue;\n\t\t\tvisited.add(child);\n\n\t\t\tif (child instanceof TextureInfo && textureInfoNames.has(edge.getName())) {\n\t\t\t\tresults.add(child);\n\t\t\t} else if (child instanceof ExtensionProperty) {\n\t\t\t\ttraverse(child);\n\t\t\t}\n\t\t}\n\t}\n\n\ttraverse(material);\n\treturn Array.from(results);\n}\n", "import { Document, type Texture } from '@gltf-transform/core';\n\n/**\n * Returns names of all texture slots using the given texture.\n *\n * Example:\n *\n * ```js\n * const slots = listTextureSlots(texture);\n * //  ['occlusionTexture', 'metallicRoughnessTexture']\n * ```\n */\nexport function listTextureSlots(texture: Texture): string[] {\n\tconst document = Document.fromGraph(texture.getGraph())!;\n\tconst root = document.getRoot();\n\tconst slots = texture\n\t\t.getGraph()\n\t\t.listParentEdges(texture)\n\t\t.filter((edge) => edge.getParent() !== root)\n\t\t.map((edge) => edge.getName());\n\treturn Array.from(new Set(slots));\n}\n", "import {\n\tAnimationChannel,\n\tColorUtils,\n\ttype Document,\n\tExtensionProperty,\n\ttype Graph,\n\ttype ILogger,\n\tMaterial,\n\ttype Node,\n\tPrimitive,\n\ttype PrimitiveTarget,\n\ttype Property,\n\tPropertyType,\n\tRoot,\n\tScene,\n\tTexture,\n\tTextureInfo,\n\ttype Transform,\n\ttype vec3,\n\ttype vec4,\n} from '@gltf-transform/core';\nimport { mul as mulVec3 } from 'gl-matrix/vec3';\nimport { add, create, len, mul, scale, sub } from 'gl-matrix/vec4';\nimport type { NdArray } from 'ndarray';\nimport { getPixels } from 'ndarray-pixels';\nimport { getTextureColorSpace } from './get-texture-color-space.js';\nimport { listTextureInfoByMaterial } from './list-texture-info.js';\nimport { listTextureSlots } from './list-texture-slots.js';\nimport { assignDefaults, createTransform, isEmptyObject } from './utils.js';\n\nconst NAME = 'prune';\n\nconst EPS = 3 / 255;\n\nexport interface PruneOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes?: string[];\n\t/** Whether to keep empty leaf nodes. */\n\tkeepLeaves?: boolean;\n\t/** Whether to keep unused vertex attributes, such as UVs without an assigned texture. */\n\tkeepAttributes?: boolean;\n\t/**\n\t * Whether to keep redundant mesh indices, where vertex count equals index count.\n\t * @deprecated Disabled. To remove indices, use {@link unweld} or other APIs.\n\t * @privateRemarks TODO(v5): Remove this option.\n\t */\n\tkeepIndices?: boolean;\n\t/** Whether to keep single-color textures that can be converted to material factors. */\n\tkeepSolidTextures?: boolean;\n\t/** Whether custom extras should prevent pruning a property. */\n\tkeepExtras?: boolean;\n}\n\nexport const PRUNE_DEFAULTS: Required<PruneOptions> = {\n\tpropertyTypes: [\n\t\tPropertyType.NODE,\n\t\tPropertyType.SKIN,\n\t\tPropertyType.MESH,\n\t\tPropertyType.CAMERA,\n\t\tPropertyType.PRIMITIVE,\n\t\tPropertyType.PRIMITIVE_TARGET,\n\t\tPropertyType.ANIMATION,\n\t\tPropertyType.MATERIAL,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.BUFFER,\n\t],\n\tkeepLeaves: false,\n\tkeepAttributes: false,\n\tkeepIndices: false,\n\tkeepSolidTextures: false,\n\tkeepExtras: false,\n};\n\n/**\n * Removes properties from the file if they are not referenced by a {@link Scene}. Commonly helpful\n * for cleaning up after other operations, e.g. allowing a node to be detached and any unused\n * meshes, materials, or other resources to be removed automatically.\n *\n * Example:\n *\n * ```javascript\n * import { PropertyType } from '@gltf-transform/core';\n * import { prune } from '@gltf-transform/functions';\n *\n * document.getRoot().listMaterials(); //  [Material, Material]\n *\n * await document.transform(\n * \tprune({\n * \t\tpropertyTypes: [PropertyType.MATERIAL],\n * \t\tkeepExtras: true\n * \t})\n * );\n *\n * document.getRoot().listMaterials(); //  [Material]\n * ```\n *\n * By default, pruning will aggressively remove most unused resources. Use\n * {@link PruneOptions} to limit what is considered for pruning.\n *\n * @category Transforms\n */\nexport function prune(_options: PruneOptions = PRUNE_DEFAULTS): Transform {\n\tconst options = assignDefaults(PRUNE_DEFAULTS, _options);\n\tconst propertyTypes = new Set(options.propertyTypes);\n\tconst keepExtras = options.keepExtras;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst root = document.getRoot();\n\t\tconst graph = document.getGraph();\n\n\t\tconst counter = new DisposeCounter();\n\n\t\tconst onDispose = (event: { target: Property }) => counter.dispose(event.target);\n\t\t// TODO(cleanup): Publish GraphEvent / GraphEventListener types from 'property-graph'.\n\t\t// biome-ignore lint/suspicious/noExplicitAny: TODO\n\t\tgraph.addEventListener('node:dispose', onDispose as any);\n\n\t\t// Prune top-down, so that low-level properties like accessors can be removed if the\n\t\t// properties referencing them are removed.\n\n\t\t// Prune empty Meshes.\n\t\tif (propertyTypes.has(PropertyType.MESH)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tif (mesh.listPrimitives().length > 0) continue;\n\t\t\t\tmesh.dispose();\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.NODE)) {\n\t\t\tif (!options.keepLeaves) {\n\t\t\t\tfor (const scene of root.listScenes()) {\n\t\t\t\t\tnodeTreeShake(graph, scene, keepExtras);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const node of root.listNodes()) {\n\t\t\t\ttreeShake(node, keepExtras);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.SKIN)) {\n\t\t\tfor (const skin of root.listSkins()) {\n\t\t\t\ttreeShake(skin, keepExtras);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.MESH)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\ttreeShake(mesh, keepExtras);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.CAMERA)) {\n\t\t\tfor (const camera of root.listCameras()) {\n\t\t\t\ttreeShake(camera, keepExtras);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.PRIMITIVE)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE, keepExtras);\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.PRIMITIVE_TARGET)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE_TARGET, keepExtras);\n\t\t}\n\n\t\t// Prune unused vertex attributes.\n\t\tif (!options.keepAttributes && propertyTypes.has(PropertyType.ACCESSOR)) {\n\t\t\tconst materialPrims = new Map<Material, Set<Primitive>>();\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\t\tconst material = prim.getMaterial();\n\t\t\t\t\tif (!material) continue;\n\n\t\t\t\t\tconst required = listRequiredSemantics(document, prim, material);\n\t\t\t\t\tconst unused = listUnusedSemantics(prim, required);\n\t\t\t\t\tpruneAttributes(prim, unused);\n\t\t\t\t\tprim.listTargets().forEach((target) => pruneAttributes(target, unused));\n\t\t\t\t\tmaterialPrims.has(material)\n\t\t\t\t\t\t? materialPrims.get(material)!.add(prim)\n\t\t\t\t\t\t: materialPrims.set(material, new Set([prim]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const [material, prims] of materialPrims) {\n\t\t\t\tshiftTexCoords(material, Array.from(prims));\n\t\t\t}\n\t\t}\n\n\t\t// Pruning animations is a bit more complicated:\n\t\t// (1) Remove channels without target nodes.\n\t\t// (2) Remove animations without channels.\n\t\t// (3) Remove samplers orphaned in the process.\n\t\tif (propertyTypes.has(PropertyType.ANIMATION)) {\n\t\t\tfor (const anim of root.listAnimations()) {\n\t\t\t\tfor (const channel of anim.listChannels()) {\n\t\t\t\t\tif (!channel.getTargetNode()) {\n\t\t\t\t\t\tchannel.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!anim.listChannels().length) {\n\t\t\t\t\tconst samplers = anim.listSamplers();\n\t\t\t\t\ttreeShake(anim, keepExtras);\n\t\t\t\t\tsamplers.forEach((sampler) => treeShake(sampler, keepExtras));\n\t\t\t\t} else {\n\t\t\t\t\tanim.listSamplers().forEach((sampler) => treeShake(sampler, keepExtras));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) {\n\t\t\troot.listMaterials().forEach((material) => treeShake(material, keepExtras));\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) {\n\t\t\troot.listTextures().forEach((texture) => treeShake(texture, keepExtras));\n\t\t\tif (!options.keepSolidTextures) {\n\t\t\t\tawait pruneSolidTextures(document);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) {\n\t\t\troot.listAccessors().forEach((accessor) => treeShake(accessor, keepExtras));\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.BUFFER)) {\n\t\t\troot.listBuffers().forEach((buffer) => treeShake(buffer, keepExtras));\n\t\t}\n\n\t\t// TODO(bug): This process does not identify unused ExtensionProperty instances. That could\n\t\t// be a future enhancement, either tracking unlinked properties as if they were connected\n\t\t// to the Graph, or iterating over a property list provided by the Extension. Properties in\n\t\t// use by an Extension are correctly preserved, in the meantime.\n\n\t\t// TODO(cleanup): Publish GraphEvent / GraphEventListener types from 'property-graph'.\n\t\t// biome-ignore lint/suspicious/noExplicitAny: TODO\n\t\tgraph.removeEventListener('node:dispose', onDispose as any);\n\n\t\tif (!counter.empty()) {\n\t\t\tconst str = counter\n\t\t\t\t.entries()\n\t\t\t\t.map(([type, count]) => `${type} (${count})`)\n\t\t\t\t.join(', ');\n\t\t\tlogger.info(`${NAME}: Removed types... ${str}`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: No unused properties found.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**********************************************************************************************\n * Utility for disposing properties and reporting statistics afterward.\n */\n\nclass DisposeCounter {\n\tpublic readonly disposed: Record<string, number> = {};\n\n\tempty(): boolean {\n\t\tfor (const _key in this.disposed) return false;\n\t\treturn true;\n\t}\n\n\tentries(): [string, number][] {\n\t\treturn Object.entries(this.disposed);\n\t}\n\n\t/** Records properties disposed by type. */\n\tdispose(prop: Property): void {\n\t\tthis.disposed[prop.propertyType] = this.disposed[prop.propertyType] || 0;\n\t\tthis.disposed[prop.propertyType]++;\n\t}\n}\n\n/**********************************************************************************************\n * Helper functions for the {@link prune} transform.\n *\n * IMPORTANT: These functions were previously declared in function scope, but\n * broke in the CommonJS build due to a buggy Babel transform. See:\n * https://github.com/donmccurdy/glTF-Transform/issues/1140\n */\n\n/** Disposes of the given property if it is unused. */\nfunction treeShake(prop: Property, keepExtras: boolean): void {\n\t// Consider a property unused if it has no references from another property, excluding\n\t// types Root and AnimationChannel.\n\tconst parents = prop.listParents().filter((p) => !(p instanceof Root || p instanceof AnimationChannel));\n\tconst needsExtras = keepExtras && !isEmptyObject(prop.getExtras());\n\tif (!parents.length && !needsExtras) {\n\t\tprop.dispose();\n\t}\n}\n\n/**\n * For property types the Root does not maintain references to, we'll need to search the\n * graph. It's possible that objects may have been constructed without any outbound links,\n * but since they're not on the graph they don't need to be tree-shaken.\n */\nfunction indirectTreeShake(graph: Graph<Property>, propertyType: string, keepExtras: boolean): void {\n\tfor (const edge of graph.listEdges()) {\n\t\tconst parent = edge.getParent();\n\t\tif (parent.propertyType === propertyType) {\n\t\t\ttreeShake(parent, keepExtras);\n\t\t}\n\t}\n}\n\n/** Iteratively prunes leaf Nodes without contents. */\nfunction nodeTreeShake(graph: Graph<Property>, prop: Node | Scene, keepExtras: boolean): void {\n\tprop.listChildren().forEach((child) => nodeTreeShake(graph, child, keepExtras));\n\n\tif (prop instanceof Scene) return;\n\n\tconst isUsed = graph.listParentEdges(prop).some((e) => {\n\t\tconst ptype = e.getParent().propertyType;\n\t\treturn ptype !== PropertyType.ROOT && ptype !== PropertyType.SCENE && ptype !== PropertyType.NODE;\n\t});\n\tconst isEmpty = graph.listChildren(prop).length === 0;\n\tconst needsExtras = keepExtras && !isEmptyObject(prop.getExtras());\n\tif (isEmpty && !isUsed && !needsExtras) {\n\t\tprop.dispose();\n\t}\n}\n\nfunction pruneAttributes(prim: Primitive | PrimitiveTarget, unused: string[]) {\n\tfor (const semantic of unused) {\n\t\tprim.setAttribute(semantic, null);\n\t}\n}\n\n/**\n * Lists vertex attribute semantics that are unused when rendering a given primitive.\n */\nfunction listUnusedSemantics(prim: Primitive | PrimitiveTarget, required: Set<string>): string[] {\n\tconst unused = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (semantic === 'NORMAL' && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic === 'TANGENT' && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic.startsWith('TEXCOORD_') && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic.startsWith('COLOR_') && semantic !== 'COLOR_0') {\n\t\t\tunused.push(semantic);\n\t\t}\n\t}\n\treturn unused;\n}\n\n/**\n * Lists vertex attribute semantics required by a material. Does not include\n * attributes that would be used unconditionally, like POSITION or NORMAL.\n */\nfunction listRequiredSemantics(\n\tdocument: Document,\n\tprim: Primitive,\n\tmaterial: Material | ExtensionProperty,\n\tsemantics = new Set<string>(),\n): Set<string> {\n\tconst graph = document.getGraph();\n\n\tconst edges = graph.listChildEdges(material);\n\tconst textureNames = new Set<string>();\n\n\tfor (const edge of edges) {\n\t\tif (edge.getChild() instanceof Texture) {\n\t\t\ttextureNames.add(edge.getName());\n\t\t}\n\t}\n\n\tfor (const edge of edges) {\n\t\tconst name = edge.getName();\n\t\tconst child = edge.getChild();\n\n\t\tif (child instanceof TextureInfo) {\n\t\t\tif (textureNames.has(name.replace(/Info$/, ''))) {\n\t\t\t\tsemantics.add(`TEXCOORD_${child.getTexCoord()}`);\n\t\t\t}\n\t\t}\n\n\t\tif (child instanceof Texture && name.match(/normalTexture/i)) {\n\t\t\tsemantics.add('TANGENT');\n\t\t}\n\n\t\tif (child instanceof ExtensionProperty) {\n\t\t\tlistRequiredSemantics(document, prim, child, semantics);\n\t\t}\n\n\t\t// TODO(#748): Does KHR_materials_anisotropy imply required vertex attributes?\n\t}\n\n\tconst isLit = material instanceof Material && !material.getExtension('KHR_materials_unlit');\n\tconst isPoints = prim.getMode() === Primitive.Mode.POINTS;\n\tif (isLit && !isPoints) {\n\t\tsemantics.add('NORMAL');\n\t}\n\n\treturn semantics;\n}\n\n/**\n * Shifts texCoord indices on the given material and primitives assigned to\n * that material, such that indices start at zero and ascend without gaps.\n * Prior to calling this function, the implementation must ensure that:\n * - All TEXCOORD_n attributes on these prims are used by the material.\n * - Material does not require any unavailable TEXCOORD_n attributes.\n *\n * TEXCOORD_n attributes on morph targets are shifted alongside the parent\n * prim, but gaps may remain in their semantic lists.\n */\nfunction shiftTexCoords(material: Material, prims: Primitive[]) {\n\t// Create map from srcTexCoord  dstTexCoord.\n\tconst textureInfoList = listTextureInfoByMaterial(material);\n\tconst texCoordSet = new Set(textureInfoList.map((info: TextureInfo) => info.getTexCoord()));\n\tconst texCoordList = Array.from(texCoordSet).sort();\n\tconst texCoordMap = new Map(texCoordList.map((texCoord, index) => [texCoord, index]));\n\tconst semanticMap = new Map(texCoordList.map((texCoord, index) => [`TEXCOORD_${texCoord}`, `TEXCOORD_${index}`]));\n\n\t// Update material.\n\tfor (const textureInfo of textureInfoList) {\n\t\tconst texCoord = textureInfo.getTexCoord();\n\t\ttextureInfo.setTexCoord(texCoordMap.get(texCoord)!);\n\t}\n\n\t// Update prims.\n\tfor (const prim of prims) {\n\t\tconst semantics = prim\n\t\t\t.listSemantics()\n\t\t\t.filter((semantic) => semantic.startsWith('TEXCOORD_'))\n\t\t\t.sort();\n\t\tupdatePrim(prim, semantics);\n\t\tprim.listTargets().forEach((target) => updatePrim(target, semantics));\n\t}\n\n\tfunction updatePrim(prim: Primitive | PrimitiveTarget, srcSemantics: string[]) {\n\t\tfor (const srcSemantic of srcSemantics) {\n\t\t\tconst uv = prim.getAttribute(srcSemantic);\n\t\t\tif (!uv) continue;\n\n\t\t\tconst dstSemantic = semanticMap.get(srcSemantic)!;\n\t\t\tif (dstSemantic === srcSemantic) continue;\n\n\t\t\tprim.setAttribute(dstSemantic, uv);\n\t\t\tprim.setAttribute(srcSemantic, null);\n\t\t}\n\t}\n}\n\n/**********************************************************************************************\n * Prune solid (single-color) textures.\n */\n\nasync function pruneSolidTextures(document: Document): Promise<void> {\n\tconst root = document.getRoot();\n\tconst graph = document.getGraph();\n\tconst logger = document.getLogger();\n\tconst textures = root.listTextures();\n\n\tconst pending = textures.map(async (texture) => {\n\t\tconst factor = await getTextureFactor(texture);\n\t\tif (!factor) return;\n\n\t\tif (getTextureColorSpace(texture) === 'srgb') {\n\t\t\tColorUtils.convertSRGBToLinear(factor, factor);\n\t\t}\n\n\t\tconst name = texture.getName() || texture.getURI();\n\t\tconst size = texture.getSize()?.join('x');\n\t\tconst slots = listTextureSlots(texture);\n\n\t\tfor (const edge of graph.listParentEdges(texture)) {\n\t\t\tconst parent = edge.getParent();\n\t\t\tif (parent !== root && applyMaterialFactor(parent as Material, factor, edge.getName(), logger)) {\n\t\t\t\tedge.dispose();\n\t\t\t}\n\t\t}\n\n\t\tif (texture.listParents().length === 1) {\n\t\t\ttexture.dispose();\n\t\t\tlogger.debug(`${NAME}: Removed solid-color texture \"${name}\" (${size}px ${slots.join(', ')})`);\n\t\t}\n\t});\n\n\tawait Promise.all(pending);\n}\n\nfunction applyMaterialFactor(\n\tmaterial: Material | ExtensionProperty,\n\tfactor: vec4,\n\tslot: string,\n\tlogger: ILogger,\n): boolean {\n\tif (material instanceof Material) {\n\t\tswitch (slot) {\n\t\t\tcase 'baseColorTexture':\n\t\t\t\tmaterial.setBaseColorFactor(mul(factor, factor, material.getBaseColorFactor()) as vec4);\n\t\t\t\treturn true;\n\t\t\tcase 'emissiveTexture':\n\t\t\t\tmaterial.setEmissiveFactor(\n\t\t\t\t\tmulVec3([0, 0, 0], factor.slice(0, 3) as vec3, material.getEmissiveFactor()) as vec3,\n\t\t\t\t);\n\t\t\t\treturn true;\n\t\t\tcase 'occlusionTexture':\n\t\t\t\treturn Math.abs(factor[0] - 1) <= EPS;\n\t\t\tcase 'metallicRoughnessTexture':\n\t\t\t\tmaterial.setRoughnessFactor(factor[1] * material.getRoughnessFactor());\n\t\t\t\tmaterial.setMetallicFactor(factor[2] * material.getMetallicFactor());\n\t\t\t\treturn true;\n\t\t\tcase 'normalTexture':\n\t\t\t\treturn len(sub(create(), factor, [0.5, 0.5, 1, 1])) <= EPS;\n\t\t}\n\t}\n\n\tlogger.warn(`${NAME}: Detected single-color ${slot} texture. Pruning ${slot} not yet supported.`);\n\treturn false;\n}\n\nasync function getTextureFactor(texture: Texture): Promise<vec4 | null> {\n\tconst pixels = await maybeGetPixels(texture);\n\tif (!pixels) return null;\n\n\tconst min: vec4 = [Infinity, Infinity, Infinity, Infinity];\n\tconst max: vec4 = [-Infinity, -Infinity, -Infinity, -Infinity];\n\tconst target: vec4 = [0, 0, 0, 0];\n\n\tconst [width, height] = pixels.shape;\n\n\tfor (let i = 0; i < width; i++) {\n\t\tfor (let j = 0; j < height; j++) {\n\t\t\tfor (let k = 0; k < 4; k++) {\n\t\t\t\tmin[k] = Math.min(min[k], pixels.get(i, j, k));\n\t\t\t\tmax[k] = Math.max(max[k], pixels.get(i, j, k));\n\t\t\t}\n\t\t}\n\n\t\tif (len(sub(target, max, min)) / 255 > EPS) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn scale(target, add(target, max, min), 0.5 / 255) as vec4;\n}\n\nasync function maybeGetPixels(texture: Texture): Promise<NdArray<Uint8Array> | null> {\n\ttry {\n\t\treturn await getPixels(texture.getImage()!, texture.getMimeType());\n\t} catch {\n\t\treturn null;\n\t}\n}\n", "import { type Document, type Node, PropertyType, type Transform } from '@gltf-transform/core';\nimport { clearNodeParent } from './clear-node-parent.js';\nimport { prune } from './prune.js';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'flatten';\n\n/** Options for the {@link flatten} function. */\nexport interface FlattenOptions {\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nexport const FLATTEN_DEFAULTS: Required<FlattenOptions> = {\n\tcleanup: true,\n};\n\n/**\n * Flattens the scene graph, leaving {@link Node Nodes} with\n * {@link Mesh Meshes}, {@link Camera Cameras}, and other attachments\n * as direct children of the {@link Scene}. Skeletons and their\n * descendants are left in their original Node structure.\n *\n * {@link Animation} targeting a Node or its parents will\n * prevent that Node from being moved.\n *\n * Example:\n *\n * ```ts\n * import { flatten } from '@gltf-transform/functions';\n *\n * await document.transform(flatten());\n * ```\n *\n * @category Transforms\n */\nexport function flatten(_options: FlattenOptions = FLATTEN_DEFAULTS): Transform {\n\tconst options = assignDefaults(FLATTEN_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\t// (1) Mark joints.\n\t\tconst joints = new Set<Node>();\n\t\tfor (const skin of root.listSkins()) {\n\t\t\tfor (const joint of skin.listJoints()) {\n\t\t\t\tjoints.add(joint);\n\t\t\t}\n\t\t}\n\n\t\t// (2) Mark nodes with TRS animation.\n\t\tconst animated = new Set<Node>();\n\t\tfor (const animation of root.listAnimations()) {\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tconst node = channel.getTargetNode();\n\t\t\t\tif (node && channel.getTargetPath() !== 'weights') {\n\t\t\t\t\tanimated.add(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (3) Mark descendants of joints and animated nodes.\n\t\tconst hasJointParent = new Set<Node>();\n\t\tconst hasAnimatedParent = new Set<Node>();\n\t\tfor (const scene of root.listScenes()) {\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst parent = node.getParentNode();\n\t\t\t\tif (!parent) return;\n\t\t\t\tif (joints.has(parent) || hasJointParent.has(parent)) {\n\t\t\t\t\thasJointParent.add(node);\n\t\t\t\t}\n\t\t\t\tif (animated.has(parent) || hasAnimatedParent.has(parent)) {\n\t\t\t\t\thasAnimatedParent.add(node);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// (4) For each affected node, in top-down order, clear parents.\n\t\tfor (const scene of root.listScenes()) {\n\t\t\tscene.traverse((node) => {\n\t\t\t\tif (animated.has(node)) return;\n\t\t\t\tif (hasJointParent.has(node)) return;\n\t\t\t\tif (hasAnimatedParent.has(node)) return;\n\n\t\t\t\tclearNodeParent(node);\n\t\t\t});\n\t\t}\n\n\t\t// TODO(feat): Transform animation channels, accounting for previously inherited transforms.\n\t\tif (animated.size) {\n\t\t\tlogger.debug(`${NAME}: Flattening node hierarchies with TRS animation not yet supported.`);\n\t\t}\n\n\t\t// (5) Clean up leaf nodes.\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(prune({ propertyTypes: [PropertyType.NODE], keepLeaves: false }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import { getBounds as _getBounds, type bbox, type Node, type Scene } from '@gltf-transform/core';\n\n/**\n * Computes bounding box (AABB) in world space for the given {@link Node} or {@link Scene}.\n *\n * Example:\n *\n * ```ts\n * import { getBounds } from '@gltf-transform/functions';\n *\n * const {min, max} = getBounds(scene);\n * ```\n */\nexport function getBounds(node: Node | Scene): bbox {\n\treturn _getBounds(node);\n}\n", "import {\n\ttype Accessor,\n\ttype Document,\n\tExtensionProperty,\n\ttype GLTF,\n\tgetBounds,\n\tImageUtils,\n\tPropertyType,\n\tTexture,\n} from '@gltf-transform/core';\nimport { KHR_DF_MODEL_ETC1S, KHR_DF_MODEL_UASTC, read as readKTX } from 'ktx-parse';\nimport { getMeshVertexCount, getSceneVertexCount, VertexCountMethod } from './get-vertex-count.js';\nimport { getGLPrimitiveCount } from './utils.js';\n\n/** Inspects the contents of a glTF file and returns a JSON report. */\nexport function inspect(doc: Document): InspectReport {\n\treturn {\n\t\tscenes: listScenes(doc),\n\t\tmeshes: listMeshes(doc),\n\t\tmaterials: listMaterials(doc),\n\t\ttextures: listTextures(doc),\n\t\tanimations: listAnimations(doc),\n\t};\n}\n\n/** List scenes. */\nfunction listScenes(doc: Document): InspectPropertyReport<InspectSceneReport> {\n\tconst scenes = doc\n\t\t.getRoot()\n\t\t.listScenes()\n\t\t.map((scene) => {\n\t\t\tconst root = scene.listChildren()[0];\n\t\t\tconst sceneBounds = getBounds(scene);\n\t\t\treturn {\n\t\t\t\tname: scene.getName(),\n\t\t\t\trootName: root ? root.getName() : '',\n\t\t\t\tbboxMin: toPrecision(sceneBounds.min),\n\t\t\t\tbboxMax: toPrecision(sceneBounds.max),\n\t\t\t\trenderVertexCount: getSceneVertexCount(scene, VertexCountMethod.RENDER),\n\t\t\t\tuploadVertexCount: getSceneVertexCount(scene, VertexCountMethod.UPLOAD),\n\t\t\t\tuploadNaiveVertexCount: getSceneVertexCount(scene, VertexCountMethod.UPLOAD_NAIVE),\n\t\t\t};\n\t\t});\n\treturn { properties: scenes };\n}\n\n/** List meshes. */\nfunction listMeshes(doc: Document): InspectPropertyReport<InspectMeshReport> {\n\tconst meshes: InspectMeshReport[] = doc\n\t\t.getRoot()\n\t\t.listMeshes()\n\t\t.map((mesh) => {\n\t\t\tconst instances = mesh.listParents().filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\t\t\tlet glPrimitives = 0;\n\t\t\tconst semantics = new Set<string>();\n\t\t\tconst meshIndices = new Set<string>();\n\t\t\tconst meshAccessors: Set<Accessor> = new Set();\n\n\t\t\tmesh.listPrimitives().forEach((prim) => {\n\t\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\t\tconst attr = prim.getAttribute(semantic)!;\n\t\t\t\t\tsemantics.add(semantic + ':' + accessorToTypeLabel(attr));\n\t\t\t\t\tmeshAccessors.add(attr);\n\t\t\t\t}\n\t\t\t\tfor (const targ of prim.listTargets()) {\n\t\t\t\t\ttarg.listAttributes().forEach((attr) => meshAccessors.add(attr));\n\t\t\t\t}\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tif (indices) {\n\t\t\t\t\tmeshIndices.add(accessorToTypeLabel(indices));\n\t\t\t\t\tmeshAccessors.add(indices);\n\t\t\t\t}\n\t\t\t\tglPrimitives += getGLPrimitiveCount(prim);\n\t\t\t});\n\n\t\t\tlet size = 0;\n\t\t\tArray.from(meshAccessors).forEach((a) => (size += a.getArray()!.byteLength));\n\n\t\t\tconst modes = mesh.listPrimitives().map((prim) => MeshPrimitiveModeLabels[prim.getMode()]);\n\n\t\t\treturn {\n\t\t\t\tname: mesh.getName(),\n\t\t\t\tmode: Array.from(new Set(modes)),\n\t\t\t\tmeshPrimitives: mesh.listPrimitives().length,\n\t\t\t\tglPrimitives: glPrimitives,\n\t\t\t\tvertices: getMeshVertexCount(mesh, VertexCountMethod.UPLOAD),\n\t\t\t\tindices: Array.from(meshIndices).sort(),\n\t\t\t\tattributes: Array.from(semantics).sort(),\n\t\t\t\tinstances: instances,\n\t\t\t\tsize: size,\n\t\t\t};\n\t\t});\n\n\treturn { properties: meshes };\n}\n\n/** List materials. */\nfunction listMaterials(doc: Document): InspectPropertyReport<InspectMaterialReport> {\n\tconst materials: InspectMaterialReport[] = doc\n\t\t.getRoot()\n\t\t.listMaterials()\n\t\t.map((material) => {\n\t\t\tconst instances = material\n\t\t\t\t.listParents()\n\t\t\t\t.filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\n\t\t\t// Find all texture slots attached to this material or its extensions.\n\t\t\tconst extensions = new Set<ExtensionProperty>(material.listExtensions());\n\t\t\tconst slots = doc\n\t\t\t\t.getGraph()\n\t\t\t\t.listEdges()\n\t\t\t\t.filter((ref) => {\n\t\t\t\t\tconst child = ref.getChild();\n\t\t\t\t\tconst parent = ref.getParent();\n\t\t\t\t\tif (child instanceof Texture && parent === material) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (child instanceof Texture && parent instanceof ExtensionProperty && extensions.has(parent)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t})\n\t\t\t\t.map((ref) => ref.getName());\n\n\t\t\treturn {\n\t\t\t\tname: material.getName(),\n\t\t\t\tinstances,\n\t\t\t\ttextures: slots,\n\t\t\t\talphaMode: material.getAlphaMode(),\n\t\t\t\tdoubleSided: material.getDoubleSided(),\n\t\t\t};\n\t\t});\n\n\treturn { properties: materials };\n}\n\n/** List textures. */\nfunction listTextures(doc: Document): InspectPropertyReport<InspectTextureReport> {\n\tconst textures: InspectTextureReport[] = doc\n\t\t.getRoot()\n\t\t.listTextures()\n\t\t.map((texture) => {\n\t\t\tconst instances = texture\n\t\t\t\t.listParents()\n\t\t\t\t.filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\n\t\t\tconst slots = doc\n\t\t\t\t.getGraph()\n\t\t\t\t.listParentEdges(texture)\n\t\t\t\t.filter((edge) => edge.getParent().propertyType !== PropertyType.ROOT)\n\t\t\t\t.map((edge) => edge.getName());\n\n\t\t\tconst resolution = ImageUtils.getSize(texture.getImage()!, texture.getMimeType());\n\n\t\t\tlet compression = '';\n\t\t\tif (texture.getMimeType() === 'image/ktx2') {\n\t\t\t\tconst container = readKTX(texture.getImage()!);\n\t\t\t\tconst dfd = container.dataFormatDescriptor[0];\n\t\t\t\tif (dfd.colorModel === KHR_DF_MODEL_ETC1S) {\n\t\t\t\t\tcompression = 'ETC1S';\n\t\t\t\t} else if (dfd.colorModel === KHR_DF_MODEL_UASTC) {\n\t\t\t\t\tcompression = 'UASTC';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tname: texture.getName(),\n\t\t\t\turi: texture.getURI(),\n\t\t\t\tslots: Array.from(new Set(slots)),\n\t\t\t\tinstances,\n\t\t\t\tmimeType: texture.getMimeType(),\n\t\t\t\tcompression,\n\t\t\t\tresolution: resolution ? resolution.join('x') : '',\n\t\t\t\tsize: texture.getImage()!.byteLength,\n\t\t\t\tgpuSize: ImageUtils.getVRAMByteLength(texture.getImage()!, texture.getMimeType()),\n\t\t\t};\n\t\t});\n\n\treturn { properties: textures };\n}\n\n/** List animations. */\nfunction listAnimations(doc: Document): InspectPropertyReport<InspectAnimationReport> {\n\tconst animations: InspectAnimationReport[] = doc\n\t\t.getRoot()\n\t\t.listAnimations()\n\t\t.map((anim) => {\n\t\t\tlet minTime = Infinity;\n\t\t\tlet maxTime = -Infinity;\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tif (!input) return;\n\t\t\t\tminTime = Math.min(minTime, input.getMin([])[0]);\n\t\t\t\tmaxTime = Math.max(maxTime, input.getMax([])[0]);\n\t\t\t});\n\n\t\t\tlet size = 0;\n\t\t\tlet keyframes = 0;\n\t\t\tconst accessors: Set<Accessor> = new Set();\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\tif (!input) return;\n\t\t\t\tkeyframes += input.getCount();\n\t\t\t\taccessors.add(input);\n\t\t\t\tif (!output) return;\n\t\t\t\taccessors.add(output);\n\t\t\t});\n\t\t\tArray.from(accessors).forEach((accessor) => {\n\t\t\t\tsize += accessor.getArray()!.byteLength;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tname: anim.getName(),\n\t\t\t\tchannels: anim.listChannels().length,\n\t\t\t\tsamplers: anim.listSamplers().length,\n\t\t\t\tduration: Math.round((maxTime - minTime) * 1000) / 1000,\n\t\t\t\tkeyframes: keyframes,\n\t\t\t\tsize: size,\n\t\t\t};\n\t\t});\n\n\treturn { properties: animations };\n}\n\nexport interface InspectReport {\n\tscenes: InspectPropertyReport<InspectSceneReport>;\n\tmeshes: InspectPropertyReport<InspectMeshReport>;\n\tmaterials: InspectPropertyReport<InspectMaterialReport>;\n\ttextures: InspectPropertyReport<InspectTextureReport>;\n\tanimations: InspectPropertyReport<InspectAnimationReport>;\n}\n\nexport interface InspectPropertyReport<T> {\n\tproperties: T[];\n\terrors?: string[];\n\twarnings?: string[];\n}\n\nexport interface InspectSceneReport {\n\tname: string;\n\trootName: string;\n\tbboxMin: number[];\n\tbboxMax: number[];\n\trenderVertexCount: number;\n\tuploadVertexCount: number;\n\tuploadNaiveVertexCount: number;\n}\n\nexport interface InspectMeshReport {\n\tname: string;\n\tmeshPrimitives: number;\n\tmode: string[];\n\tvertices: number;\n\tglPrimitives: number;\n\tindices: string[];\n\tattributes: string[];\n\tinstances: number;\n\tsize: number;\n}\n\nexport interface InspectMaterialReport {\n\tname: string;\n\tinstances: number;\n\ttextures: string[];\n\talphaMode: GLTF.MaterialAlphaMode;\n\tdoubleSided: boolean;\n}\n\nexport interface InspectTextureReport {\n\tname: string;\n\turi: string;\n\tslots: string[];\n\tinstances: number;\n\tmimeType: string;\n\tresolution: string;\n\tcompression: string;\n\tsize: number;\n\tgpuSize: number | null;\n}\n\nexport interface InspectAnimationReport {\n\tname: string;\n\tchannels: number;\n\tsamplers: number;\n\tkeyframes: number;\n\tduration: number;\n\tsize: number;\n}\n\nconst MeshPrimitiveModeLabels = [\n\t'POINTS',\n\t'LINES',\n\t'LINE_LOOP',\n\t'LINE_STRIP',\n\t'TRIANGLES',\n\t'TRIANGLE_STRIP',\n\t'TRIANGLE_FAN',\n];\n\nconst NumericTypeLabels: Record<string, string> = {\n\tFloat32Array: 'f32',\n\tUint32Array: 'u32',\n\tUint16Array: 'u16',\n\tUint8Array: 'u8',\n\tInt32Array: 'i32',\n\tInt16Array: 'i16',\n\tInt8Array: 'i8',\n};\n\n/** Maps values in a vector to a finite precision. */\nfunction toPrecision(v: number[]): number[] {\n\tfor (let i = 0; i < v.length; i++) {\n\t\tif ((v[i] as number).toFixed) v[i] = Number(v[i].toFixed(5));\n\t}\n\treturn v;\n}\n\nfunction accessorToTypeLabel(accessor: Accessor): string {\n\tconst array = accessor.getArray()!;\n\tconst base = NumericTypeLabels[array.constructor.name] || '?';\n\tconst suffix = accessor.getNormalized() ? '_norm' : '';\n\treturn base + suffix;\n}\n", "import {\n\ttype Document,\n\ttype ILogger,\n\tMathUtils,\n\ttype Mesh,\n\ttype Node,\n\ttype Primitive,\n\ttype Transform,\n\ttype vec3,\n\ttype vec4,\n} from '@gltf-transform/core';\nimport { EXTMeshGPUInstancing, type InstancedMesh } from '@gltf-transform/extensions';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'instance';\n\nexport interface InstanceOptions {\n\t/** Minimum number of meshes considered eligible for instancing. Default: 5. */\n\tmin?: number;\n}\n\nexport const INSTANCE_DEFAULTS: Required<InstanceOptions> = {\n\tmin: 5,\n};\n\n/**\n * Creates GPU instances (with {@link EXTMeshGPUInstancing}) for shared {@link Mesh} references. In\n * engines supporting the extension, reused Meshes will be drawn with GPU instancing, greatly\n * reducing draw calls and improving performance in many cases. If you're not sure that identical\n * Meshes share vertex data and materials (\"linked duplicates\"), run {@link dedup} first to link them.\n *\n * Example:\n *\n * ```javascript\n * import { dedup, instance } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tdedup(),\n * \tinstance({min: 5}),\n * );\n * ```\n *\n * @category Transforms\n */\nexport function instance(_options: InstanceOptions = INSTANCE_DEFAULTS): Transform {\n\tconst options = assignDefaults(INSTANCE_DEFAULTS, _options);\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\n\t\tif (root.listAnimations().length) {\n\t\t\tlogger.warn(`${NAME}: Instancing is not currently supported for animated models.`);\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst batchExtension = doc.createExtension(EXTMeshGPUInstancing);\n\n\t\tlet numBatches = 0;\n\t\tlet numInstances = 0;\n\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t// Gather a one-to-many Mesh/Node mapping, identifying what we can instance.\n\t\t\tconst meshInstances = new Map<Mesh, Set<Node>>();\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst mesh = node.getMesh();\n\t\t\t\tif (!mesh) return;\n\t\t\t\tif (node.getExtension('EXT_mesh_gpu_instancing')) return;\n\t\t\t\tmeshInstances.set(mesh, (meshInstances.get(mesh) || new Set<Node>()).add(node));\n\t\t\t});\n\n\t\t\t// For each Mesh, create an InstancedMesh and collect transforms.\n\t\t\tconst modifiedNodes = [];\n\t\t\tfor (const mesh of Array.from(meshInstances.keys())) {\n\t\t\t\tconst nodes = Array.from(meshInstances.get(mesh)!);\n\t\t\t\tif (nodes.length < options.min) continue;\n\t\t\t\tif (nodes.some((node) => node.getSkin())) continue;\n\n\t\t\t\t// Cannot preserve volumetric effects when instancing with varying scale.\n\t\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/AttenuationTest\n\t\t\t\tif (mesh.listPrimitives().some(hasVolume) && nodes.some(hasScale)) continue;\n\n\t\t\t\tconst batch = createBatch(doc, batchExtension, mesh, nodes.length);\n\t\t\t\tconst batchTranslation = batch.getAttribute('TRANSLATION')!;\n\t\t\t\tconst batchRotation = batch.getAttribute('ROTATION')!;\n\t\t\t\tconst batchScale = batch.getAttribute('SCALE')!;\n\n\t\t\t\tconst batchNode = doc.createNode().setMesh(mesh).setExtension('EXT_mesh_gpu_instancing', batch);\n\t\t\t\tscene.addChild(batchNode);\n\n\t\t\t\tlet needsTranslation = false;\n\t\t\t\tlet needsRotation = false;\n\t\t\t\tlet needsScale = false;\n\n\t\t\t\t// For each Node, write TRS properties into instance attributes.\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tlet t: vec3, r: vec4, s: vec3;\n\t\t\t\t\tconst node = nodes[i];\n\n\t\t\t\t\tbatchTranslation.setElement(i, (t = node.getWorldTranslation()));\n\t\t\t\t\tbatchRotation.setElement(i, (r = node.getWorldRotation()));\n\t\t\t\t\tbatchScale.setElement(i, (s = node.getWorldScale()));\n\n\t\t\t\t\tif (!MathUtils.eq(t, [0, 0, 0])) needsTranslation = true;\n\t\t\t\t\tif (!MathUtils.eq(r, [0, 0, 0, 1])) needsRotation = true;\n\t\t\t\t\tif (!MathUtils.eq(s, [1, 1, 1])) needsScale = true;\n\t\t\t\t}\n\n\t\t\t\tif (!needsTranslation) batchTranslation.dispose();\n\t\t\t\tif (!needsRotation) batchRotation.dispose();\n\t\t\t\tif (!needsScale) batchScale.dispose();\n\n\t\t\t\tif (!needsTranslation && !needsRotation && !needsScale) {\n\t\t\t\t\tbatchNode.dispose();\n\t\t\t\t\tbatch.dispose();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Mark nodes for cleanup.\n\t\t\t\tfor (const node of nodes) {\n\t\t\t\t\tnode.setMesh(null);\n\t\t\t\t\tmodifiedNodes.push(node);\n\t\t\t\t}\n\n\t\t\t\tnumBatches++;\n\t\t\t\tnumInstances += nodes.length;\n\t\t\t}\n\n\t\t\tpruneUnusedNodes(modifiedNodes, logger);\n\t\t}\n\n\t\tif (numBatches > 0) {\n\t\t\tlogger.info(`${NAME}: Created ${numBatches} batches, with ${numInstances} total instances.`);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No meshes with >=${options.min} parent nodes were found.`);\n\t\t}\n\n\t\tif (batchExtension.listProperties().length === 0) {\n\t\t\tbatchExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction pruneUnusedNodes(nodes: Node[], logger: ILogger): void {\n\tlet node: Node | undefined;\n\tlet unusedNodes = 0;\n\twhile ((node = nodes.pop())) {\n\t\tif (\n\t\t\tnode.listChildren().length ||\n\t\t\tnode.getCamera() ||\n\t\t\tnode.getMesh() ||\n\t\t\tnode.getSkin() ||\n\t\t\tnode.listExtensions().length\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst nodeParent = node.getParentNode();\n\t\tif (nodeParent) nodes.push(nodeParent);\n\t\tnode.dispose();\n\t\tunusedNodes++;\n\t}\n\n\tlogger.debug(`${NAME}: Removed ${unusedNodes} unused nodes.`);\n}\n\nfunction hasVolume(prim: Primitive) {\n\tconst material = prim.getMaterial();\n\treturn !!(material && material.getExtension('KHR_materials_volume'));\n}\n\nfunction hasScale(node: Node) {\n\tconst scale = node.getWorldScale();\n\treturn !MathUtils.eq(scale, [1, 1, 1]);\n}\n\nfunction createBatch(doc: Document, batchExtension: EXTMeshGPUInstancing, mesh: Mesh, count: number): InstancedMesh {\n\tconst buffer = mesh.listPrimitives()[0].getAttribute('POSITION')!.getBuffer();\n\n\tconst batchTranslation = doc\n\t\t.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\tconst batchRotation = doc\n\t\t.createAccessor()\n\t\t.setType('VEC4')\n\t\t.setArray(new Float32Array(4 * count))\n\t\t.setBuffer(buffer);\n\tconst batchScale = doc\n\t\t.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\n\treturn batchExtension\n\t\t.createInstancedMesh()\n\t\t.setAttribute('TRANSLATION', batchTranslation)\n\t\t.setAttribute('ROTATION', batchRotation)\n\t\t.setAttribute('SCALE', batchScale);\n}\n", "import { type Accessor, ComponentTypeToTypedArray, Document, Primitive, type TypedArray } from '@gltf-transform/core';\nimport { convertPrimitiveToLines, convertPrimitiveToTriangles } from './convert-primitive-mode.js';\nimport { assignDefaults, createIndicesEmpty, createPrimGroupKey, shallowCloneAccessor } from './utils.js';\n\ninterface JoinPrimitiveOptions {\n\tskipValidation?: boolean;\n}\n\nconst JOIN_PRIMITIVE_DEFAULTS: Required<JoinPrimitiveOptions> = {\n\tskipValidation: false,\n};\n\nconst EMPTY_U32 = 2 ** 32 - 1;\n\nconst { LINE_STRIP, LINE_LOOP, TRIANGLE_STRIP, TRIANGLE_FAN } = Primitive.Mode;\n\n/**\n * Given a list of compatible Mesh {@link Primitive Primitives}, returns new Primitive\n * containing their vertex data. Compatibility requires that all Primitives share the\n * same {@link Material Materials}, draw mode, and vertex attribute types. Primitives\n * using morph targets cannot currently be joined.\n *\n * Example:\n *\n * ```javascript\n * import { joinPrimitives } from '@gltf-transform/functions';\n *\n * // Succeeds if Primitives are compatible, or throws an error.\n * const result = joinPrimitives(mesh.listPrimitives());\n *\n * for (const prim of mesh.listPrimitives()) {\n * \tprim.dispose();\n * }\n *\n * mesh.addPrimitive(result);\n * ```\n */\nexport function joinPrimitives(prims: Primitive[], _options: JoinPrimitiveOptions = {}): Primitive {\n\tconst options = assignDefaults(JOIN_PRIMITIVE_DEFAULTS, _options);\n\tconst templatePrim = prims[0]!;\n\tconst document = Document.fromGraph(templatePrim.getGraph())!;\n\n\t// (1) Validation.\n\tif (!options.skipValidation && new Set(prims.map(createPrimGroupKey)).size > 1) {\n\t\tthrow new Error(\n\t\t\t'' +\n\t\t\t\t'Requires >=2 Primitives, sharing the same Material ' +\n\t\t\t\t'and Mode, with compatible vertex attributes and indices.',\n\t\t);\n\t}\n\n\t// (2) Convert all prims to POINTS, LINES, or TRIANGLES.\n\tfor (const prim of prims) {\n\t\tswitch (prim.getMode()) {\n\t\t\tcase LINE_STRIP:\n\t\t\tcase LINE_LOOP:\n\t\t\t\tconvertPrimitiveToLines(prim);\n\t\t\t\tbreak;\n\t\t\tcase TRIANGLE_STRIP:\n\t\t\tcase TRIANGLE_FAN:\n\t\t\t\tconvertPrimitiveToTriangles(prim);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst primRemaps = [] as Uint32Array[]; // remap[srcIndex]  dstIndex, by prim\n\tconst primVertexCounts = new Uint32Array(prims.length); // vertex count, by prim\n\n\tlet dstVertexCount = 0;\n\tlet dstIndicesCount = 0;\n\n\t// (3) Build remap lists.\n\tfor (let primIndex = 0; primIndex < prims.length; primIndex++) {\n\t\tconst srcPrim = prims[primIndex];\n\t\tconst srcIndices = srcPrim.getIndices();\n\t\tconst srcVertexCount = srcPrim.getAttribute('POSITION')!.getCount();\n\t\tconst srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n\t\tconst srcIndicesCount = srcIndices ? srcIndices.getCount() : srcVertexCount;\n\n\t\tconst remap = new Uint32Array(srcVertexCount).fill(EMPTY_U32);\n\n\t\tfor (let i = 0; i < srcIndicesCount; i++) {\n\t\t\tconst index = srcIndicesArray ? srcIndicesArray[i] : i;\n\t\t\tif (remap[index] === EMPTY_U32) {\n\t\t\t\tremap[index] = dstVertexCount++;\n\t\t\t\tprimVertexCounts[primIndex]++;\n\t\t\t}\n\t\t}\n\n\t\tprimRemaps.push(remap);\n\t\tdstIndicesCount += srcIndicesCount;\n\t}\n\n\t// (4) Allocate joined attributes.\n\tconst dstPrim = document.createPrimitive().setMode(templatePrim.getMode()).setMaterial(templatePrim.getMaterial());\n\tfor (const semantic of templatePrim.listSemantics()) {\n\t\tconst tplAttribute = templatePrim.getAttribute(semantic)!;\n\t\tconst AttributeArray = ComponentTypeToTypedArray[tplAttribute.getComponentType()];\n\t\tconst dstAttribute = shallowCloneAccessor(document, tplAttribute).setArray(\n\t\t\tnew AttributeArray(dstVertexCount * tplAttribute.getElementSize()),\n\t\t);\n\t\tdstPrim.setAttribute(semantic, dstAttribute);\n\t}\n\n\t// (5) Allocate joined indices.\n\tconst tplIndices = templatePrim.getIndices();\n\tconst dstIndices = tplIndices\n\t\t? shallowCloneAccessor(document, tplIndices).setArray(createIndicesEmpty(dstIndicesCount, dstVertexCount))\n\t\t: null;\n\tdstPrim.setIndices(dstIndices);\n\n\t// (6) Remap attributes into joined Primitive.\n\tlet dstIndicesOffset = 0;\n\tfor (let primIndex = 0; primIndex < primRemaps.length; primIndex++) {\n\t\tconst srcPrim = prims[primIndex];\n\t\tconst srcIndices = srcPrim.getIndices();\n\t\tconst srcIndicesCount = srcIndices ? srcIndices.getCount() : -1;\n\n\t\tconst remap = primRemaps[primIndex];\n\n\t\tif (srcIndices && dstIndices) {\n\t\t\tremapIndices(srcIndices, remap, dstIndices, dstIndicesOffset);\n\t\t\tdstIndicesOffset += srcIndicesCount;\n\t\t}\n\n\t\tfor (const semantic of dstPrim.listSemantics()) {\n\t\t\tconst srcAttribute = srcPrim.getAttribute(semantic)!;\n\t\t\tconst dstAttribute = dstPrim.getAttribute(semantic)!;\n\t\t\tremapAttribute(srcAttribute, srcIndices, remap, dstAttribute);\n\t\t}\n\t}\n\n\treturn dstPrim;\n}\n\n/**\n * Internal variant of {@link compactAttribute}. Unlike compactAttribute,\n * assumes the vertex count cannot change, and avoids cloning attributes.\n * @hidden\n * @internal\n */\nfunction remapAttribute(\n\tsrcAttribute: Accessor,\n\tsrcIndices: Accessor | null,\n\tremap: TypedArray,\n\tdstAttribute: Accessor,\n): void {\n\tconst elementSize = srcAttribute.getElementSize();\n\tconst srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n\tconst srcVertexCount = srcAttribute.getCount();\n\tconst srcArray = srcAttribute.getArray()!;\n\tconst dstArray = dstAttribute.getArray()!;\n\tconst done = new Uint8Array(srcAttribute.getCount());\n\n\tfor (let i = 0, il = srcIndices ? srcIndices.getCount() : srcVertexCount; i < il; i++) {\n\t\tconst srcIndex = srcIndicesArray ? srcIndicesArray[i] : i;\n\t\tconst dstIndex = remap[srcIndex];\n\t\tif (done[dstIndex]) continue;\n\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[dstIndex * elementSize + j] = srcArray[srcIndex * elementSize + j];\n\t\t}\n\n\t\tdone[dstIndex] = 1;\n\t}\n}\n\n/**\n * Internal variant of {@link compactPrimitive}'s index remapping. Avoids\n * cloning indices; writes directly to `dstIndices`.\n * @hidden\n * @internal\n */\nfunction remapIndices(srcIndices: Accessor, remap: TypedArray, dstIndices: Accessor, dstOffset: number): void {\n\tconst srcCount = srcIndices.getCount();\n\tconst srcArray = srcIndices.getArray()!;\n\tconst dstArray = dstIndices.getArray()!;\n\n\tfor (let i = 0; i < srcCount; i++) {\n\t\tconst srcIndex = srcArray[i];\n\t\tconst dstIndex = remap[srcIndex];\n\t\tdstArray[dstOffset + i] = dstIndex;\n\t}\n}\n", "import {\n\tAnimationChannel,\n\ttype Document,\n\ttype Mesh,\n\ttype mat4,\n\ttype Node,\n\ttype Primitive,\n\tPropertyType,\n\ttype Scene,\n\ttype Transform,\n} from '@gltf-transform/core';\nimport { invert, multiply } from 'gl-matrix/mat4';\nimport { compactPrimitive } from './compact-primitive.js';\nimport { dequantizeAttribute } from './dequantize.js';\nimport { joinPrimitives } from './join-primitives.js';\nimport { prune } from './prune.js';\nimport { transformPrimitive } from './transform-primitive.js';\nimport { assignDefaults, createPrimGroupKey, createTransform, formatLong, isUsed } from './utils.js';\n\nconst NAME = 'join';\n\nconst { ROOT, NODE, MESH, PRIMITIVE, ACCESSOR } = PropertyType;\n\n// biome-ignore format: Readability.\nconst _matrix = [\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n] as mat4;\n\n/** Options for the {@link join} function. */\nexport interface JoinOptions {\n\t/**\n\t * Prevents joining distinct {@link Mesh Meshes} and {@link Node Nodes}.\n\t * Joins only Primitives found within the same parent Mesh. To preserve\n\t * only _named_ Nodes and Meshes, use\n\t * {@link JoinOptions.keepNamed keepNamed} instead. Default: false.\n\t */\n\tkeepMeshes?: boolean;\n\t/**\n\t * Prevents joining _named_ {@link Mesh Meshes} and {@link Node Nodes}.\n\t * If {@link JoinOptions.keepMeshes keepMeshes} is enabled, keepNamed will\n\t * have no effect. Default: false.\n\t */\n\tkeepNamed?: boolean;\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n\t/**\n\t * A filter function used to evaluate a condition on a given {@link Node Node}.\n\t * This function should return a boolean indicating whether the node\n\t * satisfies the provided condition.\n\t *\n\t * @param {Node} node - The node instance to be evaluated.\n\t * @returns {boolean} - The result of the evaluation; `true` if the condition is met, otherwise `false`.\n\t */\n\tfilter?: (node: Node) => boolean;\n}\n\nexport const JOIN_DEFAULTS: Required<JoinOptions> = {\n\tkeepMeshes: false,\n\tkeepNamed: false,\n\tcleanup: true,\n\tfilter: () => true,\n};\n\n/**\n * Joins compatible {@link Primitive Primitives} and reduces draw calls.\n * Primitives are eligible for joining if they are members of the same\n * {@link Mesh} or, optionally, attached to sibling {@link Node Nodes}\n * in the scene hierarchy. For best results, apply {@link dedup} and\n * {@link flatten} first to maximize the number of Primitives that\n * can be joined.\n *\n * NOTE: In a Scene that heavily reuses the same Mesh data, joining may\n * increase vertex count. Consider alternatives, like\n * {@link instance instancing} with {@link EXTMeshGPUInstancing}.\n *\n * Example:\n *\n * ```ts\n * import { PropertyType } from '@gltf-transform/core';\n * import { join, flatten, dedup } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tdedup({ propertyTypes: [PropertyType.MATERIAL] }),\n * \tflatten(),\n * \tjoin({ keepNamed: false }),\n * );\n * ```\n *\n * @category Transforms\n */\nexport function join(_options: JoinOptions = JOIN_DEFAULTS): Transform {\n\tconst options = assignDefaults(JOIN_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\t// Join.\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t_joinLevel(document, scene, options);\n\t\t\tscene.traverse((node) => _joinLevel(document, node, options));\n\t\t}\n\n\t\t// Clean up.\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [NODE, MESH, PRIMITIVE, ACCESSOR],\n\t\t\t\t\tkeepAttributes: true,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t\tkeepLeaves: false,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\ninterface IJoinGroup {\n\tkey: string;\n\tprims: Primitive[];\n\tprimMeshes: Mesh[];\n\tprimNodes: Node[];\n\tdstNode: Node;\n\tdstMesh?: Mesh | undefined;\n}\n\nfunction _joinLevel(document: Document, parent: Node | Scene, options: Required<JoinOptions>) {\n\tconst logger = document.getLogger();\n\tconst groups = {} as Record<string, IJoinGroup>;\n\n\t// Scan for compatible Primitives.\n\tconst children = parent.listChildren();\n\tfor (let nodeIndex = 0; nodeIndex < children.length; nodeIndex++) {\n\t\tconst node = children[nodeIndex];\n\n\t\t// Skip nodes not matching the filter.\n\t\tif (!options.filter(node)) continue;\n\n\t\t// Skip animated nodes.\n\t\tconst isAnimated = node.listParents().some((p) => p instanceof AnimationChannel);\n\t\tif (isAnimated) continue;\n\n\t\t// Skip nodes without meshes.\n\t\tconst mesh = node.getMesh();\n\t\tif (!mesh) continue;\n\n\t\t// Skip nodes with instancing; unsupported.\n\t\tif (node.getExtension('EXT_mesh_gpu_instancing')) continue;\n\n\t\t// Skip nodes with skinning; unsupported.\n\t\tif (node.getSkin()) continue;\n\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t// Skip prims with morph targets; unsupported.\n\t\t\tif (prim.listTargets().length > 0) continue;\n\n\t\t\t// Skip prims with volumetric materials; unsupported.\n\t\t\tconst material = prim.getMaterial();\n\t\t\tif (material && material.getExtension('KHR_materials_volume')) continue;\n\n\t\t\tcompactPrimitive(prim);\n\t\t\tdequantizeTransformableAttributes(prim);\n\n\t\t\tlet key = createPrimGroupKey(prim);\n\n\t\t\tconst isNamed = mesh.getName() || node.getName();\n\t\t\tif (options.keepMeshes || (options.keepNamed && isNamed)) {\n\t\t\t\tkey += `|${nodeIndex}`;\n\t\t\t}\n\n\t\t\tif (!(key in groups)) {\n\t\t\t\tgroups[key] = {\n\t\t\t\t\tprims: [] as Primitive[],\n\t\t\t\t\tprimMeshes: [] as Mesh[],\n\t\t\t\t\tprimNodes: [] as Node[],\n\t\t\t\t\tdstNode: node,\n\t\t\t\t\tdstMesh: undefined,\n\t\t\t\t} as IJoinGroup;\n\t\t\t}\n\n\t\t\tconst group = groups[key];\n\t\t\tgroup.prims.push(prim);\n\t\t\tgroup.primNodes.push(node);\n\t\t}\n\t}\n\n\t// Discard single-Primitive groups.\n\tconst joinGroups = Object.values(groups).filter(({ prims }) => prims.length > 1);\n\n\t// Unlink all affected Meshes at current level, before modifying Primitives.\n\tconst srcNodes = new Set<Node>(joinGroups.flatMap((group) => group.primNodes));\n\tfor (const node of srcNodes) {\n\t\tconst mesh = node.getMesh()!;\n\t\tconst isSharedMesh = mesh.listParents().some((parent) => {\n\t\t\treturn parent.propertyType !== ROOT && node !== parent;\n\t\t});\n\t\tif (isSharedMesh) {\n\t\t\tnode.setMesh(mesh.clone());\n\t\t}\n\t}\n\n\t// Update Meshes in groups.\n\tfor (const group of joinGroups) {\n\t\tconst { dstNode, primNodes } = group;\n\t\tgroup.dstMesh = dstNode.getMesh()!;\n\t\tgroup.primMeshes = primNodes.map((node) => node.getMesh()!);\n\t}\n\n\t// Join Primitives.\n\tfor (const group of joinGroups) {\n\t\tconst { prims, primNodes, primMeshes, dstNode, dstMesh } = group as Required<IJoinGroup>;\n\t\tconst dstMatrix = dstNode.getMatrix();\n\n\t\tfor (let i = 0; i < prims.length; i++) {\n\t\t\tconst primNode = primNodes[i];\n\t\t\tconst primMesh = primMeshes[i];\n\n\t\t\tlet prim = prims[i];\n\t\t\tprimMesh.removePrimitive(prim);\n\n\t\t\t// If Primitive is still in use after being removed from the\n\t\t\t// current mesh, above, make a deep copy. Because compactPrimitive()\n\t\t\t// was applied earlier in join(), we know the full vertex streams are\n\t\t\t// used, and no accessors are shared.\n\t\t\tif (isUsed(prim)) {\n\t\t\t\tprim = prims[i] = _deepClonePrimitive(prims[i]);\n\t\t\t}\n\n\t\t\t// Transform Primitive into new local coordinate space.\n\t\t\tif (primNode !== dstNode) {\n\t\t\t\tmultiply(_matrix, invert(_matrix, dstMatrix), primNode.getMatrix());\n\t\t\t\ttransformPrimitive(prim, _matrix);\n\t\t\t}\n\t\t}\n\n\t\tconst dstPrim = joinPrimitives(prims);\n\t\tconst dstVertexCount = dstPrim.listAttributes()[0].getCount();\n\t\tdstMesh.addPrimitive(dstPrim);\n\n\t\tlogger.debug(\n\t\t\t`${NAME}: Joined Primitives (${prims.length}) containing ` +\n\t\t\t\t`${formatLong(dstVertexCount)} vertices under Node \"${dstNode.getName()}\".`,\n\t\t);\n\t}\n}\n\nfunction _deepClonePrimitive(src: Primitive): Primitive {\n\t// compactPrimitive already applied; no vertices are unused.\n\tconst dst = src.clone();\n\tfor (const semantic of dst.listSemantics()) {\n\t\tdst.setAttribute(semantic, dst.getAttribute(semantic)!.clone());\n\t}\n\tconst indices = dst.getIndices();\n\tif (indices) dst.setIndices(indices.clone());\n\treturn dst;\n}\n\n/**\n * Dequantize attributes that would be affected by {@link transformPrimitive},\n * to avoid invalidating our primitive group keys.\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/844\n */\nfunction dequantizeTransformableAttributes(prim: Primitive) {\n\tfor (const semantic of ['POSITION', 'NORMAL', 'TANGENT']) {\n\t\tconst attribute = prim.getAttribute(semantic);\n\t\tif (attribute) dequantizeAttribute(attribute);\n\t}\n}\n", "import { Document, Material, PropertyType, type Texture, TextureChannel } from '@gltf-transform/core';\n\n/**\n * Returns a list of {@link TextureChannel TextureChannels} used by the given\n * texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel\n * in use. See {@link getTextureChannelMask} for bitmask alternative.\n *\n * Example:\n *\n * ```js\n * const channels = listTextureChannels(texture);\n * if (channels.includes(TextureChannel.R)) {\n *   console.log('texture red channel used');\n * }\n * ```\n */\nexport function listTextureChannels(texture: Texture): TextureChannel[] {\n\tconst mask = getTextureChannelMask(texture);\n\tconst channels = [];\n\tif (mask & TextureChannel.R) channels.push(TextureChannel.R);\n\tif (mask & TextureChannel.G) channels.push(TextureChannel.G);\n\tif (mask & TextureChannel.B) channels.push(TextureChannel.B);\n\tif (mask & TextureChannel.A) channels.push(TextureChannel.A);\n\treturn channels;\n}\n\n/**\n * Returns bitmask of all {@link TextureChannel TextureChannels} used by the\n * given texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel.\n * See {@link listTextureChannels} for an array alternative.\n *\n * Example:\n *\n * ```js\n * const mask = getTextureChannelMask(texture);\n * if (mask & TextureChannel.R) {\n *   console.log('texture red channel used');\n * }\n * ```\n */\nexport function getTextureChannelMask(texture: Texture): number {\n\tconst document = Document.fromGraph(texture.getGraph())!;\n\tlet mask = 0x0000;\n\tfor (const edge of document.getGraph().listParentEdges(texture)) {\n\t\tconst parent = edge.getParent();\n\t\tlet { channels } = edge.getAttributes() as { channels: number | undefined };\n\n\t\tif (\n\t\t\tchannels &&\n\t\t\tedge.getName() === 'baseColorTexture' &&\n\t\t\tparent instanceof Material &&\n\t\t\tparent.getAlphaMode() === Material.AlphaMode.OPAQUE\n\t\t) {\n\t\t\tchannels &= ~TextureChannel.A;\n\t\t}\n\n\t\tif (channels) {\n\t\t\tmask |= channels;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\tdocument.getLogger().warn(`Missing attribute \".channels\" on edge, \"${edge.getName()}\".`);\n\t\t}\n\t}\n\treturn mask;\n}\n", "import {\n\ttype Accessor,\n\ttype GLTF,\n\tMathUtils,\n\ttype Primitive,\n\ttype PrimitiveTarget,\n\ttype TypedArray,\n\ttype vec4,\n} from '@gltf-transform/core';\n\n/**\n * Sorts skinning weights from high to low, for each vertex of the input\n * {@link Primitive} or {@link PrimitiveTarget}, and normalizes the weights.\n * Optionally, uses the given 'limit' to remove least-significant joint\n * influences such that no vertex has more than 'limit' influences.\n *\n * Most realtime engines support a limited number of joint influences per vertex,\n * often 4 or 8. Sorting and removing the additional influences can reduce file\n * size and improve compatibility.\n *\n * Example:\n *\n * ```javascript\n * import { sortPrimitiveWeights } from '@gltf-transform/functions';\n *\n * const limit = 4;\n * for (const mesh of document.getRoot().listMeshes()) {\n * \tfor (const prim of mesh.listPrimitives()) {\n * \t\tsortPrimitiveWeights(prim, limit);\n * \t}\n * }\n * ```\n *\n * @param prim Input, to be modified in place.\n * @param limit Maximum number of joint influences per vertex. Must be a multiple of four.\n */\nexport function sortPrimitiveWeights(prim: Primitive | PrimitiveTarget, limit: number = Infinity): void {\n\tif ((Number.isFinite(limit) && limit % 4) || limit <= 0) {\n\t\tthrow new Error(`Limit must be positive multiple of four.`);\n\t}\n\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst setCount = prim.listSemantics().filter((name) => name.startsWith('WEIGHTS_')).length;\n\n\t// (1) Sort.\n\n\tconst indices = new Uint16Array(setCount * 4);\n\tconst srcWeights = new Float32Array(setCount * 4);\n\tconst dstWeights = new Float32Array(setCount * 4);\n\tconst srcJoints = new Uint32Array(setCount * 4);\n\tconst dstJoints = new Uint32Array(setCount * 4);\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tgetVertexArray(prim, i, 'WEIGHTS', srcWeights);\n\t\tgetVertexArray(prim, i, 'JOINTS', srcJoints);\n\n\t\t// Sort indices to create a lookup table, indices[dstIndex]  srcIndex,\n\t\t// indexed into the weights and joints arrays.\n\t\tfor (let j = 0; j < setCount * 4; j++) indices[j] = j;\n\t\tindices.sort((a, b) => (srcWeights[a] > srcWeights[b] ? -1 : 1));\n\n\t\t// Sort weights and joints.\n\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\tdstWeights[j] = srcWeights[indices[j]];\n\t\t\tdstJoints[j] = srcJoints[indices[j]];\n\t\t}\n\n\t\tsetVertexArray(prim, i, 'WEIGHTS', dstWeights);\n\t\tsetVertexArray(prim, i, 'JOINTS', dstJoints);\n\t}\n\n\t// (2) Limit.\n\tfor (let i = setCount; i * 4 > limit; i--) {\n\t\tconst weights = prim.getAttribute(`WEIGHTS_${i - 1}`)!;\n\t\tconst joints = prim.getAttribute(`JOINTS_${i - 1}`)!;\n\t\tprim.setAttribute(`WEIGHTS_${i - 1}`, null);\n\t\tprim.setAttribute(`JOINTS_${i - 1}`, null);\n\t\tif (weights.listParents().length === 1) weights.dispose();\n\t\tif (joints.listParents().length === 1) joints.dispose();\n\t}\n\n\t// (3) Normalize.\n\tnormalizePrimitiveWeights(prim);\n}\n\n// Utilities.\n\ntype PrimLike = Primitive | PrimitiveTarget;\n\nfunction normalizePrimitiveWeights(prim: PrimLike): void {\n\t// TODO(feat): Convert attributes to same component types when necessary.\n\tif (!isNormalizeSafe(prim)) return;\n\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst setCount = prim.listSemantics().filter((name) => name.startsWith('WEIGHTS_')).length;\n\n\tconst templateAttribute = prim.getAttribute('WEIGHTS_0')!;\n\tconst templateArray = templateAttribute.getArray()!;\n\tconst componentType = templateAttribute.getComponentType();\n\tconst normalized = templateAttribute.getNormalized();\n\tconst normalizedComponentType = normalized ? componentType : undefined;\n\tconst delta = normalized ? MathUtils.decodeNormalizedInt(1, componentType) : Number.EPSILON;\n\tconst joints = new Uint32Array(setCount * 4).fill(0);\n\tconst weights = templateArray.slice(0, setCount * 4).fill(0);\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tgetVertexArray(prim, i, 'JOINTS', joints);\n\t\tgetVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n\n\t\tlet weightsSum = sum(weights, normalizedComponentType);\n\n\t\tif (weightsSum !== 0 && weightsSum !== 1) {\n\t\t\t// (1) If sum of weights not within  of 1, renormalize all weights.\n\t\t\tif (Math.abs(1 - weightsSum) > delta) {\n\t\t\t\tfor (let j = 0; j < weights.length; j++) {\n\t\t\t\t\tif (normalized) {\n\t\t\t\t\t\tconst floatValue = MathUtils.decodeNormalizedInt(weights[j], componentType);\n\t\t\t\t\t\tweights[j] = MathUtils.encodeNormalizedInt(floatValue / weightsSum, componentType);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tweights[j] /= weightsSum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tweightsSum = sum(weights, normalizedComponentType);\n\n\t\t\t// (2) Sum of normalized weights may still be off by . Compensate\n\t\t\t// in least-significant weight.\n\t\t\tif (normalized && weightsSum !== 1) {\n\t\t\t\tfor (let j = weights.length - 1; j >= 0; j--) {\n\t\t\t\t\tif (weights[j] > 0) {\n\t\t\t\t\t\t// Normalized integer encoding will clamp negative values, so separate the sign.\n\t\t\t\t\t\tconst delta = 1 - weightsSum;\n\t\t\t\t\t\tweights[j] += Math.sign(delta) * MathUtils.encodeNormalizedInt(Math.abs(delta), componentType);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (3) Remove joint indices whose weights have fallen to zero.\n\t\tfor (let j = weights.length - 1; j >= 0; j--) {\n\t\t\tif (weights[j] === 0) {\n\t\t\t\tjoints[j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tsetVertexArray(prim, i, 'JOINTS', joints);\n\t\tsetVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n\t}\n}\n\n/** Lists all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction getVertexArray(\n\tprim: PrimLike,\n\tvertexIndex: number,\n\tprefix: string,\n\ttarget: TypedArray,\n\tnormalizedComponentType?: GLTF.AccessorComponentType,\n): TypedArray {\n\tlet weights: Accessor | null;\n\tconst el = [0, 0, 0, 0] as vec4;\n\tfor (let i = 0; (weights = prim.getAttribute(`${prefix}_${i}`)); i++) {\n\t\tweights.getElement(vertexIndex, el);\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\tif (normalizedComponentType) {\n\t\t\t\ttarget[i * 4 + j] = MathUtils.encodeNormalizedInt(el[j], normalizedComponentType);\n\t\t\t} else {\n\t\t\t\ttarget[i * 4 + j] = el[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n}\n\n/** Sets all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction setVertexArray(\n\tprim: PrimLike,\n\tvertexIndex: number,\n\tprefix: string,\n\tvalues: TypedArray,\n\tnormalizedComponentType?: GLTF.AccessorComponentType,\n): void {\n\tlet weights: Accessor | null;\n\tconst el = [0, 0, 0, 0] as vec4;\n\tfor (let i = 0; (weights = prim.getAttribute(`${prefix}_${i}`)); i++) {\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\tif (normalizedComponentType) {\n\t\t\t\tel[j] = MathUtils.decodeNormalizedInt(values[i * 4 + j], normalizedComponentType);\n\t\t\t} else {\n\t\t\t\tel[j] = values[i * 4 + j];\n\t\t\t}\n\t\t}\n\t\tweights.setElement(vertexIndex, el);\n\t}\n}\n\n/** Sum an array of numbers. */\nfunction sum(values: TypedArray, normalizedComponentType?: GLTF.AccessorComponentType): number {\n\tlet sum = 0;\n\tfor (let i = 0; i < values.length; i++) {\n\t\tif (normalizedComponentType) {\n\t\t\tsum += MathUtils.decodeNormalizedInt(values[i], normalizedComponentType);\n\t\t} else {\n\t\t\tsum += values[i];\n\t\t}\n\t}\n\treturn sum;\n}\n\n/** Returns true if attribute normalization is supported for this primitive. */\nfunction isNormalizeSafe(prim: PrimLike): boolean {\n\tconst attributes = prim\n\t\t.listSemantics()\n\t\t.filter((name) => name.startsWith('WEIGHTS_'))\n\t\t.map((name) => prim.getAttribute(name)!);\n\tconst normList = attributes.map((a) => a.getNormalized());\n\tconst typeList = attributes.map((a) => a.getComponentType());\n\treturn new Set(normList).size === 1 && new Set(typeList).size === 1;\n}\n", "import {\n\tAccessor,\n\tAnimationChannel,\n\ttype bbox,\n\ttype Document,\n\ttype ILogger,\n\tMathUtils,\n\ttype Mesh,\n\ttype mat4,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\ttype Skin,\n\ttype Transform,\n\ttype vec2,\n\ttype vec3,\n\ttype vec4,\n} from '@gltf-transform/core';\nimport type { Volume } from '@gltf-transform/extensions';\nimport { type InstancedMesh, KHRMeshQuantization } from '@gltf-transform/extensions';\nimport { fromRotationTranslationScale, fromScaling, invert, multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { max, min, scale, transformMat4 } from 'gl-matrix/vec3';\nimport { compactPrimitive } from './compact-primitive.js';\nimport { dedup } from './dedup.js';\nimport { getPrimitiveVertexCount, VertexCountMethod } from './get-vertex-count.js';\nimport { prune } from './prune.js';\nimport { sortPrimitiveWeights } from './sort-primitive-weights.js';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'quantize';\n\ntype TypedArrayConstructor =\n\t| Int8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Uint16ArrayConstructor;\nconst SIGNED_INT = [Int8Array, Int16Array, Int32Array] as TypedArrayConstructor[];\n\nconst { TRANSLATION, ROTATION, SCALE, WEIGHTS } = AnimationChannel.TargetPath;\nconst TRS_CHANNELS = [TRANSLATION, ROTATION, SCALE];\n\n/** Options for the {@link quantize} function. */\nexport interface QuantizeOptions {\n\t/** Pattern (regex) used to filter vertex attribute semantics for quantization. Default: all. */\n\tpattern?: RegExp;\n\t/** Pattern (regex) used to filter morph target semantics for quantization. Default: `options.pattern`. */\n\tpatternTargets?: RegExp;\n\t/** Bounds for quantization grid. */\n\tquantizationVolume?: 'mesh' | 'scene';\n\t/** Quantization bits for `POSITION` attributes. */\n\tquantizePosition?: number;\n\t/** Quantization bits for `NORMAL` attributes. */\n\tquantizeNormal?: number;\n\t/** Quantization bits for `TEXCOORD_*` attributes. */\n\tquantizeTexcoord?: number;\n\t/** Quantization bits for `COLOR_*` attributes. */\n\tquantizeColor?: number;\n\t/** Quantization bits for `WEIGHT_*` attributes. */\n\tquantizeWeight?: number;\n\t/** Quantization bits for application-specific (`_*`) attributes. */\n\tquantizeGeneric?: number;\n\t/** Normalize weight attributes. */\n\tnormalizeWeights?: boolean;\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nexport const QUANTIZE_DEFAULTS: Required<Omit<QuantizeOptions, 'patternTargets'>> = {\n\tpattern: /.*/,\n\tquantizationVolume: 'mesh',\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeTexcoord: 12,\n\tquantizeColor: 8,\n\tquantizeWeight: 8,\n\tquantizeGeneric: 12,\n\tnormalizeWeights: true,\n\tcleanup: true,\n};\n\n/**\n * References:\n * - https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n * - http://www.aclockworkberry.com/normal-unpacking-quantization-errors/\n * - https://www.mathworks.com/help/dsp/ref/uniformencoder.html\n * - https://oroboro.com/compressed-unit-vectors/\n */\n\n/**\n * Quantizes vertex attributes with `KHR_mesh_quantization`, reducing the size and memory footprint\n * of the file. Conceptually, quantization refers to snapping values to regular intervals; vertex\n * positions are snapped to a 3D grid, UVs to a 2D grid, and so on. When quantized to <= 16 bits,\n * larger component types may be more compactly stored as 16-bit or 8-bit attributes.\n *\n * Often, it can be useful to quantize to precision lower than the maximum allowed by the component\n * type. Positions quantized to 14 bits in a 16-bit accessor will occupy 16 bits in VRAM, but they\n * can be compressed further for network compression with lossless encodings such as ZSTD.\n *\n * Vertex positions are shifted into [-1,1] or [0,1] range before quantization. Compensating for\n * that shift, a transform is applied to the parent {@link Node}, or inverse bind matrices for a\n * {@link Skin} if applicable. Materials using {@link KHRMaterialsVolume} are adjusted to maintain\n * appearance. In future releases, UVs may also be transformed with {@link KHRTextureTransform}.\n * Currently UVs outside of [0,1] range are not quantized.\n *\n * In most cases, quantization requires {@link KHRMeshQuantization}; the extension will be added\n * automatically when `quantize()` is applied. When applying meshopt compression with\n * {@link EXTMeshoptCompression}, quantization is usually applied before compression.\n *\n * Example:\n *\n * ```javascript\n * import { quantize } from '@gltf-transform/functions';\n *\n * await document.transform(\n *   quantize({\n *\t\tquantizePosition: 14,\n *\t\tquantizeNormal: 10,\n *   }),\n * );\n * ```\n *\n * For the inverse operation, see {@link dequantize}.\n *\n * @category Transforms\n */\nexport function quantize(_options: QuantizeOptions = QUANTIZE_DEFAULTS): Transform {\n\tconst options = assignDefaults(QUANTIZE_DEFAULTS, {\n\t\tpatternTargets: _options.pattern || QUANTIZE_DEFAULTS.pattern,\n\t\t..._options,\n\t});\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst root = document.getRoot();\n\n\t\t// Compute vertex position quantization volume.\n\t\tlet nodeTransform: VectorTransform<vec3> | undefined;\n\t\tif (options.quantizationVolume === 'scene') {\n\t\t\tnodeTransform = getNodeTransform(expandBounds(root.listMeshes().map(getPositionQuantizationVolume)));\n\t\t}\n\n\t\t// Quantize mesh primitives.\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tif (options.quantizationVolume === 'mesh') {\n\t\t\t\tnodeTransform = getNodeTransform(getPositionQuantizationVolume(mesh));\n\t\t\t}\n\n\t\t\tif (nodeTransform && options.pattern.test('POSITION')) {\n\t\t\t\ttransformMeshParents(document, mesh, nodeTransform);\n\t\t\t\ttransformMeshMaterials(mesh, 1 / nodeTransform.scale);\n\t\t\t}\n\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst renderCount = getPrimitiveVertexCount(prim, VertexCountMethod.RENDER);\n\t\t\t\tconst uploadCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n\t\t\t\tif (renderCount < uploadCount / 2) {\n\t\t\t\t\tcompactPrimitive(prim);\n\t\t\t\t}\n\t\t\t\tquantizePrimitive(document, prim, nodeTransform!, options);\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tquantizePrimitive(document, target, nodeTransform!, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst needsExtension = root\n\t\t\t.listMeshes()\n\t\t\t.flatMap((mesh) => mesh.listPrimitives())\n\t\t\t.some(isQuantizedPrimitive);\n\t\tif (needsExtension) {\n\t\t\tdocument.createExtension(KHRMeshQuantization).setRequired(true);\n\t\t}\n\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.SKIN, PropertyType.MATERIAL],\n\t\t\t\t\tkeepAttributes: true,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t\tkeepLeaves: true,\n\t\t\t\t\tkeepSolidTextures: true,\n\t\t\t\t}),\n\t\t\t\tdedup({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.MATERIAL, PropertyType.SKIN],\n\t\t\t\t\tkeepUniqueNames: true,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction quantizePrimitive(\n\tdocument: Document,\n\tprim: Primitive | PrimitiveTarget,\n\tnodeTransform: VectorTransform<vec3>,\n\toptions: Required<QuantizeOptions>,\n): void {\n\tconst isTarget = prim instanceof PrimitiveTarget;\n\tconst logger = document.getLogger();\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (!isTarget && !options.pattern.test(semantic)) continue;\n\t\tif (isTarget && !options.patternTargets.test(semantic)) continue;\n\n\t\tconst srcAttribute = prim.getAttribute(semantic)!;\n\n\t\tconst { bits, ctor } = getQuantizationSettings(semantic, srcAttribute, logger, options);\n\n\t\tif (!ctor) continue;\n\t\tif (bits < 8 || bits > 16) throw new Error(`${NAME}: Requires bits = 816.`);\n\t\tif (srcAttribute.getComponentSize() <= bits / 8) continue;\n\n\t\tconst dstAttribute = srcAttribute.clone();\n\n\t\t// Remap position data.\n\t\tif (semantic === 'POSITION') {\n\t\t\tconst scale = nodeTransform.scale;\n\t\t\tconst transform: mat4 = [] as unknown as mat4;\n\t\t\t// Morph targets are relative offsets, don't translate them.\n\t\t\tprim instanceof Primitive\n\t\t\t\t? invert(transform, fromTransform(nodeTransform))\n\t\t\t\t: fromScaling(transform, [1 / scale, 1 / scale, 1 / scale]);\n\t\t\tfor (let i = 0, el: vec3 = [0, 0, 0], il = dstAttribute.getCount(); i < il; i++) {\n\t\t\t\tdstAttribute.getElement(i, el);\n\t\t\t\tdstAttribute.setElement(i, transformMat4(el, el, transform) as vec3);\n\t\t\t}\n\t\t}\n\n\t\t// Quantize the vertex attribute.\n\t\tquantizeAttribute(dstAttribute, ctor, bits);\n\t\tprim.setAttribute(semantic, dstAttribute);\n\t}\n\n\t// Normalize skinning weights.\n\tif (options.normalizeWeights && prim.getAttribute('WEIGHTS_0')) {\n\t\tsortPrimitiveWeights(prim, Infinity);\n\t}\n\n\tif (\n\t\tprim instanceof Primitive &&\n\t\tprim.getIndices() &&\n\t\tprim.listAttributes().length &&\n\t\tprim.listAttributes()[0]!.getCount() < 65535\n\t) {\n\t\tconst indices = prim.getIndices()!;\n\t\tindices.setArray(new Uint16Array(indices.getArray()!));\n\t}\n}\n\n/** Computes node quantization transforms in local space. */\nfunction getNodeTransform(volume: bbox): VectorTransform<vec3> {\n\tconst { min, max } = volume;\n\n\t// Scaling factor transforms [-1,1] box to the mesh AABB in local space.\n\t// See: https://github.com/donmccurdy/glTF-Transform/issues/328\n\tconst scale = Math.max(\n\t\t(max[0] - min[0]) / 2, // Divide because interval [-1,1] has length 2.\n\t\t(max[1] - min[1]) / 2,\n\t\t(max[2] - min[2]) / 2,\n\t);\n\n\t// Original center of the mesh, in local space.\n\tconst offset: vec3 = [\n\t\tmin[0] + (max[0] - min[0]) / 2,\n\t\tmin[1] + (max[1] - min[1]) / 2,\n\t\tmin[2] + (max[2] - min[2]) / 2,\n\t];\n\n\treturn { offset, scale };\n}\n\n/** Applies corrective scale and offset to nodes referencing a quantized Mesh. */\nfunction transformMeshParents(document: Document, mesh: Mesh, nodeTransform: VectorTransform<vec3>): void {\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tfor (const parent of mesh.listParents()) {\n\t\tif (!(parent instanceof Node)) continue;\n\n\t\tconst animChannels = parent.listParents().filter((p) => p instanceof AnimationChannel) as AnimationChannel[];\n\t\tconst isAnimated = animChannels.some((channel) => TRS_CHANNELS.includes(channel.getTargetPath()!));\n\t\tconst isParentNode = parent.listChildren().length > 0;\n\n\t\tconst skin = parent.getSkin();\n\t\tif (skin) {\n\t\t\tparent.setSkin(transformSkin(skin, nodeTransform));\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst batch = parent.getExtension<InstancedMesh>('EXT_mesh_gpu_instancing');\n\t\tif (batch) {\n\t\t\tparent.setExtension('EXT_mesh_gpu_instancing', transformBatch(document, batch, nodeTransform));\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet targetNode: Node;\n\t\tif (isParentNode || isAnimated) {\n\t\t\ttargetNode = document.createNode('').setMesh(mesh);\n\t\t\tparent.addChild(targetNode).setMesh(null);\n\t\t\tanimChannels\n\t\t\t\t.filter((channel) => channel.getTargetPath() === WEIGHTS)\n\t\t\t\t.forEach((channel) => channel.setTargetNode(targetNode));\n\t\t} else {\n\t\t\ttargetNode = parent;\n\t\t}\n\n\t\tconst nodeMatrix = targetNode.getMatrix();\n\t\tmultiplyMat4(nodeMatrix, nodeMatrix, transformMatrix);\n\t\ttargetNode.setMatrix(nodeMatrix);\n\t}\n}\n\n/** Applies corrective scale and offset to skin IBMs. */\nfunction transformSkin(skin: Skin, nodeTransform: VectorTransform<vec3>): Skin {\n\tskin = skin.clone(); // quantize() does cleanup.\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tconst inverseBindMatrices = skin.getInverseBindMatrices()!.clone();\n\tconst ibm = [] as unknown as mat4;\n\tfor (let i = 0, count = inverseBindMatrices.getCount(); i < count; i++) {\n\t\tinverseBindMatrices.getElement(i, ibm);\n\t\tmultiplyMat4(ibm, ibm, transformMatrix);\n\t\tinverseBindMatrices.setElement(i, ibm);\n\t}\n\treturn skin.setInverseBindMatrices(inverseBindMatrices);\n}\n\n/** Applies corrective scale and offset to GPU instancing batches. */\nfunction transformBatch(document: Document, batch: InstancedMesh, nodeTransform: VectorTransform<vec3>): InstancedMesh {\n\tif (!batch.getAttribute('TRANSLATION') && !batch.getAttribute('ROTATION') && !batch.getAttribute('SCALE')) {\n\t\treturn batch;\n\t}\n\n\tbatch = batch.clone(); // quantize() does cleanup.\n\n\tlet instanceTranslation = batch.getAttribute('TRANSLATION')?.clone();\n\tconst instanceRotation = batch.getAttribute('ROTATION')?.clone();\n\tlet instanceScale = batch.getAttribute('SCALE')?.clone();\n\n\tconst tpl = (instanceTranslation || instanceRotation || instanceScale)!;\n\n\tconst T_IDENTITY = [0, 0, 0] as vec3;\n\tconst R_IDENTITY = [0, 0, 0, 1] as vec4;\n\tconst S_IDENTITY = [1, 1, 1] as vec3;\n\n\t// Transformed batch may now require instance translation or scale.\n\t// See: https://github.com/donmccurdy/glTF-Transform/issues/1584\n\n\tif (!instanceTranslation && nodeTransform.offset) {\n\t\tinstanceTranslation = document.createAccessor().setType('VEC3').setArray(makeArray(tpl.getCount(), T_IDENTITY));\n\t}\n\n\tif (!instanceScale && nodeTransform.scale) {\n\t\tinstanceScale = document.createAccessor().setType('VEC3').setArray(makeArray(tpl.getCount(), S_IDENTITY));\n\t}\n\n\tconst t = [0, 0, 0] as vec3;\n\tconst r = [0, 0, 0, 1] as vec4;\n\tconst s = [1, 1, 1] as vec3;\n\n\t// biome-ignore format: Readability.\n\tconst instanceMatrix = [\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1,\n\t] as mat4;\n\n\tconst transformMatrix = fromTransform(nodeTransform);\n\n\tfor (let i = 0, count = tpl.getCount(); i < count; i++) {\n\t\tMathUtils.compose(\n\t\t\tinstanceTranslation ? (instanceTranslation.getElement(i, t) as vec3) : T_IDENTITY,\n\t\t\tinstanceRotation ? (instanceRotation.getElement(i, r) as vec4) : R_IDENTITY,\n\t\t\tinstanceScale ? (instanceScale.getElement(i, s) as vec3) : S_IDENTITY,\n\t\t\tinstanceMatrix,\n\t\t);\n\n\t\tmultiplyMat4(instanceMatrix, instanceMatrix, transformMatrix);\n\n\t\tMathUtils.decompose(instanceMatrix, t, r, s);\n\n\t\tif (instanceTranslation) instanceTranslation.setElement(i, t);\n\t\tif (instanceRotation) instanceRotation.setElement(i, r);\n\t\tif (instanceScale) instanceScale.setElement(i, s);\n\t}\n\n\tif (instanceTranslation) batch.setAttribute('TRANSLATION', instanceTranslation);\n\tif (instanceRotation) batch.setAttribute('ROTATION', instanceRotation);\n\tif (instanceScale) batch.setAttribute('SCALE', instanceScale);\n\n\treturn batch;\n}\n\n/** Applies corrective scale to volumetric materials, which give thickness in local units. */\nfunction transformMeshMaterials(mesh: Mesh, scale: number) {\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tlet material = prim.getMaterial();\n\t\tif (!material) continue;\n\n\t\tlet volume = material.getExtension<Volume>('KHR_materials_volume');\n\t\tif (!volume || volume.getThicknessFactor() <= 0) continue;\n\n\t\t// quantize() does cleanup.\n\t\tvolume = volume.clone().setThicknessFactor(volume.getThicknessFactor() * scale);\n\t\tmaterial = material.clone().setExtension('KHR_materials_volume', volume);\n\t\tprim.setMaterial(material);\n\t}\n}\n\n/**\n * Quantizes an attribute to the given parameters.\n *\n * Uniformly remap 32-bit floats to reduced-precision 8- or 16-bit integers, so\n * that there are only 2^N unique values, for N within [8, 16].\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/208\n */\nfunction quantizeAttribute(attribute: Accessor, ctor: TypedArrayConstructor, bits: number): void {\n\tconst dstArray = new ctor(attribute.getArray()!.length);\n\n\tconst signBits = SIGNED_INT.includes(ctor) ? 1 : 0;\n\tconst quantBits = bits - signBits;\n\tconst storageBits = ctor.BYTES_PER_ELEMENT * 8 - signBits;\n\n\tconst scale = Math.pow(2, quantBits) - 1;\n\tconst lo = storageBits - quantBits;\n\tconst hi = 2 * quantBits - storageBits;\n\tconst range = [signBits > 0 ? -1 : 0, 1] as vec2;\n\n\tfor (let i = 0, di = 0, el: number[] = []; i < attribute.getCount(); i++) {\n\t\tattribute.getElement(i, el);\n\t\tfor (let j = 0; j < el.length; j++) {\n\t\t\t// Clamp to range.\n\t\t\tlet value = clamp(el[j], range);\n\n\t\t\t// Map [0.0 ... 1.0] to [0 ... scale].\n\t\t\tvalue = Math.round(Math.abs(value) * scale);\n\n\t\t\t// Replicate msb to missing lsb.\n\t\t\tvalue = (value << lo) | (value >> hi);\n\n\t\t\t// Restore sign.\n\t\t\tdstArray[di++] = value * Math.sign(el[j]);\n\t\t}\n\t}\n\n\t// TODO(feat): Support sparse accessors, https://github.com/donmccurdy/glTF-Transform/issues/795\n\tattribute.setArray(dstArray).setNormalized(true).setSparse(false);\n}\n\nfunction getQuantizationSettings(\n\tsemantic: string,\n\tattribute: Accessor,\n\tlogger: ILogger,\n\toptions: Required<QuantizeOptions>,\n): { bits: number; ctor?: TypedArrayConstructor } {\n\tconst min = attribute.getMinNormalized([]);\n\tconst max = attribute.getMaxNormalized([]);\n\n\tlet bits: number;\n\tlet ctor: TypedArrayConstructor;\n\n\tif (semantic === 'POSITION') {\n\t\tbits = options.quantizePosition;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic === 'NORMAL' || semantic === 'TANGENT') {\n\t\tbits = options.quantizeNormal;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\tbits = options.quantizeColor;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeTexcoord;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('JOINTS_')) {\n\t\tbits = Math.max(...attribute.getMax([])) <= 255 ? 8 : 16;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t\tif (attribute.getComponentSize() > bits / 8) {\n\t\t\tattribute.setArray(new ctor(attribute.getArray()!));\n\t\t}\n\t\treturn { bits: -1 };\n\t} else if (semantic.startsWith('WEIGHTS_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeWeight;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('_')) {\n\t\tif (min.some((v) => v < -1) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [-1,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeGeneric;\n\t\tctor = min.some((v) => v < 0)\n\t\t\t? (ctor = bits <= 8 ? Int8Array : Int16Array)\n\t\t\t: (ctor = bits <= 8 ? Uint8Array : Uint16Array);\n\t} else {\n\t\tthrow new Error(`${NAME}: Unexpected semantic, \"${semantic}\".`);\n\t}\n\n\treturn { bits, ctor };\n}\n\nfunction getPositionQuantizationVolume(mesh: Mesh): bbox {\n\tconst positions: Accessor[] = [];\n\tconst relativePositions: Accessor[] = [];\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst attribute = prim.getAttribute('POSITION');\n\t\tif (attribute) positions.push(attribute);\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tconst attribute = target.getAttribute('POSITION');\n\t\t\tif (attribute) relativePositions.push(attribute);\n\t\t}\n\t}\n\n\tif (positions.length === 0) {\n\t\tthrow new Error(`${NAME}: Missing \"POSITION\" attribute.`);\n\t}\n\n\tconst bbox = flatBounds<vec3>(positions, 3);\n\n\t// Morph target quantization volume is computed differently. First, ensure that the origin\n\t// <0, 0, 0> is in the quantization volume. Because we can't offset target positions (they're\n\t// relative deltas), default remapping will only map to a [-2, 2] AABB. Double the bounding box\n\t// to ensure scaling puts them within a [-1, 1] AABB instead.\n\tif (relativePositions.length > 0) {\n\t\tconst { min: relMin, max: relMax } = flatBounds<vec3>(relativePositions, 3);\n\t\tmin(bbox.min, bbox.min, min(relMin, scale(relMin, relMin, 2), [0, 0, 0]));\n\t\tmax(bbox.max, bbox.max, max(relMax, scale(relMax, relMax, 2), [0, 0, 0]));\n\t}\n\n\treturn bbox;\n}\n\nfunction isQuantizedAttribute(semantic: string, attribute: Accessor): boolean {\n\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview\n\tconst componentSize = attribute.getComponentSize();\n\tif (semantic === 'POSITION') return componentSize < 4;\n\tif (semantic === 'NORMAL') return componentSize < 4;\n\tif (semantic === 'TANGENT') return componentSize < 4;\n\tif (semantic.startsWith('TEXCOORD_')) {\n\t\tconst componentType = attribute.getComponentType();\n\t\tconst normalized = attribute.getNormalized();\n\t\treturn (\n\t\t\tcomponentSize < 4 &&\n\t\t\t!(normalized && componentType === Accessor.ComponentType.UNSIGNED_BYTE) &&\n\t\t\t!(normalized && componentType === Accessor.ComponentType.UNSIGNED_SHORT)\n\t\t);\n\t}\n\treturn false;\n}\n\nfunction isQuantizedPrimitive(prim: Primitive | PrimitiveTarget): boolean {\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute('POSITION')!;\n\t\tif (isQuantizedAttribute(semantic, attribute)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (prim.propertyType === PropertyType.PRIMITIVE) {\n\t\treturn prim.listTargets().some(isQuantizedPrimitive);\n\t}\n\treturn false;\n}\n\n/** Computes total min and max of all Accessors in a list. */\nfunction flatBounds<T = vec2 | vec3>(accessors: Accessor[], elementSize: number): { min: T; max: T } {\n\tconst min: number[] = new Array(elementSize).fill(Infinity);\n\tconst max: number[] = new Array(elementSize).fill(-Infinity);\n\n\tconst tmpMin: number[] = [];\n\tconst tmpMax: number[] = [];\n\n\tfor (const accessor of accessors) {\n\t\taccessor.getMinNormalized(tmpMin);\n\t\taccessor.getMaxNormalized(tmpMax);\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tmin[i] = Math.min(min[i], tmpMin[i]);\n\t\t\tmax[i] = Math.max(max[i], tmpMax[i]);\n\t\t}\n\t}\n\n\treturn { min, max } as unknown as { min: T; max: T };\n}\n\nfunction expandBounds(bboxes: bbox[]): bbox {\n\tconst result = bboxes[0];\n\tfor (const bbox of bboxes) {\n\t\tmin(result.min, result.min, bbox.min);\n\t\tmax(result.max, result.max, bbox.max);\n\t}\n\treturn result;\n}\n\ninterface VectorTransform<T = vec2 | vec3 | vec4> {\n\toffset: T;\n\tscale: number;\n}\n\nfunction fromTransform(transform: VectorTransform<vec3>): mat4 {\n\treturn fromRotationTranslationScale([] as unknown as mat4, [0, 0, 0, 1], transform.offset, [\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t]) as mat4;\n}\n\nfunction clamp(value: number, range: vec2): number {\n\treturn Math.min(Math.max(value, range[0]), range[1]);\n}\n\nfunction makeArray(elementCount: number, initialElement: vec2 | vec3 | vec4) {\n\tconst elementSize = initialElement.length;\n\tconst array = new Float32Array(elementCount * elementSize);\n\n\tfor (let i = 0; i < elementCount; i++) {\n\t\tarray.set(initialElement, i * elementSize);\n\t}\n\n\treturn array;\n}\n", "import { type Accessor, type Document, type GLTF, Primitive, PropertyType, type Transform } from '@gltf-transform/core';\nimport type { MeshoptEncoder } from 'meshoptimizer';\nimport { compactAttribute } from './compact-primitive.js';\nimport { prune } from './prune.js';\nimport { assignDefaults, createTransform, deepListAttributes, SetMap, shallowCloneAccessor } from './utils.js';\n\nconst NAME = 'reorder';\n\n/** Options for the {@link reorder} function. */\nexport interface ReorderOptions {\n\t/** MeshoptEncoder instance. */\n\tencoder: unknown;\n\t/**\n\t * Whether the order should be optimal for transmission size (recommended for Web)\n\t * or for GPU rendering performance. Default is 'size'.\n\t */\n\ttarget?: 'size' | 'performance';\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nconst REORDER_DEFAULTS: Required<Omit<ReorderOptions, 'encoder'>> = {\n\ttarget: 'size',\n\tcleanup: true,\n};\n\n/**\n * Optimizes {@link Mesh} {@link Primitive Primitives} for locality of reference. Choose whether\n * the order should be optimal for transmission size (recommended for Web) or for GPU rendering\n * performance. Requires a MeshoptEncoder instance from the Meshoptimizer library.\n *\n * Example:\n *\n * ```ts\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder})\n * );\n * ```\n *\n * @category Transforms\n */\nexport function reorder(_options: ReorderOptions): Transform {\n\tconst options = assignDefaults(REORDER_DEFAULTS, _options);\n\tconst encoder = options.encoder as typeof MeshoptEncoder | undefined;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${NAME}: encoder dependency required  install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tawait encoder.ready;\n\n\t\tconst plan = createLayoutPlan(document);\n\n\t\tfor (const srcIndices of plan.indicesToAttributes.keys()) {\n\t\t\tlet indicesArray = srcIndices.getArray()!;\n\t\t\tif (!(indicesArray instanceof Uint32Array)) {\n\t\t\t\tindicesArray = new Uint32Array(indicesArray);\n\t\t\t} else {\n\t\t\t\tindicesArray = indicesArray.slice();\n\t\t\t}\n\n\t\t\t// Compute optimal order.\n\t\t\tconst [remap, unique] = encoder.reorderMesh(\n\t\t\t\tindicesArray,\n\t\t\t\tplan.indicesToMode.get(srcIndices) === Primitive.Mode.TRIANGLES,\n\t\t\t\toptions.target === 'size',\n\t\t\t);\n\n\t\t\tconst dstIndices = shallowCloneAccessor(document, srcIndices);\n\t\t\tdstIndices.setArray(unique <= 65534 ? new Uint16Array(indicesArray) : indicesArray);\n\n\t\t\t// Update affected primitives.\n\t\t\tfor (const srcAttribute of plan.indicesToAttributes.get(srcIndices)) {\n\t\t\t\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute);\n\t\t\t\tcompactAttribute(srcAttribute, srcIndices, remap, dstAttribute, unique);\n\n\t\t\t\tfor (const prim of plan.indicesToPrimitives.get(srcIndices)) {\n\t\t\t\t\tif (prim.getIndices() === srcIndices) {\n\t\t\t\t\t\tprim.swap(srcIndices, dstIndices);\n\t\t\t\t\t}\n\n\t\t\t\t\tprim.swap(srcAttribute, dstAttribute);\n\t\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\t\ttarget.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up any attributes left unused by earlier cloning.\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR],\n\t\t\t\t\tkeepAttributes: true,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (!plan.indicesToAttributes.size) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found; may need to weld first.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\n/** @hidden */\ninterface LayoutPlan {\n\tindicesToMode: Map<Accessor, GLTF.MeshPrimitiveMode>;\n\tindicesToPrimitives: SetMap<Accessor, Primitive>;\n\tindicesToAttributes: SetMap<Accessor, Accessor>;\n\tattributesToPrimitives: SetMap<Accessor, Primitive>;\n}\n\n/**\n * Constructs a plan for processing vertex streams, based on unique\n * index:attribute[] groups. Where different indices are used with the same\n * attributes, we'll end up splitting the primitives to not share attributes,\n * which appears to be consistent with the Meshopt implementation.\n *\n * @hidden\n */\nfunction createLayoutPlan(document: Document): LayoutPlan {\n\tconst indicesToMode = new Map<Accessor, GLTF.MeshPrimitiveMode>();\n\tconst indicesToPrimitives = new SetMap<Accessor, Primitive>();\n\tconst indicesToAttributes = new SetMap<Accessor, Accessor>();\n\tconst attributesToPrimitives = new SetMap<Accessor, Primitive>();\n\n\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tconst indices = prim.getIndices();\n\t\t\tif (!indices) continue;\n\n\t\t\tindicesToMode.set(indices, prim.getMode());\n\t\t\tindicesToPrimitives.add(indices, prim);\n\n\t\t\tfor (const attribute of deepListAttributes(prim)) {\n\t\t\t\tindicesToAttributes.add(indices, attribute);\n\t\t\t\tattributesToPrimitives.add(attribute, prim);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { indicesToPrimitives, indicesToAttributes, indicesToMode, attributesToPrimitives };\n}\n", "import type { Document, Transform } from '@gltf-transform/core';\nimport { EXTMeshoptCompression } from '@gltf-transform/extensions';\nimport type { MeshoptEncoder } from 'meshoptimizer';\nimport { QUANTIZE_DEFAULTS, type QuantizeOptions, quantize } from './quantize.js';\nimport { reorder } from './reorder.js';\nimport { assignDefaults, createTransform } from './utils.js';\n\nexport interface MeshoptOptions extends Omit<QuantizeOptions, 'pattern' | 'patternTargets'> {\n\tencoder: unknown;\n\tlevel?: 'medium' | 'high';\n}\n\nexport const MESHOPT_DEFAULTS: Required<Omit<MeshoptOptions, 'encoder'>> = {\n\tlevel: 'high',\n\t...QUANTIZE_DEFAULTS,\n};\n\nconst NAME = 'meshopt';\n\n/**\n * Applies Meshopt compression using {@link EXTMeshoptCompression EXT_meshopt_compression}.\n * This type of compression can reduce the size of point, line, and triangle geometry,\n * morph targets, and animation data.\n *\n * This function is a thin wrapper around {@link reorder}, {@link quantize}, and\n * {@link EXTMeshoptCompression}, and exposes relatively few configuration options.\n * To access more options (like quantization bits) direct use of the underlying\n * functions is recommended.\n *\n * Example:\n *\n * ```javascript\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { meshopt } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n *   meshopt({encoder: MeshoptEncoder, level: 'medium'})\n * );\n * ```\n *\n * Compression is deferred until generating output with an I/O class.\n *\n * @category Transforms\n */\nexport function meshopt(_options: MeshoptOptions): Transform {\n\tconst options = assignDefaults(MESHOPT_DEFAULTS, _options);\n\tconst encoder = options.encoder as typeof MeshoptEncoder | undefined;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${NAME}: encoder dependency required  install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tlet pattern: RegExp;\n\t\tlet patternTargets: RegExp;\n\t\tlet quantizeNormal = options.quantizeNormal;\n\n\t\tif (document.getRoot().listAccessors().length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// IMPORTANT: Vertex attributes should be quantized in 'high' mode IFF they are\n\t\t// _not_ filtered in 'packages/extensions/src/ext-meshopt-compression/encoder.ts'.\n\t\t// Note that normals and tangents use octahedral filters, but _morph_ normals\n\t\t// and tangents do not.\n\t\t// See: https://github.com/donmccurdy/glTF-Transform/issues/1142\n\t\tif (options.level === 'medium') {\n\t\t\tpattern = /.*/;\n\t\t\tpatternTargets = /.*/;\n\t\t} else {\n\t\t\tpattern = /^(POSITION|TEXCOORD|JOINTS|WEIGHTS|COLOR)(_\\d+)?$/;\n\t\t\tpatternTargets = /^(POSITION|TEXCOORD|JOINTS|WEIGHTS|COLOR|NORMAL|TANGENT)(_\\d+)?$/;\n\t\t\tquantizeNormal = Math.min(quantizeNormal, 8); // See meshopt::getMeshoptFilter.\n\t\t}\n\n\t\tawait document.transform(\n\t\t\treorder({\n\t\t\t\tencoder: encoder,\n\t\t\t\ttarget: 'size',\n\t\t\t}),\n\t\t\tquantize({\n\t\t\t\t...options,\n\t\t\t\tpattern,\n\t\t\t\tpatternTargets,\n\t\t\t\tquantizeNormal,\n\t\t\t}),\n\t\t);\n\n\t\tdocument\n\t\t\t.createExtension(EXTMeshoptCompression)\n\t\t\t.setRequired(true)\n\t\t\t.setEncoderOptions({\n\t\t\t\tmethod:\n\t\t\t\t\toptions.level === 'medium'\n\t\t\t\t\t\t? EXTMeshoptCompression.EncoderMethod.QUANTIZE\n\t\t\t\t\t\t: EXTMeshoptCompression.EncoderMethod.FILTER,\n\t\t\t});\n\t});\n}\n", "import type { Document, Texture, Transform } from '@gltf-transform/core';\nimport {\n\tKHRMaterialsIOR,\n\tKHRMaterialsPBRSpecularGlossiness,\n\tKHRMaterialsSpecular,\n\ttype PBRSpecularGlossiness,\n} from '@gltf-transform/extensions';\nimport { createTransform, rewriteTexture } from './utils.js';\n\nconst NAME = 'metalRough';\n\nexport interface MetalRoughOptions {}\n\nconst METALROUGH_DEFAULTS: Required<MetalRoughOptions> = {};\n\n/**\n * Convert {@link Material}s from spec/gloss PBR workflow to metal/rough PBR workflow,\n * removing `KHR_materials_pbrSpecularGlossiness` and adding `KHR_materials_ior` and\n * `KHR_materials_specular`. The metal/rough PBR workflow is preferred for most use cases,\n * and is a prerequisite for other advanced PBR extensions provided by glTF.\n *\n * No options are currently implemented for this function.\n *\n * @category Transforms\n */\nexport function metalRough(_options: MetalRoughOptions = METALROUGH_DEFAULTS): Transform {\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tconst extensionsUsed = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.map((ext) => ext.extensionName);\n\t\tif (!extensionsUsed.includes('KHR_materials_pbrSpecularGlossiness')) {\n\t\t\tlogger.warn(`${NAME}: KHR_materials_pbrSpecularGlossiness not found on document.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst iorExtension = doc.createExtension(KHRMaterialsIOR);\n\t\tconst specExtension = doc.createExtension(KHRMaterialsSpecular);\n\t\tconst specGlossExtension = doc.createExtension(KHRMaterialsPBRSpecularGlossiness);\n\n\t\tconst inputTextures = new Set<Texture | null>();\n\n\t\tfor (const material of doc.getRoot().listMaterials()) {\n\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>('KHR_materials_pbrSpecularGlossiness');\n\t\t\tif (!specGloss) continue;\n\n\t\t\t// Create specular extension.\n\t\t\tconst specular = specExtension\n\t\t\t\t.createSpecular()\n\t\t\t\t.setSpecularFactor(1.0)\n\t\t\t\t.setSpecularColorFactor(specGloss.getSpecularFactor());\n\n\t\t\t// Stash textures that might become unused, to check and clean up later.\n\t\t\tinputTextures.add(specGloss.getSpecularGlossinessTexture());\n\t\t\tinputTextures.add(material.getBaseColorTexture());\n\t\t\tinputTextures.add(material.getMetallicRoughnessTexture());\n\n\t\t\t// Set up a metal/rough PBR material with IOR=Infinity (or 0), metallic=0. This\n\t\t\t// representation is precise and reliable, but perhaps less convenient for artists\n\t\t\t// than deriving a metalness value. Unfortunately we can't do that without imprecise\n\t\t\t// heuristics, and perhaps user tuning.\n\t\t\t// See: https://github.com/KhronosGroup/glTF/pull/1719#issuecomment-674365677\n\t\t\tmaterial\n\t\t\t\t.setBaseColorFactor(specGloss.getDiffuseFactor())\n\t\t\t\t.setMetallicFactor(0)\n\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t.setExtension('KHR_materials_ior', iorExtension.createIOR().setIOR(1000))\n\t\t\t\t.setExtension('KHR_materials_specular', specular);\n\n\t\t\t// Move diffuse -> baseColor.\n\t\t\tconst diffuseTexture = specGloss.getDiffuseTexture();\n\t\t\tif (diffuseTexture) {\n\t\t\t\tmaterial.setBaseColorTexture(diffuseTexture);\n\t\t\t\tmaterial.getBaseColorTextureInfo()!.copy(specGloss.getDiffuseTextureInfo()!);\n\t\t\t}\n\n\t\t\t// Move specular + gloss -> specular + roughness.\n\t\t\tconst sgTexture = specGloss.getSpecularGlossinessTexture();\n\t\t\tif (sgTexture) {\n\t\t\t\t// specularGlossiness -> specular.\n\t\t\t\tconst sgTextureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\tconst specularTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, specularTexture, (pixels, i, j) => {\n\t\t\t\t\tpixels.set(i, j, 3, 255); // Remove glossiness.\n\t\t\t\t});\n\t\t\t\tspecular.setSpecularTexture(specularTexture);\n\t\t\t\tspecular.setSpecularColorTexture(specularTexture);\n\t\t\t\tspecular.getSpecularTextureInfo()!.copy(sgTextureInfo);\n\t\t\t\tspecular.getSpecularColorTextureInfo()!.copy(sgTextureInfo);\n\n\t\t\t\t// specularGlossiness -> roughness.\n\t\t\t\tconst glossinessFactor = specGloss.getGlossinessFactor();\n\t\t\t\tconst metalRoughTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, metalRoughTexture, (pixels, i, j) => {\n\t\t\t\t\t// Invert glossiness.\n\t\t\t\t\tconst roughness = 255 - Math.round(pixels.get(i, j, 3) * glossinessFactor);\n\t\t\t\t\tpixels.set(i, j, 0, 0);\n\t\t\t\t\tpixels.set(i, j, 1, roughness);\n\t\t\t\t\tpixels.set(i, j, 2, 0);\n\t\t\t\t\tpixels.set(i, j, 3, 255);\n\t\t\t\t});\n\t\t\t\tmaterial.setMetallicRoughnessTexture(metalRoughTexture);\n\t\t\t\tmaterial.getMetallicRoughnessTextureInfo()!.copy(sgTextureInfo);\n\t\t\t} else {\n\t\t\t\tspecular.setSpecularColorFactor(specGloss.getSpecularFactor());\n\t\t\t\tmaterial.setRoughnessFactor(1 - specGloss.getGlossinessFactor());\n\t\t\t}\n\n\t\t\t// Remove KHR_materials_pbrSpecularGlossiness from the material.\n\t\t\tmaterial.setExtension('KHR_materials_pbrSpecularGlossiness', null);\n\t\t}\n\n\t\t// Remove KHR_materials_pbrSpecularGlossiness from the document.\n\t\tspecGlossExtension.dispose();\n\n\t\t// Clean up unused textures.\n\t\tfor (const tex of inputTextures) {\n\t\t\tif (tex && tex.listParents().length === 1) tex.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import {\n\ttype Accessor,\n\tDocument,\n\ttype Primitive,\n\ttype Transform,\n\ttype TypedArrayConstructor,\n} from '@gltf-transform/core';\nimport { createTransform, formatDeltaOp, shallowCloneAccessor } from './utils.js';\n\nconst NAME = 'unweld';\n\n/** Options for the {@link unweld} function. */\nexport interface UnweldOptions {}\n\nconst UNWELD_DEFAULTS: UnweldOptions = {};\n\n/**\n * De-index {@link Primitive}s, disconnecting any shared vertices. This operation will generally\n * increase the number of vertices in a mesh, but may be helpful for some geometry operations or\n * for creating hard edges.\n *\n * No options are currently implemented for this function.\n *\n * @category Transforms\n */\nexport function unweld(_options: UnweldOptions = UNWELD_DEFAULTS): Transform {\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst visited = new Map<Accessor, Map<Accessor, Accessor>>();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tunweldPrimitive(prim, visited);\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * @hidden\n * @internal\n */\nexport function unweldPrimitive(prim: Primitive, visited = new Map<Accessor, Map<Accessor, Accessor>>()): void {\n\tconst indices = prim.getIndices();\n\tif (!indices) return;\n\n\tconst graph = prim.getGraph();\n\tconst document = Document.fromGraph(graph)!;\n\tconst logger = document.getLogger();\n\n\tconst srcVertexCount = prim.getAttribute('POSITION')!.getCount();\n\n\t// Vertex attributes.\n\tfor (const srcAttribute of prim.listAttributes()) {\n\t\tprim.swap(srcAttribute, unweldAttribute(document, srcAttribute, indices, visited));\n\n\t\t// Clean up.\n\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t}\n\n\t// Morph target vertex attributes.\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const srcAttribute of target.listAttributes()) {\n\t\t\ttarget.swap(srcAttribute, unweldAttribute(document, srcAttribute, indices, visited));\n\n\t\t\t// Clean up.\n\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t}\n\t}\n\n\tconst dstVertexCount = prim.getAttribute('POSITION')!.getCount();\n\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n\n\t// Clean up.\n\tprim.setIndices(null);\n\tif (indices.listParents().length === 1) indices.dispose();\n}\n\nfunction unweldAttribute(\n\tdocument: Document,\n\tsrcAttribute: Accessor,\n\tindices: Accessor,\n\tvisited: Map<Accessor, Map<Accessor, Accessor>>,\n): Accessor {\n\tif (visited.has(srcAttribute) && visited.get(srcAttribute)!.has(indices)) {\n\t\treturn visited.get(srcAttribute)!.get(indices)!;\n\t}\n\n\tconst srcArray = srcAttribute.getArray()!;\n\tconst TypedArray = srcArray.constructor as TypedArrayConstructor;\n\tconst dstArray = new TypedArray(indices.getCount() * srcAttribute.getElementSize());\n\n\tconst indicesArray = indices.getArray()!;\n\tconst elementSize = srcAttribute.getElementSize();\n\tfor (let i = 0, il = indices.getCount(); i < il; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[i * elementSize + j] = srcArray[indicesArray[i] * elementSize + j];\n\t\t}\n\t}\n\n\tif (!visited.has(srcAttribute)) visited.set(srcAttribute, new Map());\n\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute).setArray(dstArray);\n\tvisited.get(srcAttribute)!.set(indices, dstAttribute);\n\n\treturn dstAttribute;\n}\n", "import type { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { normalize } from 'gl-matrix/vec3';\nimport { unweld } from './unweld.js';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'normals';\n\n/** Options for the {@link normals} function. */\nexport interface NormalsOptions {\n\t/** Whether to overwrite existing `NORMAL` attributes. */\n\toverwrite?: boolean;\n}\n\nconst NORMALS_DEFAULTS: Required<NormalsOptions> = {\n\toverwrite: false,\n};\n\n/**\n * Generates flat vertex normals for mesh primitives.\n *\n * Example:\n *\n * ```ts\n * import { normals } from '@gltf-transform/functions';\n *\n * await document.transform(normals({overwrite: true}));\n * ```\n *\n * @category Transforms\n */\nexport function normals(_options: NormalsOptions = NORMALS_DEFAULTS): Transform {\n\tconst options = assignDefaults(NORMALS_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tlet modified = 0;\n\n\t\tawait document.transform(unweld());\n\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst position = prim.getAttribute('POSITION')!;\n\t\t\t\tlet normal = prim.getAttribute('NORMAL');\n\n\t\t\t\tif (options.overwrite && normal) {\n\t\t\t\t\tnormal.dispose();\n\t\t\t\t} else if (normal) {\n\t\t\t\t\tlogger.debug(`${NAME}: Skipping primitive: NORMAL found.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnormal = document\n\t\t\t\t\t.createAccessor()\n\t\t\t\t\t.setArray(new Float32Array(position.getCount() * 3))\n\t\t\t\t\t.setType('VEC3');\n\n\t\t\t\tconst a = [0, 0, 0] as vec3;\n\t\t\t\tconst b = [0, 0, 0] as vec3;\n\t\t\t\tconst c = [0, 0, 0] as vec3;\n\n\t\t\t\tfor (let i = 0; i < position.getCount(); i += 3) {\n\t\t\t\t\tposition.getElement(i + 0, a);\n\t\t\t\t\tposition.getElement(i + 1, b);\n\t\t\t\t\tposition.getElement(i + 2, c);\n\n\t\t\t\t\tconst faceNormal = computeNormal(a, b, c);\n\n\t\t\t\t\tnormal.setElement(i + 0, faceNormal);\n\t\t\t\t\tnormal.setElement(i + 1, faceNormal);\n\t\t\t\t\tnormal.setElement(i + 2, faceNormal);\n\t\t\t\t}\n\n\t\t\t\tprim.setAttribute('NORMAL', normal);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\n// https://stackoverflow.com/a/23709352/1314762\nfunction computeNormal(a: vec3, b: vec3, c: vec3): vec3 {\n\tconst A = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];\n\tconst B = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];\n\tconst n = [\n\t\tA[1] * B[2] - A[2] * B[1], //\n\t\tA[2] * B[0] - A[0] * B[2],\n\t\tA[0] * B[1] - A[1] * B[0],\n\t] as vec3;\n\treturn normalize([0, 0, 0], n) as vec3;\n}\n", "import {\n\tColorUtils,\n\ttype Document,\n\ttype Material,\n\ttype Primitive,\n\tPropertyType,\n\ttype Texture,\n\tTextureInfo,\n\ttype Transform,\n\ttype vec4,\n} from '@gltf-transform/core';\nimport ndarray, { type NdArray, type TypedArray } from 'ndarray';\nimport { savePixels } from 'ndarray-pixels';\nimport { prune } from './prune.js';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'palette';\n\ntype TexturableProp = 'baseColor' | 'emissive' | 'metallicRoughness';\n\nexport interface PaletteOptions {\n\t/** Size (in pixels) of a single block within each palette texture. Default: 4. */\n\tblockSize?: number;\n\t/**\n\t * Minimum number of blocks in the palette texture. If fewer unique\n\t * material values are found, no palettes will be generated. Default: 5.\n\t */\n\tmin?: number;\n\t/**\n\t * Whether to keep unused vertex attributes, such as UVs without an assigned\n\t * texture. If kept, unused UV coordinates may prevent palette texture\n\t * creation. Default: false.\n\t */\n\tkeepAttributes?: boolean;\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nexport const PALETTE_DEFAULTS: Required<PaletteOptions> = {\n\tblockSize: 4,\n\tmin: 5,\n\tkeepAttributes: false,\n\tcleanup: true,\n};\n\n/**\n * Creates palette textures containing all unique values of scalar\n * {@link Material} properties within the scene, then merges materials. For\n * scenes with many solid-colored materials (often found in CAD, architectural,\n * or low-poly styles), texture palettes can reduce the number of materials\n * used, and significantly increase the number of {@link Mesh} objects eligible\n * for {@link join} operations.\n *\n * Materials already containing texture coordinates (UVs) are not eligible for\n * texture palette optimizations. Currently only a material's base color,\n * alpha, emissive factor, metallic factor, and roughness factor are converted\n * to palette textures.\n *\n * Example:\n *\n * ```typescript\n * import { palette, flatten, dequantize, join } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tpalette({ min: 5 }),\n * \tflatten(),\n * \tdequantize(),\n * \tjoin()\n * );\n * ```\n *\n * The illustration below shows a typical base color palette texture:\n *\n * <img\n * \tsrc=\"/media/functions/palette.png\"\n * \talt=\"Row of colored blocks\"\n * \tstyle=\"width: 100%; max-width: 320px; image-rendering: pixelated;\">\n *\n * @category Transforms\n */\nexport function palette(_options: PaletteOptions = PALETTE_DEFAULTS): Transform {\n\tconst options = assignDefaults(PALETTE_DEFAULTS, _options);\n\tconst blockSize = Math.max(options.blockSize, 1);\n\tconst min = Math.max(options.min, 1);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst root = document.getRoot();\n\n\t\t// Find and remove unused TEXCOORD_n attributes.\n\t\tif (!options.keepAttributes) {\n\t\t\tawait document.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR],\n\t\t\t\t\tkeepAttributes: false,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t\tkeepLeaves: true,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tconst prims = new Set<Primitive>();\n\t\tconst materials = new Set<Material>();\n\n\t\t// (1) Gather list of eligible prims and materials.\n\n\t\tfor (const mesh of root.listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst material = prim.getMaterial();\n\t\t\t\tif (!material || !!prim.getAttribute('TEXCOORD_0')) continue;\n\n\t\t\t\tprims.add(prim);\n\t\t\t\tmaterials.add(material);\n\t\t\t}\n\t\t}\n\n\t\t// (2) Gather list of distinct material properties.\n\n\t\tconst materialKeys = new Set<string>();\n\t\tconst materialKeyMap = new Map<Material, string>();\n\t\tconst materialProps: Record<TexturableProp, Set<string>> = {\n\t\t\tbaseColor: new Set<string>(),\n\t\t\temissive: new Set<string>(),\n\t\t\tmetallicRoughness: new Set<string>(),\n\t\t};\n\n\t\tfor (const material of materials) {\n\t\t\tconst baseColor = encodeRGBA(material.getBaseColorFactor().slice() as vec4);\n\t\t\tconst emissive = encodeRGBA([...material.getEmissiveFactor(), 1]);\n\t\t\tconst roughness = encodeFloat(material.getRoughnessFactor());\n\t\t\tconst metallic = encodeFloat(material.getMetallicFactor());\n\t\t\tconst key = `baseColor:${baseColor},emissive:${emissive},metallicRoughness:${metallic}${roughness}`;\n\t\t\tmaterialProps.baseColor.add(baseColor);\n\t\t\tmaterialProps.emissive.add(emissive);\n\t\t\tmaterialProps.metallicRoughness.add(metallic + '+' + roughness);\n\t\t\tmaterialKeys.add(key);\n\t\t\tmaterialKeyMap.set(material, key);\n\t\t}\n\n\t\t// logger.debug(`${NAME}:\\n${Array.from(materialKeys.values()).join('\\n')}`);\n\n\t\tconst keyCount = materialKeys.size;\n\t\tif (keyCount < min) {\n\t\t\tlogger.debug(`${NAME}: Found <${min} unique material properties. Exiting.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// (3) Allocate palette textures.\n\n\t\tconst w = ceilPowerOfTwo(keyCount * blockSize);\n\t\tconst h = ceilPowerOfTwo(blockSize);\n\t\tconst padWidth = w - keyCount * blockSize;\n\n\t\tconst paletteTexturePixels: Record<TexturableProp, NdArray<Uint8Array> | null> = {\n\t\t\tbaseColor: null,\n\t\t\temissive: null,\n\t\t\tmetallicRoughness: null,\n\t\t};\n\n\t\t// Properties skipped for material equality comparisons.\n\t\tconst skipProps = new Set(['name', 'extras']);\n\t\tconst skip = (...props: string[]) => props.forEach((prop) => skipProps.add(prop));\n\n\t\tlet baseColorTexture: Texture | null = null;\n\t\tlet emissiveTexture: Texture | null = null;\n\t\tlet metallicRoughnessTexture: Texture | null = null;\n\n\t\tif (materialProps.baseColor.size >= min) {\n\t\t\tconst name = 'PaletteBaseColor';\n\t\t\tbaseColorTexture = document.createTexture(name).setURI(`${name}.png`);\n\t\t\tpaletteTexturePixels.baseColor = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n\t\t\tskip('baseColorFactor', 'baseColorTexture', 'baseColorTextureInfo');\n\t\t}\n\t\tif (materialProps.emissive.size >= min) {\n\t\t\tconst name = 'PaletteEmissive';\n\t\t\temissiveTexture = document.createTexture(name).setURI(`${name}.png`);\n\t\t\tpaletteTexturePixels.emissive = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n\t\t\tskip('emissiveFactor', 'emissiveTexture', 'emissiveTextureInfo');\n\t\t}\n\t\tif (materialProps.metallicRoughness.size >= min) {\n\t\t\tconst name = 'PaletteMetallicRoughness';\n\t\t\tmetallicRoughnessTexture = document.createTexture(name).setURI(`${name}.png`);\n\t\t\tpaletteTexturePixels.metallicRoughness = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n\t\t\tskip('metallicFactor', 'roughnessFactor', 'metallicRoughnessTexture', 'metallicRoughnessTextureInfo');\n\t\t}\n\n\t\tif (!(baseColorTexture || emissiveTexture || metallicRoughnessTexture)) {\n\t\t\tlogger.debug(`${NAME}: No material property has >=${min} unique values. Exiting.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// (4) Write blocks to palette textures.\n\n\t\tconst visitedKeys = new Set<string>();\n\t\tconst materialIndices = new Map<string, number>();\n\t\tconst paletteMaterials: Material[] = [];\n\n\t\tlet nextIndex = 0;\n\t\tfor (const material of materials) {\n\t\t\tconst key = materialKeyMap.get(material)!;\n\t\t\tif (visitedKeys.has(key)) continue;\n\n\t\t\tconst index = nextIndex++;\n\n\t\t\tif (paletteTexturePixels.baseColor) {\n\t\t\t\tconst pixels = paletteTexturePixels.baseColor;\n\t\t\t\tconst baseColor = [...material.getBaseColorFactor()] as vec4;\n\t\t\t\tColorUtils.convertLinearToSRGB(baseColor, baseColor);\n\t\t\t\twriteBlock(pixels, index, baseColor, blockSize);\n\t\t\t}\n\t\t\tif (paletteTexturePixels.emissive) {\n\t\t\t\tconst pixels = paletteTexturePixels.emissive;\n\t\t\t\tconst emissive = [...material.getEmissiveFactor(), 1] as vec4;\n\t\t\t\tColorUtils.convertLinearToSRGB(emissive, emissive);\n\t\t\t\twriteBlock(pixels, index, emissive, blockSize);\n\t\t\t}\n\t\t\tif (paletteTexturePixels.metallicRoughness) {\n\t\t\t\tconst pixels = paletteTexturePixels.metallicRoughness;\n\t\t\t\tconst metallic = material.getMetallicFactor();\n\t\t\t\tconst roughness = material.getRoughnessFactor();\n\t\t\t\twriteBlock(pixels, index, [0, roughness, metallic, 1], blockSize);\n\t\t\t}\n\n\t\t\tvisitedKeys.add(key);\n\t\t\tmaterialIndices.set(key, index);\n\t\t}\n\n\t\t// (5) Compress palette textures and assign to palette materials.\n\n\t\tconst mimeType = 'image/png';\n\n\t\tif (baseColorTexture) {\n\t\t\tconst image = await savePixels(paletteTexturePixels.baseColor!, mimeType);\n\t\t\tbaseColorTexture.setImage(image).setMimeType(mimeType);\n\t\t}\n\t\tif (emissiveTexture) {\n\t\t\tconst image = await savePixels(paletteTexturePixels.emissive!, mimeType);\n\t\t\temissiveTexture.setImage(image).setMimeType(mimeType);\n\t\t}\n\t\tif (metallicRoughnessTexture) {\n\t\t\tconst image = await savePixels(paletteTexturePixels.metallicRoughness!, mimeType);\n\t\t\tmetallicRoughnessTexture.setImage(image).setMimeType(mimeType);\n\t\t}\n\n\t\t// (6) Create palette materials, generate UVs, and assign both to prims.\n\n\t\tlet nextPaletteMaterialIndex = 1;\n\t\tfor (const prim of prims) {\n\t\t\tconst srcMaterial = prim.getMaterial()!;\n\t\t\tconst key = materialKeyMap.get(srcMaterial)!;\n\t\t\tconst blockIndex = materialIndices.get(key)!;\n\n\t\t\t// UVs are centered horizontally in each block, descending vertically\n\t\t\t// to form a diagonal line in the UV layout. Easy and compressible.\n\t\t\tconst baseUV = (blockIndex + 0.5) / keyCount;\n\t\t\tconst padUV = (baseUV * (w - padWidth)) / w;\n\n\t\t\tconst position = prim.getAttribute('POSITION')!;\n\t\t\tconst buffer = position.getBuffer();\n\t\t\tconst array = new Float32Array(position.getCount() * 2).fill(padUV);\n\t\t\tconst uv = document.createAccessor().setType('VEC2').setArray(array).setBuffer(buffer);\n\n\t\t\tlet dstMaterial;\n\t\t\tfor (const material of paletteMaterials) {\n\t\t\t\tif (material.equals(srcMaterial, skipProps)) {\n\t\t\t\t\tdstMaterial = material;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dstMaterial) {\n\t\t\t\tconst suffix = (nextPaletteMaterialIndex++).toString().padStart(3, '0');\n\t\t\t\tdstMaterial = srcMaterial.clone().setName(`PaletteMaterial${suffix}`);\n\n\t\t\t\tif (baseColorTexture) {\n\t\t\t\t\tdstMaterial\n\t\t\t\t\t\t.setBaseColorFactor([1, 1, 1, 1])\n\t\t\t\t\t\t.setBaseColorTexture(baseColorTexture)\n\t\t\t\t\t\t.getBaseColorTextureInfo()!\n\t\t\t\t\t\t.setMinFilter(TextureInfo.MinFilter.NEAREST)\n\t\t\t\t\t\t.setMagFilter(TextureInfo.MagFilter.NEAREST);\n\t\t\t\t}\n\t\t\t\tif (emissiveTexture) {\n\t\t\t\t\tdstMaterial\n\t\t\t\t\t\t.setEmissiveFactor([1, 1, 1])\n\t\t\t\t\t\t.setEmissiveTexture(emissiveTexture)\n\t\t\t\t\t\t.getEmissiveTextureInfo()!\n\t\t\t\t\t\t.setMinFilter(TextureInfo.MinFilter.NEAREST)\n\t\t\t\t\t\t.setMagFilter(TextureInfo.MagFilter.NEAREST);\n\t\t\t\t}\n\t\t\t\tif (metallicRoughnessTexture) {\n\t\t\t\t\tdstMaterial\n\t\t\t\t\t\t.setMetallicFactor(1)\n\t\t\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t\t\t.setMetallicRoughnessTexture(metallicRoughnessTexture)\n\t\t\t\t\t\t.getMetallicRoughnessTextureInfo()!\n\t\t\t\t\t\t.setMinFilter(TextureInfo.MinFilter.NEAREST)\n\t\t\t\t\t\t.setMagFilter(TextureInfo.MagFilter.NEAREST);\n\t\t\t\t}\n\n\t\t\t\tpaletteMaterials.push(dstMaterial);\n\t\t\t}\n\n\t\t\tprim.setMaterial(dstMaterial).setAttribute('TEXCOORD_0', uv);\n\t\t}\n\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(prune({ propertyTypes: [PropertyType.MATERIAL] }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/** Encodes a floating-point value on the interval [0,1] at 8-bit precision. */\nfunction encodeFloat(value: number): string {\n\tconst hex = Math.round(value * 255).toString(16);\n\treturn hex.length === 1 ? '0' + hex : hex;\n}\n\n/** Encodes an RGBA color in Linear-sRGB-D65 color space. */\nfunction encodeRGBA(value: vec4): string {\n\tColorUtils.convertLinearToSRGB(value, value);\n\treturn value.map(encodeFloat).join('');\n}\n\n/** Returns the nearest higher power of two. */\nfunction ceilPowerOfTwo(value: number): number {\n\treturn Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n\n/** Writes an NxN block of pixels to an image, at the given block index. */\nfunction writeBlock(pixels: NdArray<TypedArray>, index: number, value: vec4, blockSize: number): void {\n\tfor (let i = 0; i < blockSize; i++) {\n\t\tfor (let j = 0; j < blockSize; j++) {\n\t\t\tpixels.set(index * blockSize + i, j, 0, value[0] * 255);\n\t\t\tpixels.set(index * blockSize + i, j, 1, value[1] * 255);\n\t\t\tpixels.set(index * blockSize + i, j, 2, value[2] * 255);\n\t\t\tpixels.set(index * blockSize + i, j, 3, value[3] * 255);\n\t\t}\n\t}\n}\n", "import { type Document, type ILogger, PropertyType, type Transform } from '@gltf-transform/core';\nimport { prune } from './prune.js';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'partition';\n\nexport interface PartitionOptions {\n\tanimations?: boolean | Array<string>;\n\tmeshes?: boolean | Array<string>;\n}\n\nconst PARTITION_DEFAULTS: Required<PartitionOptions> = {\n\tanimations: true,\n\tmeshes: true,\n};\n\n/**\n * Partitions the binary payload of a glTF file so separate mesh or animation data is in separate\n * `.bin` {@link Buffer}s. This technique may be useful for engines that support lazy-loading\n * specific binary resources as needed over the application lifecycle.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); //  [Buffer]\n *\n * await document.transform(partition({meshes: true}));\n *\n * document.getRoot().listBuffers(); //  [Buffer, Buffer, ...]\n * ```\n *\n * @category Transforms\n */\nexport function partition(_options: PartitionOptions = PARTITION_DEFAULTS): Transform {\n\tconst options = assignDefaults(PARTITION_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.meshes !== false) partitionMeshes(doc, logger, options);\n\t\tif (options.animations !== false) partitionAnimations(doc, logger, options);\n\n\t\tif (!options.meshes && !options.animations) {\n\t\t\tlogger.warn(`${NAME}: Select animations or meshes to create a partition.`);\n\t\t}\n\n\t\tawait doc.transform(prune({ propertyTypes: [PropertyType.BUFFER] }));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction partitionMeshes(doc: Document, logger: ILogger, options: Required<PartitionOptions>): void {\n\tconst existingURIs = new Set<string>(\n\t\tdoc\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.map((b) => b.getURI()),\n\t);\n\n\tdoc.getRoot()\n\t\t.listMeshes()\n\t\t.forEach((mesh, meshIndex) => {\n\t\t\tif (Array.isArray(options.meshes) && !options.meshes.includes(mesh.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping mesh #${meshIndex} with name \"${mesh.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for mesh \"${mesh.getName()}\".`);\n\n\t\t\tconst buffer = doc\n\t\t\t\t.createBuffer(mesh.getName())\n\t\t\t\t.setURI(createBufferURI(mesh.getName() || 'mesh', existingURIs));\n\n\t\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\tif (indices) indices.setBuffer(buffer);\n\t\t\t\tprimitive.listAttributes().forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\tprimitive.listTargets().forEach((primTarget) => {\n\t\t\t\t\tprimTarget.listAttributes().forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t});\n\t\t\t});\n\t\t});\n}\n\nfunction partitionAnimations(doc: Document, logger: ILogger, options: Required<PartitionOptions>): void {\n\tconst existingURIs = new Set<string>(\n\t\tdoc\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.map((b) => b.getURI()),\n\t);\n\n\tdoc.getRoot()\n\t\t.listAnimations()\n\t\t.forEach((anim, animIndex) => {\n\t\t\tif (Array.isArray(options.animations) && !options.animations.includes(anim.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping animation #${animIndex} with name \"${anim.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for animation \"${anim.getName()}\".`);\n\n\t\t\tconst buffer = doc\n\t\t\t\t.createBuffer(anim.getName())\n\t\t\t\t.setURI(createBufferURI(anim.getName() || 'animation', existingURIs));\n\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\tif (input) input.setBuffer(buffer);\n\t\t\t\tif (output) output.setBuffer(buffer);\n\t\t\t});\n\t\t});\n}\n\nconst SANITIZE_BASENAME_RE = /[^\\w09-]+/g;\n\nfunction createBufferURI(basename: string, existing: Set<string>): string {\n\tbasename = basename.replace(SANITIZE_BASENAME_RE, '');\n\tlet uri = `${basename}.bin`;\n\tlet i = 1;\n\twhile (existing.has(uri)) uri = `${basename}_${i++}.bin`;\n\texisting.add(uri);\n\treturn uri;\n}\n", "var InterpolationInternal;\n\n(function (InterpolationInternal) {\n  InterpolationInternal[InterpolationInternal[\"STEP\"] = 0] = \"STEP\";\n  InterpolationInternal[InterpolationInternal[\"LERP\"] = 1] = \"LERP\";\n  InterpolationInternal[InterpolationInternal[\"SLERP\"] = 2] = \"SLERP\";\n})(InterpolationInternal || (InterpolationInternal = {}));\n\nconst TO_INTERPOLATION_INTERNAL = {\n  step: InterpolationInternal.STEP,\n  lerp: InterpolationInternal.LERP,\n  slerp: InterpolationInternal.SLERP\n};\nconst EPSILON = 0.000001;\n\n/* Implementation */\n\nfunction resampleDebug(input, output, interpolation, tolerance = 1e-4) {\n  const elementSize = output.length / input.length;\n  const tmp = new Array(elementSize).fill(0);\n  const value = new Array(elementSize).fill(0);\n  const valueNext = new Array(elementSize).fill(0);\n  const valuePrev = new Array(elementSize).fill(0);\n  const lastIndex = input.length - 1;\n  let writeIndex = 1;\n\n  for (let i = 1; i < lastIndex; ++i) {\n    const timePrev = input[writeIndex - 1];\n    const time = input[i];\n    const timeNext = input[i + 1];\n    const t = (time - timePrev) / (timeNext - timePrev);\n    let keep = false; // Remove unnecessary adjacent keyframes.\n\n    if (time !== timeNext && (i !== 1 || time !== input[0])) {\n      getElement(output, writeIndex - 1, valuePrev);\n      getElement(output, i, value);\n      getElement(output, i + 1, valueNext);\n\n      if (interpolation === 'slerp') {\n        // Prune keyframes colinear with prev/next keyframes.\n        const sample = slerp(tmp, valuePrev, valueNext, t);\n        const angle = getAngle(valuePrev, value) + getAngle(value, valueNext);\n        keep = !eq(value, sample, tolerance) || angle + Number.EPSILON >= Math.PI;\n      } else if (interpolation === 'lerp') {\n        // Prune keyframes colinear with prev/next keyframes.\n        const sample = vlerp(tmp, valuePrev, valueNext, t);\n        keep = !eq(value, sample, tolerance);\n      } else if (interpolation === 'step') {\n        // Prune keyframes identical to prev/next keyframes.\n        keep = !eq(value, valuePrev) || !eq(value, valueNext);\n      }\n    } // In-place compaction.\n\n\n    if (keep) {\n      if (i !== writeIndex) {\n        input[writeIndex] = input[i];\n        setElement(output, writeIndex, getElement(output, i, tmp));\n      }\n\n      writeIndex++;\n    }\n  } // Flush last keyframe (compaction looks ahead).\n\n\n  if (lastIndex > 0) {\n    input[writeIndex] = input[lastIndex];\n    setElement(output, writeIndex, getElement(output, lastIndex, tmp));\n    writeIndex++;\n  }\n\n  return writeIndex;\n}\n/* Utilities */\n\nfunction getElement(array, index, target) {\n  for (let i = 0, elementSize = target.length; i < elementSize; i++) {\n    target[i] = array[index * elementSize + i];\n  }\n\n  return target;\n}\n\nfunction setElement(array, index, value) {\n  for (let i = 0, elementSize = value.length; i < elementSize; i++) {\n    array[index * elementSize + i] = value[i];\n  }\n}\n\nfunction eq(a, b, tolerance = 0) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (Math.abs(a[i] - b[i]) > tolerance) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction lerp(v0, v1, t) {\n  return v0 * (1 - t) + v1 * t;\n}\n\nfunction vlerp(out, a, b, t) {\n  for (let i = 0; i < a.length; i++) out[i] = lerp(a[i], b[i], t);\n\n  return out;\n} // From gl-matrix.\n\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  let omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n\nfunction getAngle(a, b) {\n  const dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/** WASM loader for Web environments. */\nconst wasm = /* #__PURE__ */fetch( /* #__PURE__ */new URL('./release.wasm', import.meta.url)).then(response => response.arrayBuffer()).then(buffer => new Uint8Array(buffer));\n\n// SETUP\n///////////////////////////////////////////////////////////////////////////////\n\nlet exports;\nconst ready = /* #__PURE__ */new Promise(async (resolve, reject) => {\n  try {\n    const module = await WebAssembly.compile(await wasm);\n    exports = await instantiate(module, {});\n    resolve();\n  } catch (e) {\n    reject(e);\n  }\n});\n\nasync function instantiate(module, imports = {}) {\n  const instance = await WebAssembly.instantiate(module, {\n    env: Object.assign(Object.create(globalThis), {}, {\n      abort: __abort\n    })\n  });\n  return instance.exports;\n} ///////////////////////////////////////////////////////////////////////////////\n// PUBLIC API\n///////////////////////////////////////////////////////////////////////////////\n\n\nconst CHUNK_SIZE = 1024; // The first and last keyframes cannot be removed in any given step, but we need to\n// somehow remove keyframes on chunk boundaries. So after processing each chunk,\n// we copy its last two keyframes in front of the next chunk, and run from there.\n//\n//                        // chunk 1, original\n//                           // chunk 1, resampled\n//                        // chunk 2, original\n//                           // chunk 2, resampled\n// ...\n\nfunction resample(input, output, interpolation, tolerance = 1e-4) {\n  __assert(!!exports, 'Await \"ready\" before using module.');\n\n  __assert(input instanceof Float32Array, 'Missing Float32Array input.');\n\n  __assert(output instanceof Float32Array, 'Missing Float32Array output.');\n\n  const outputSize = output.length / input.length;\n\n  __assert(Number.isInteger(outputSize), 'Invalid input/output counts.');\n\n  __assert(interpolation in TO_INTERPOLATION_INTERNAL, 'Invalid interpolation.');\n\n  __assert(Number.isFinite(tolerance), 'Invalid tolerance');\n\n  const interpVal = TO_INTERPOLATION_INTERNAL[interpolation];\n  const srcCount = input.length;\n  let dstCount = 0;\n\n  for (let chunkStart = 0; chunkStart < input.length; chunkStart += CHUNK_SIZE) {\n    const chunkCount = Math.min(srcCount - chunkStart, CHUNK_SIZE); // Allocate a two-keyframe prefix for all chunks after the first.\n\n    const prefixCount = chunkStart > 0 ? 2 : 0;\n    const chunkInput = new Float32Array(input.buffer, input.byteOffset + (chunkStart - prefixCount) * Float32Array.BYTES_PER_ELEMENT, chunkCount + prefixCount);\n    const chunkOutput = new Float32Array(output.buffer, output.byteOffset + (chunkStart - prefixCount) * outputSize * Float32Array.BYTES_PER_ELEMENT, (chunkCount + prefixCount) * outputSize); // Copy prefix to start of next chunk.\n\n    if (prefixCount > 0) {\n      input.copyWithin(chunkStart - prefixCount, dstCount - prefixCount, dstCount);\n      output.copyWithin((chunkStart - prefixCount) * outputSize, (dstCount - prefixCount) * outputSize, dstCount * outputSize);\n    }\n\n    const inputPtr = __retain(__lowerStaticArray(chunkInput, 4, 2));\n\n    const outputPtr = __retain(__lowerStaticArray(chunkOutput, 4, 2));\n\n    try {\n      exports.__setArgumentsLength(4);\n\n      const count = exports.resample(inputPtr, outputPtr, interpVal, tolerance) >>> 0;\n      dstCount -= prefixCount;\n\n      __liftStaticArray(inputPtr, input, dstCount, count);\n\n      __liftStaticArray(outputPtr, output, dstCount * outputSize, count * outputSize);\n\n      dstCount += count;\n    } finally {\n      __release(inputPtr);\n\n      __release(outputPtr);\n\n      exports.__collect();\n    }\n  } // console.log(`Memory: ${exports.memory.buffer.byteLength} bytes`);\n\n\n  return dstCount;\n} ///////////////////////////////////////////////////////////////////////////////\n// INTERNAL\n///////////////////////////////////////////////////////////////////////////////\n\nfunction __assert(cond, msg) {\n  if (!cond) throw new Error(msg);\n}\n\nfunction __retain(ptr) {\n  exports.__pin(ptr);\n\n  return ptr;\n}\n\nfunction __release(ptr) {\n  exports.__unpin(ptr);\n\n  return ptr;\n}\n\nfunction __liftString(ptr) {\n  if (!ptr) return null;\n  const end = ptr + new Uint32Array(exports.memory.buffer)[ptr - 4 >>> 2] >>> 1,\n        memoryU16 = new Uint16Array(exports.memory.buffer);\n  let start = ptr >>> 1,\n      string = '';\n\n  while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));\n\n  return string + String.fromCharCode(...memoryU16.subarray(start, end));\n}\n\nfunction __lowerStaticArray(values, id, align) {\n  const ptr = exports.__pin(exports.__new(values.length << align, id)) >>> 0;\n  new Float32Array(exports.memory.buffer, ptr, values.length).set(values);\n\n  exports.__unpin(ptr);\n\n  return ptr;\n}\n\nfunction __liftStaticArray(ptr, values, offset, count) {\n  values.set(new Float32Array(exports.memory.buffer, ptr, count), offset);\n}\n\nfunction __abort(messagePtr, fileNamePtr, lineNumber, columnNumber) {\n  const message = __liftString(messagePtr >>> 0);\n\n  const fileName = __liftString(fileNamePtr >>> 0);\n\n  lineNumber = lineNumber >>> 0;\n  columnNumber = columnNumber >>> 0;\n\n  (() => {\n    throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\n  })();\n}\n\nexport { ready, resample, resampleDebug };\n//# sourceMappingURL=keyframe-resample-browser.modern.js.map\n", "import {\n\tAccessor,\n\ttype AnimationSampler,\n\tComponentTypeToTypedArray,\n\ttype Document,\n\ttype GLTF,\n\tMathUtils,\n\tPropertyType,\n\tRoot,\n\ttype Transform,\n\ttype TypedArray,\n} from '@gltf-transform/core';\nimport { resampleDebug } from 'keyframe-resample';\nimport { dedup } from './dedup.js';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'resample';\n\nconst EMPTY_ARRAY = new Float32Array(0);\n\nexport interface ResampleOptions {\n\tready?: Promise<void>;\n\tresample?: unknown; // glTF-Transform/issues/996\n\ttolerance?: number;\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nconst RESAMPLE_DEFAULTS: Required<ResampleOptions> = {\n\tready: Promise.resolve(),\n\tresample: resampleDebug,\n\ttolerance: 1e-4,\n\tcleanup: true,\n};\n\n/**\n * Resample {@link AnimationChannel AnimationChannels}, losslessly deduplicating keyframes to\n * reduce file size. Duplicate keyframes are commonly present in animation 'baked' by the\n * authoring software to apply IK constraints or other software-specific features.\n *\n * Optionally, a WebAssembly implementation from the\n * [`keyframe-resample`](https://github.com/donmccurdy/keyframe-resample-wasm) library may be\n * provided. The WebAssembly version is usually much faster at processing large animation\n * sequences, but may not be compatible with all runtimes and JavaScript build tools.\n *\n * Result: (0,0,0,0,1,1,1,0,0,0,0,0,0,0)  (0,0,1,1,0,0)\n *\n * Example:\n *\n * ```\n * import { resample } from '@gltf-transform/functions';\n * import { ready, resample as resampleWASM } from 'keyframe-resample';\n *\n * // JavaScript (slower)\n * await document.transform(resample());\n *\n * // WebAssembly (faster)\n * await document.transform(resample({ ready, resample: resampleWASM }));\n * ```\n *\n * @privateRemarks Implementation based on THREE.KeyframeTrack#optimize().\n * @category Transforms\n */\nexport function resample(_options: ResampleOptions = RESAMPLE_DEFAULTS): Transform {\n\tconst options = assignDefaults(RESAMPLE_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst accessorsVisited = new Set<Accessor>();\n\t\tconst srcAccessorCount = document.getRoot().listAccessors().length;\n\t\tconst logger = document.getLogger();\n\n\t\tconst ready = options.ready;\n\t\tconst resample = options.resample as typeof resampleDebug;\n\n\t\tawait ready;\n\n\t\tfor (const animation of document.getRoot().listAnimations()) {\n\t\t\tconst samplerTargetPaths = new Map<AnimationSampler, GLTF.AnimationChannelTargetPath>();\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tsamplerTargetPaths.set(channel.getSampler()!, channel.getTargetPath()!);\n\t\t\t}\n\n\t\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\t\tconst samplerInterpolation = sampler.getInterpolation();\n\n\t\t\t\tif (samplerInterpolation === 'STEP' || samplerInterpolation === 'LINEAR') {\n\t\t\t\t\tconst input = sampler.getInput()!;\n\t\t\t\t\tconst output = sampler.getOutput()!;\n\n\t\t\t\t\taccessorsVisited.add(input);\n\t\t\t\t\taccessorsVisited.add(output);\n\n\t\t\t\t\t// biome-ignore format: Readability.\n\t\t\t\t\tconst tmpTimes = toFloat32Array(\n\t\t\t\t\t\tinput.getArray()!,\n\t\t\t\t\t\tinput.getComponentType(),\n\t\t\t\t\t\tinput.getNormalized()\n\t\t\t\t\t);\n\t\t\t\t\tconst tmpValues = toFloat32Array(\n\t\t\t\t\t\toutput.getArray()!,\n\t\t\t\t\t\toutput.getComponentType(),\n\t\t\t\t\t\toutput.getNormalized(),\n\t\t\t\t\t);\n\n\t\t\t\t\tconst elementSize = tmpValues.length / tmpTimes.length;\n\t\t\t\t\tconst srcCount = tmpTimes.length;\n\t\t\t\t\tlet dstCount: number;\n\n\t\t\t\t\tif (samplerInterpolation === 'STEP') {\n\t\t\t\t\t\tdstCount = resample(tmpTimes, tmpValues, 'step', options.tolerance);\n\t\t\t\t\t} else if (samplerTargetPaths.get(sampler) === 'rotation') {\n\t\t\t\t\t\tdstCount = resample(tmpTimes, tmpValues, 'slerp', options.tolerance);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdstCount = resample(tmpTimes, tmpValues, 'lerp', options.tolerance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dstCount < srcCount) {\n\t\t\t\t\t\t// Clone the input/output accessors, without cloning their underlying\n\t\t\t\t\t\t// arrays. Then assign the resampled data.\n\t\t\t\t\t\tconst srcTimes = input.getArray()!;\n\t\t\t\t\t\tconst srcValues = output.getArray()!;\n\n\t\t\t\t\t\tconst dstTimes = fromFloat32Array(\n\t\t\t\t\t\t\tnew Float32Array(tmpTimes.buffer, tmpTimes.byteOffset, dstCount),\n\t\t\t\t\t\t\tinput.getComponentType(),\n\t\t\t\t\t\t\tinput.getNormalized(),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst dstValues = fromFloat32Array(\n\t\t\t\t\t\t\tnew Float32Array(tmpValues.buffer, tmpValues.byteOffset, dstCount * elementSize),\n\t\t\t\t\t\t\toutput.getComponentType(),\n\t\t\t\t\t\t\toutput.getNormalized(),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tinput.setArray(EMPTY_ARRAY);\n\t\t\t\t\t\toutput.setArray(EMPTY_ARRAY);\n\n\t\t\t\t\t\tsampler.setInput(input.clone().setArray(dstTimes));\n\t\t\t\t\t\tsampler.setOutput(output.clone().setArray(dstValues));\n\n\t\t\t\t\t\tinput.setArray(srcTimes);\n\t\t\t\t\t\toutput.setArray(srcValues);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const accessor of Array.from(accessorsVisited.values())) {\n\t\t\tconst used = accessor.listParents().some((p) => !(p instanceof Root));\n\t\t\tif (!used) accessor.dispose();\n\t\t}\n\n\t\t// Resampling may result in duplicate input or output sampler\n\t\t// accessors. Find and remove the duplicates after processing.\n\t\tconst dstAccessorCount = document.getRoot().listAccessors().length;\n\t\tif (dstAccessorCount > srcAccessorCount && options.cleanup) {\n\t\t\tawait document.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/** Returns a copy of the source array, as a denormalized Float32Array. */\nfunction toFloat32Array(\n\tsrcArray: TypedArray,\n\tcomponentType: GLTF.AccessorComponentType,\n\tnormalized: boolean,\n): Float32Array {\n\tif (srcArray instanceof Float32Array) return srcArray.slice();\n\tconst dstArray = new Float32Array(srcArray);\n\tif (!normalized) return dstArray;\n\n\tfor (let i = 0; i < dstArray.length; i++) {\n\t\tdstArray[i] = MathUtils.decodeNormalizedInt(dstArray[i], componentType);\n\t}\n\n\treturn dstArray;\n}\n\n/** Returns a copy of the source array, with specified component type and normalization. */\nfunction fromFloat32Array(\n\tsrcArray: Float32Array,\n\tcomponentType: GLTF.AccessorComponentType,\n\tnormalized: boolean,\n): TypedArray {\n\tif (componentType === Accessor.ComponentType.FLOAT) return srcArray.slice();\n\tconst TypedArray = ComponentTypeToTypedArray[componentType];\n\tconst dstArray = new TypedArray(srcArray.length);\n\n\tfor (let i = 0; i < dstArray.length; i++) {\n\t\tdstArray[i] = normalized ? MathUtils.encodeNormalizedInt(srcArray[i], componentType) : srcArray[i];\n\t}\n\n\treturn dstArray;\n}\n", "import { Accessor, AnimationChannel, AnimationSampler, type Document, type Transform } from '@gltf-transform/core';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'sequence';\n\nexport interface SequenceOptions {\n\t/** Frames per second, where one node is shown each frame. Default 10. */\n\tfps?: number;\n\t/** Pattern (regex) used to filter nodes for the sequence. Required. */\n\tpattern: RegExp;\n\t/** Name of the new animation. */\n\tname?: string;\n\t/** Whether to sort the nodes by name, or use original order. Default true. */\n\tsort?: boolean;\n}\n\nconst SEQUENCE_DEFAULTS: Required<SequenceOptions> = {\n\tname: '',\n\tfps: 10,\n\tpattern: /.*/,\n\tsort: true,\n};\n\n/**\n * Creates an {@link Animation} displaying each of the specified {@link Node}s sequentially.\n *\n * @category Transforms\n */\nexport function sequence(_options: SequenceOptions = SEQUENCE_DEFAULTS): Transform {\n\tconst options = assignDefaults(SEQUENCE_DEFAULTS, _options);\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst fps = options.fps;\n\n\t\t// Collect sequence nodes.\n\t\tconst sequenceNodes = root.listNodes().filter((node) => node.getName().match(options.pattern));\n\n\t\t// Sort by node name.\n\t\tif (options.sort) {\n\t\t\tsequenceNodes.sort((a, b) => (a.getName() > b.getName() ? 1 : -1));\n\t\t}\n\n\t\t// Create animation cycling visibility of each node.\n\t\tconst anim = doc.createAnimation(options.name);\n\t\tconst animBuffer = root.listBuffers()[0];\n\t\tsequenceNodes.forEach((node, i) => {\n\t\t\t// Create keyframe tracks that show each node for a single frame.\n\t\t\tlet inputArray;\n\t\t\tlet outputArray;\n\t\t\tif (i === 0) {\n\t\t\t\tinputArray = [i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [1, 1, 1, 0, 0, 0];\n\t\t\t} else if (i === sequenceNodes.length - 1) {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1];\n\t\t\t} else {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1, 0, 0, 0];\n\t\t\t}\n\n\t\t\t// Append channel to animation sequence.\n\t\t\tconst input = doc.createAccessor().setArray(new Float32Array(inputArray)).setBuffer(animBuffer);\n\t\t\tconst output = doc\n\t\t\t\t.createAccessor()\n\t\t\t\t.setArray(new Float32Array(outputArray))\n\t\t\t\t.setBuffer(animBuffer)\n\t\t\t\t.setType(Accessor.Type.VEC3);\n\t\t\tconst sampler = doc\n\t\t\t\t.createAnimationSampler()\n\t\t\t\t.setInterpolation(AnimationSampler.Interpolation.STEP)\n\t\t\t\t.setInput(input)\n\t\t\t\t.setOutput(output);\n\t\t\tconst channel = doc\n\t\t\t\t.createAnimationChannel()\n\t\t\t\t.setTargetNode(node)\n\t\t\t\t.setTargetPath(AnimationChannel.TargetPath.SCALE)\n\t\t\t\t.setSampler(sampler);\n\t\t\tanim.addSampler(sampler).addChannel(channel);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import { Document, Primitive, type Transform } from '@gltf-transform/core';\nimport type { MeshoptSimplifier } from 'meshoptimizer';\nimport { compactAttribute, compactPrimitive } from './compact-primitive.js';\nimport { convertPrimitiveToTriangles } from './convert-primitive-mode.js';\nimport { dequantizeAttributeArray } from './dequantize.js';\nimport { getPrimitiveVertexCount, VertexCountMethod } from './get-vertex-count.js';\nimport { unweldPrimitive } from './unweld.js';\nimport {\n\tassignDefaults,\n\tcreateTransform,\n\tdeepDisposePrimitive,\n\tdeepListAttributes,\n\tdeepSwapAttribute,\n\tformatDeltaOp,\n\tshallowCloneAccessor,\n} from './utils.js';\nimport { weld } from './weld.js';\n\nconst NAME = 'simplify';\n\nconst { POINTS, LINES, LINE_STRIP, LINE_LOOP, TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN } = Primitive.Mode;\n\n/** Options for the {@link simplify} function. */\nexport interface SimplifyOptions {\n\t/** MeshoptSimplifier instance. */\n\tsimplifier: unknown;\n\t/** Target ratio (01) of vertices to keep. Default: 0.0 (0%). */\n\tratio?: number;\n\t/** Limit on error, as a fraction of mesh radius. Default: 0.0001 (0.01%). */\n\terror?: number;\n\t/**\n\t * Whether to lock topological borders of the mesh. May be necessary when\n\t * adjacent 'chunks' of a large mesh (e.g. terrain) share a border, helping\n\t * to ensure no seams appear.\n\t */\n\tlockBorder?: boolean;\n}\n\nexport const SIMPLIFY_DEFAULTS: Required<Omit<SimplifyOptions, 'simplifier'>> = {\n\tratio: 0.0,\n\terror: 0.0001,\n\tlockBorder: false,\n};\n\n/**\n * Simplification algorithm, based on meshoptimizer, producing meshes with fewer\n * triangles and vertices. Simplification is lossy, but the algorithm aims to\n * preserve visual quality as much as possible for given parameters.\n *\n * The algorithm aims to reach the target 'ratio', while minimizing error. If\n * error exceeds the specified 'error' threshold, the algorithm will quit\n * before reaching the target ratio. Examples:\n *\n * - ratio=0.0, error=0.0001: Aims for maximum simplification, constrained to 0.01% error.\n * - ratio=0.5, error=0.0001: Aims for 50% simplification, constrained to 0.01% error.\n * - ratio=0.5, error=1: Aims for 50% simplification, unconstrained by error.\n *\n * Topology, particularly split vertices, will also limit the simplifier. For\n * best results, apply a {@link weld} operation before simplification.\n *\n * Example:\n *\n * ```javascript\n * import { simplify, weld } from '@gltf-transform/functions';\n * import { MeshoptSimplifier } from 'meshoptimizer';\n *\n * await document.transform(\n *   weld({}),\n *   simplify({ simplifier: MeshoptSimplifier, ratio: 0.75, error: 0.001 })\n * );\n * ```\n *\n * References:\n * - https://github.com/zeux/meshoptimizer/blob/master/js/README.md#simplifier\n *\n * @category Transforms\n */\nexport function simplify(_options: SimplifyOptions): Transform {\n\tconst options = assignDefaults(SIMPLIFY_DEFAULTS, _options);\n\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier | undefined;\n\n\tif (!simplifier) {\n\t\tthrow new Error(`${NAME}: simplifier dependency required  install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tawait simplifier.ready;\n\t\tawait document.transform(weld({ overwrite: false }));\n\n\t\tlet numUnsupported = 0;\n\n\t\t// Simplify mesh primitives.\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst mode = prim.getMode();\n\t\t\t\tif (mode !== TRIANGLES && mode !== TRIANGLE_STRIP && mode !== TRIANGLE_FAN && mode !== POINTS) {\n\t\t\t\t\tnumUnsupported++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsimplifyPrimitive(prim, options);\n\n\t\t\t\tif (getPrimitiveVertexCount(prim, VertexCountMethod.RENDER) === 0) {\n\t\t\t\t\tdeepDisposePrimitive(prim);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mesh.listPrimitives().length === 0) mesh.dispose();\n\t\t}\n\n\t\tif (numUnsupported > 0) {\n\t\t\tlogger.warn(`${NAME}: Skipped ${numUnsupported} primitives: Unsupported draw mode.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/** @hidden */\nexport function simplifyPrimitive(prim: Primitive, _options: SimplifyOptions): Primitive {\n\tconst options = { ...SIMPLIFY_DEFAULTS, ..._options } as Required<SimplifyOptions>;\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier;\n\tconst graph = prim.getGraph();\n\tconst document = Document.fromGraph(graph)!;\n\tconst logger = document.getLogger();\n\n\tswitch (prim.getMode()) {\n\t\tcase POINTS:\n\t\t\treturn _simplifyPoints(document, prim, options);\n\t\tcase LINES:\n\t\tcase LINE_STRIP:\n\t\tcase LINE_LOOP:\n\t\t\tlogger.warn(`${NAME}: Skipping primitive simplification: Unsupported draw mode.`);\n\t\t\treturn prim;\n\t\tcase TRIANGLE_STRIP:\n\t\tcase TRIANGLE_FAN:\n\t\t\tconvertPrimitiveToTriangles(prim);\n\t\t\tbreak;\n\t}\n\n\t// (1) If primitive draws <50% of its vertex stream, compact before simplification.\n\n\tconst srcVertexCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n\tconst srcIndexCount = getPrimitiveVertexCount(prim, VertexCountMethod.RENDER);\n\tif (srcIndexCount < srcVertexCount / 2) {\n\t\tcompactPrimitive(prim);\n\t}\n\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst srcIndices = prim.getIndices()!;\n\n\tlet positionArray = position.getArray()!;\n\tlet indicesArray = srcIndices.getArray()!;\n\n\t// (2) Gather attributes and indices in Meshopt-compatible format.\n\n\tif (!(positionArray instanceof Float32Array)) {\n\t\tpositionArray = dequantizeAttributeArray(positionArray, position.getComponentType(), position.getNormalized());\n\t}\n\tif (!(indicesArray instanceof Uint32Array)) {\n\t\tindicesArray = new Uint32Array(indicesArray);\n\t}\n\n\t// (3) Run simplification.\n\n\tconst targetCount = Math.floor((options.ratio * srcIndexCount) / 3) * 3;\n\tconst flags = options.lockBorder ? ['LockBorder'] : [];\n\n\tconst [dstIndicesArray, error] = simplifier.simplify(\n\t\tindicesArray,\n\t\tpositionArray,\n\t\t3,\n\t\ttargetCount,\n\t\toptions.error,\n\t\tflags as 'LockBorder'[],\n\t);\n\n\t// (4) Assign subset of indexes; compact primitive.\n\n\tprim.setIndices(shallowCloneAccessor(document, srcIndices).setArray(dstIndicesArray));\n\tif (srcIndices.listParents().length === 1) srcIndices.dispose();\n\tcompactPrimitive(prim);\n\n\tconst dstVertexCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n\tif (dstVertexCount <= 65534) {\n\t\tprim.getIndices()!.setArray(new Uint16Array(prim.getIndices()!.getArray()!));\n\t}\n\n\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices, error: ${error.toFixed(4)}.`);\n\n\treturn prim;\n}\n\nfunction _simplifyPoints(document: Document, prim: Primitive, options: Required<SimplifyOptions>): Primitive {\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier;\n\tconst logger = document.getLogger();\n\n\tconst indices = prim.getIndices();\n\tif (indices) unweldPrimitive(prim);\n\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst color = prim.getAttribute('COLOR_0');\n\tconst srcVertexCount = position.getCount();\n\n\tlet positionArray = position.getArray()!;\n\tlet colorArray = color ? color.getArray()! : undefined;\n\tconst colorStride = color ? color.getComponentSize() : undefined;\n\n\t// (1) Gather attributes in Meshopt-compatible format.\n\n\tif (!(positionArray instanceof Float32Array)) {\n\t\tpositionArray = dequantizeAttributeArray(positionArray, position.getComponentType(), position.getNormalized());\n\t}\n\tif (colorArray && !(colorArray instanceof Float32Array)) {\n\t\tcolorArray = dequantizeAttributeArray(colorArray, position.getComponentType(), position.getNormalized());\n\t}\n\n\t// (2) Run simplification.\n\n\tconst targetCount = Math.floor(options.ratio * srcVertexCount);\n\tconst dstIndicesArray = simplifier.simplifyPoints(positionArray, 3, targetCount, colorArray, colorStride);\n\n\t// (3) Write vertex attributes.\n\n\tconst [remap, unique] = simplifier.compactMesh(dstIndicesArray);\n\n\tlogger.debug(`${NAME}: ${formatDeltaOp(position.getCount(), unique)} vertices.`);\n\n\tfor (const srcAttribute of deepListAttributes(prim)) {\n\t\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute);\n\t\tcompactAttribute(srcAttribute, null, remap, dstAttribute, unique);\n\t\tdeepSwapAttribute(prim, srcAttribute, dstAttribute);\n\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t}\n\n\treturn prim;\n}\n", "import { type Document, MathUtils, type Transform } from '@gltf-transform/core';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'sparse';\n\n/** Options for the {@link sparse} function. */\nexport interface SparseOptions {\n\t/**\n\t * Threshold ratio used to determine when an accessor should be sparse.\n\t * Default: 1 / 3.\n\t */\n\tratio: number;\n}\n\nconst SPARSE_DEFAULTS: Required<SparseOptions> = {\n\tratio: 1 / 3,\n};\n\n/**\n * Scans all {@link Accessor Accessors} in the Document, detecting whether each Accessor\n * would benefit from sparse data storage. Currently, sparse data storage is used only\n * when many values (>= ratio) are zeroes. Particularly for assets using morph target\n * (\"shape key\") animation, sparse data storage may significantly reduce file sizes.\n *\n * Example:\n *\n * ```ts\n * import { sparse } from '@gltf-transform/functions';\n *\n * accessor.getArray(); //  [ 0, 0, 0, 0, 0, 25.0, 0, 0, ... ]\n * accessor.getSparse(); //  false\n *\n * await document.transform(sparse({ratio: 1 / 10}));\n *\n * accessor.getSparse(); //  true\n * ```\n *\n * @experimental\n * @category Transforms\n */\nexport function sparse(_options: SparseOptions = SPARSE_DEFAULTS): Transform {\n\tconst options = assignDefaults(SPARSE_DEFAULTS, _options);\n\n\tconst ratio = options.ratio;\n\tif (ratio < 0 || ratio > 1) {\n\t\tthrow new Error(`${NAME}: Ratio must be between 0 and 1.`);\n\t}\n\n\treturn createTransform(NAME, (document: Document): void => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\tlet modifiedCount = 0;\n\n\t\tfor (const accessor of root.listAccessors()) {\n\t\t\tconst count = accessor.getCount();\n\t\t\tconst base = Array(accessor.getElementSize()).fill(0);\n\t\t\tconst el = Array(accessor.getElementSize()).fill(0);\n\n\t\t\tlet nonZeroCount = 0;\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\taccessor.getElement(i, el);\n\t\t\t\tif (!MathUtils.eq(el, base, 0)) nonZeroCount++;\n\t\t\t\tif (nonZeroCount / count >= ratio) break;\n\t\t\t}\n\n\t\t\tconst sparse = nonZeroCount / count < ratio;\n\t\t\tif (sparse !== accessor.getSparse()) {\n\t\t\t\taccessor.setSparse(sparse);\n\t\t\t\tmodifiedCount++;\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Updated ${modifiedCount} accessors.`);\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import {\n\ttype Accessor,\n\ttype Document,\n\ttype ILogger,\n\tPrimitive,\n\ttype Transform,\n\ttype TypedArray,\n\tuuid,\n} from '@gltf-transform/core';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'tangents';\n\n/** Options for the {@link tangents} function. */\nexport interface TangentsOptions {\n\t/**\n\t * Callback function to generate tangents from position, uv, and normal attributes.\n\t * Generally, users will want to provide the `generateTangents` from the\n\t * [mikktspace](https://github.com/donmccurdy/mikktspace-wasm) library, which is not\n\t * included by default.\n\t */\n\tgenerateTangents?: (pos: Float32Array, norm: Float32Array, uv: Float32Array) => Float32Array;\n\t/** Whether to overwrite existing `TANGENT` attributes. */\n\toverwrite?: boolean;\n}\n\nconst TANGENTS_DEFAULTS: Required<Omit<TangentsOptions, 'generateTangents'>> = {\n\toverwrite: false,\n};\n\n/**\n * Generates MikkTSpace vertex tangents for mesh primitives, which may fix rendering issues\n * occurring with some baked normal maps. Requires access to the [mikktspace](https://github.com/donmccurdy/mikktspace-wasm)\n * WASM package, or equivalent.\n *\n * Example:\n *\n * ```ts\n * import { generateTangents } from 'mikktspace';\n * import { tangents } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \ttangents({generateTangents})\n * );\n * ```\n *\n * @category Transforms\n */\nexport function tangents(_options: TangentsOptions = TANGENTS_DEFAULTS): Transform {\n\tconst options = assignDefaults(TANGENTS_DEFAULTS, _options);\n\n\tif (!options.generateTangents) {\n\t\tthrow new Error(`${NAME}: generateTangents callback required  install \"mikktspace\".`);\n\t}\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst attributeIDs = new Map<TypedArray, string>();\n\t\tconst tangentCache = new Map<string, Accessor>();\n\t\tlet modified = 0;\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tconst meshName = mesh.getName();\n\t\t\tconst meshPrimitives = mesh.listPrimitives();\n\n\t\t\tfor (let i = 0; i < meshPrimitives.length; i++) {\n\t\t\t\tconst prim = meshPrimitives[i];\n\n\t\t\t\t// Skip primitives for which we can't compute tangents.\n\t\t\t\tif (!filterPrimitive(prim, logger, meshName, i, options.overwrite)) continue;\n\n\t\t\t\tconst texcoordSemantic = getNormalTexcoord(prim);\n\n\t\t\t\t// Nullability conditions checked by filterPrimitive() above.\n\t\t\t\tconst position = prim.getAttribute('POSITION')!.getArray()!;\n\t\t\t\tconst normal = prim.getAttribute('NORMAL')!.getArray()!;\n\t\t\t\tconst texcoord = prim.getAttribute(texcoordSemantic)!.getArray()!;\n\n\t\t\t\t// Compute UUIDs for each attribute.\n\t\t\t\tconst positionID = attributeIDs.get(position) || uuid();\n\t\t\t\tattributeIDs.set(position, positionID);\n\n\t\t\t\tconst normalID = attributeIDs.get(normal) || uuid();\n\t\t\t\tattributeIDs.set(normal, normalID);\n\n\t\t\t\tconst texcoordID = attributeIDs.get(texcoord) || uuid();\n\t\t\t\tattributeIDs.set(texcoord, texcoordID);\n\n\t\t\t\t// Dispose of previous TANGENT accessor if only used by this primitive (and Root).\n\t\t\t\tconst prevTangent = prim.getAttribute('TANGENT');\n\t\t\t\tif (prevTangent && prevTangent.listParents().length === 2) prevTangent.dispose();\n\n\t\t\t\t// If we've already computed tangents for this pos/norm/uv set, reuse them.\n\t\t\t\tconst attributeHash = `${positionID}|${normalID}|${texcoordID}`;\n\t\t\t\tlet tangent = tangentCache.get(attributeHash);\n\t\t\t\tif (tangent) {\n\t\t\t\t\tlogger.debug(`${NAME}: Found cache for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\t\t\t\t\tmodified++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, generate tangents with the 'mikktspace' WASM library.\n\t\t\t\tlogger.debug(`${NAME}: Generating for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\tconst tangentBuffer = prim.getAttribute('POSITION')!.getBuffer();\n\t\t\t\tconst tangentArray = options.generateTangents!(\n\t\t\t\t\tposition instanceof Float32Array ? position : new Float32Array(position),\n\t\t\t\t\tnormal instanceof Float32Array ? normal : new Float32Array(normal),\n\t\t\t\t\ttexcoord instanceof Float32Array ? texcoord : new Float32Array(texcoord),\n\t\t\t\t);\n\n\t\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/issues/174\n\t\t\t\tfor (let i = 3; i < tangentArray.length; i += 4) tangentArray[i] *= -1;\n\n\t\t\t\ttangent = doc.createAccessor().setBuffer(tangentBuffer).setArray(tangentArray).setType('VEC4');\n\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\n\t\t\t\ttangentCache.set(attributeHash, tangent);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\nfunction getNormalTexcoord(prim: Primitive): string {\n\tconst material = prim.getMaterial();\n\tif (!material) return 'TEXCOORD_0';\n\n\tconst normalTextureInfo = material.getNormalTextureInfo();\n\tif (!normalTextureInfo) return 'TEXCOORD_0';\n\n\tconst texcoord = normalTextureInfo.getTexCoord();\n\tconst semantic = `TEXCOORD_${texcoord}`;\n\tif (prim.getAttribute(semantic)) return semantic;\n\n\treturn 'TEXCOORD_0';\n}\n\nfunction filterPrimitive(prim: Primitive, logger: ILogger, meshName: string, i: number, overwrite: boolean): boolean {\n\tif (\n\t\tprim.getMode() !== Primitive.Mode.TRIANGLES ||\n\t\t!prim.getAttribute('POSITION') ||\n\t\t!prim.getAttribute('NORMAL') ||\n\t\t!prim.getAttribute('TEXCOORD_0')\n\t) {\n\t\tlogger.debug(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` +\n\t\t\t\t' have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.',\n\t\t);\n\t\treturn false;\n\t}\n\n\tif (prim.getAttribute('TANGENT') && !overwrite) {\n\t\tlogger.debug(`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": TANGENT found.`);\n\t\treturn false;\n\t}\n\n\tif (prim.getIndices()) {\n\t\tlogger.warn(`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` + ' be unwelded.');\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "import {\n\tBufferUtils,\n\ttype Document,\n\tFileUtils,\n\tImageUtils,\n\ttype Texture,\n\tTextureChannel,\n\ttype Transform,\n\ttype vec2,\n} from '@gltf-transform/core';\nimport { EXTTextureAVIF, EXTTextureWebP } from '@gltf-transform/extensions';\nimport ndarray from 'ndarray';\nimport { lanczos2, lanczos3 } from 'ndarray-lanczos';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport type sharp from 'sharp';\nimport { getTextureChannelMask } from './list-texture-channels.js';\nimport { listTextureSlots } from './list-texture-slots.js';\nimport { assignDefaults, createTransform, fitPowerOfTwo, fitWithin, formatBytes } from './utils.js';\n\nconst NAME = 'textureCompress';\n\ntype Format = (typeof TEXTURE_COMPRESS_SUPPORTED_FORMATS)[number];\nexport const TEXTURE_COMPRESS_SUPPORTED_FORMATS = ['jpeg', 'png', 'webp', 'avif'] as const;\nconst SUPPORTED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/avif'];\n\n/** Resampling filter methods. LANCZOS3 is sharper, LANCZOS2 is smoother. */\nexport enum TextureResizeFilter {\n\t/** Lanczos3 (sharp) */\n\tLANCZOS3 = 'lanczos3',\n\t/** Lanczos2 (smooth) */\n\tLANCZOS2 = 'lanczos2',\n}\n\nexport interface TextureCompressOptions {\n\t/** Instance of the Sharp encoder, which must be installed from the\n\t * 'sharp' package and provided by the caller. When not provided, a\n\t * platform-specific fallback implementation will be used, and most\n\t * quality- and compression-related options are ignored.\n\t */\n\tencoder?: unknown;\n\t/**\n\t * Target image format. If specified, included textures in other formats\n\t * will be converted. Default: original format.\n\t */\n\ttargetFormat?: Format;\n\t/**\n\t * Resizes textures to given maximum width/height, preserving aspect ratio.\n\t * For example, a 4096x8192 texture, resized with limit [2048, 2048] will\n\t * be reduced to 1024x2048.\n\t *\n\t * Presets \"nearest-pot\", \"ceil-pot\", and \"floor-pot\" resize textures to\n\t * power-of-two dimensions, for older graphics APIs including WebGL 1.0.\n\t */\n\tresize?: vec2 | 'nearest-pot' | 'ceil-pot' | 'floor-pot';\n\t/** Interpolation used if resizing. Default: TextureResizeFilter.LANCZOS3. */\n\tresizeFilter?: TextureResizeFilter;\n\t/** Pattern identifying textures to compress, matched to name or URI. */\n\tpattern?: RegExp | null;\n\t/**\n\t * Pattern matching the format(s) to be compressed or converted. Some examples\n\t * of formats include \"jpeg\" and \"png\".\n\t */\n\tformats?: RegExp | null;\n\t/**\n\t * Pattern matching the material texture slot(s) to be compressed or converted.\n\t * Some examples of slot names include \"baseColorTexture\", \"occlusionTexture\",\n\t * \"metallicRoughnessTexture\", and \"normalTexture\".\n\t */\n\tslots?: RegExp | null;\n\n\t/** Quality, 1-100. Default: auto. */\n\tquality?: number | null;\n\t/**\n\t * Level of CPU effort to reduce file size, 0-100. PNG, WebP, and AVIF\n\t * only. Supported only when a Sharp encoder is provided. Default: auto.\n\t */\n\teffort?: number | null;\n\t/**\n\t * Use lossless compression mode. WebP and AVIF only. Supported only when a\n\t * Sharp encoder is provided. Default: false.\n\t */\n\tlossless?: boolean;\n\t/**\n\t * Use near lossless compression mode. WebP only. Supported only when a\n\t * Sharp encoder is provided. Default: false.\n\t */\n\tnearLossless?: boolean;\n\n\t/**\n\t * Attempts to avoid processing images that could exceed memory or other other\n\t * limits, throwing an error instead. Default: true.\n\t * @experimental\n\t */\n\tlimitInputPixels?: boolean;\n}\n\nexport type CompressTextureOptions = Omit<TextureCompressOptions, 'pattern' | 'formats' | 'slots'>;\n\n// IMPORTANT: No defaults for quality flags, see https://github.com/donmccurdy/glTF-Transform/issues/969.\nexport const TEXTURE_COMPRESS_DEFAULTS: Omit<TextureCompressOptions, 'resize' | 'targetFormat' | 'encoder'> = {\n\tresizeFilter: TextureResizeFilter.LANCZOS3,\n\tpattern: undefined,\n\tformats: undefined,\n\tslots: undefined,\n\tquality: undefined,\n\teffort: undefined,\n\tlossless: false,\n\tnearLossless: false,\n\tlimitInputPixels: true,\n};\n\n/**\n * Optimizes images, optionally resizing or converting to JPEG, PNG, WebP, or AVIF formats.\n *\n * For best results use a Node.js environment, install the `sharp` module, and\n * provide an encoder. When the encoder is omitted  `sharp` works only in Node.js \n * the implementation will use a platform-specific fallback encoder, and most\n * quality- and compression-related options are ignored.\n *\n * Example:\n *\n * ```javascript\n * import { textureCompress } from '@gltf-transform/functions';\n * import sharp from 'sharp';\n *\n * // (A) Optimize without conversion.\n * await document.transform(\n * \ttextureCompress({encoder: sharp})\n * );\n *\n * // (B) Optimize and convert images to WebP.\n * await document.transform(\n * \ttextureCompress({\n * \t\tencoder: sharp,\n * \t\ttargetFormat: 'webp',\n * \t\tslots: /^(?!normalTexture).*$/ // exclude normal maps\n * \t})\n * );\n *\n * // (C) Resize and convert images to WebP in a browser, without a Sharp\n * // encoder. Most quality- and compression-related options are ignored.\n * await document.transform(\n * \ttextureCompress({ targetFormat: 'webp', resize: [1024, 1024] })\n * );\n * ```\n *\n * @category Transforms\n */\nexport function textureCompress(_options: TextureCompressOptions): Transform {\n\tconst options = assignDefaults(TEXTURE_COMPRESS_DEFAULTS, _options);\n\tconst targetFormat = options.targetFormat as Format | undefined;\n\tconst patternRe = options.pattern;\n\tconst formatsRe = options.formats;\n\tconst slotsRe = options.slots;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst textures = document.getRoot().listTextures();\n\n\t\tawait Promise.all(\n\t\t\ttextures.map(async (texture, textureIndex) => {\n\t\t\t\tconst slots = listTextureSlots(texture);\n\t\t\t\tconst channels = getTextureChannelMask(texture);\n\t\t\t\tconst textureLabel =\n\t\t\t\t\ttexture.getURI() ||\n\t\t\t\t\ttexture.getName() ||\n\t\t\t\t\t`${textureIndex + 1}/${document.getRoot().listTextures().length}`;\n\t\t\t\tconst prefix = `${NAME}(${textureLabel})`;\n\n\t\t\t\t// FILTER: Exclude textures that don't match (a) 'slots' or (b) expected formats.\n\n\t\t\t\tif (!SUPPORTED_MIME_TYPES.includes(texture.getMimeType())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, unsupported texture type \"${texture.getMimeType()}\".`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (patternRe && !patternRe.test(texture.getName()) && !patternRe.test(texture.getURI())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, excluded by \"pattern\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (formatsRe && !formatsRe.test(texture.getMimeType())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, \"${texture.getMimeType()}\" excluded by \"formats\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (slotsRe && slots.length && !slots.some((slot) => slotsRe.test(slot))) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, [${slots.join(', ')}] excluded by \"slots\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (options.targetFormat === 'jpeg' && channels & TextureChannel.A) {\n\t\t\t\t\tlogger.warn(`${prefix}: Skipping, [${slots.join(', ')}] requires alpha channel.`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst srcFormat = getFormat(texture);\n\t\t\t\tconst dstFormat = targetFormat || srcFormat;\n\t\t\t\tlogger.debug(`${prefix}: Format = ${srcFormat}  ${dstFormat}`);\n\t\t\t\tlogger.debug(`${prefix}: Slots = [${slots.join(', ')}]`);\n\n\t\t\t\tconst srcImage = texture.getImage()!;\n\t\t\t\tconst srcByteLength = srcImage.byteLength;\n\n\t\t\t\tawait compressTexture(texture, options);\n\n\t\t\t\tconst dstImage = texture.getImage()!;\n\t\t\t\tconst dstByteLength = dstImage.byteLength;\n\n\t\t\t\tconst flag = srcImage === dstImage ? ' (SKIPPED' : '';\n\n\t\t\t\tlogger.debug(`${prefix}: Size = ${formatBytes(srcByteLength)}  ${formatBytes(dstByteLength)}${flag}`);\n\t\t\t}),\n\t\t);\n\n\t\t// Attach EXT_texture_webp if needed.\n\t\tconst webpExtension = document.createExtension(EXTTextureWebP);\n\t\tif (textures.some((texture) => texture.getMimeType() === 'image/webp')) {\n\t\t\twebpExtension.setRequired(true);\n\t\t} else {\n\t\t\twebpExtension.dispose();\n\t\t}\n\n\t\t// Attach EXT_texture_avif if needed.\n\t\tconst avifExtension = document.createExtension(EXTTextureAVIF);\n\t\tif (textures.some((texture) => texture.getMimeType() === 'image/avif')) {\n\t\t\tavifExtension.setRequired(true);\n\t\t} else {\n\t\t\tavifExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Optimizes a single {@link Texture}, optionally resizing or converting to JPEG, PNG, WebP, or AVIF formats.\n *\n * For best results use a Node.js environment, install the `sharp` module, and\n * provide an encoder. When the encoder is omitted  `sharp` works only in Node.js \n * the implementation will use a platform-specific fallback encoder, and most\n * quality- and compression-related options are ignored.\n *\n * Example:\n *\n * ```javascript\n * import { compressTexture } from '@gltf-transform/functions';\n * import sharp from 'sharp';\n *\n * const texture = document.getRoot().listTextures()\n * \t.find((texture) => texture.getName() === 'MyTexture');\n *\n * // (A) Node.js.\n * await compressTexture(texture, {\n * \tencoder: sharp,\n * \ttargetFormat: 'webp',\n * \tresize: [1024, 1024]\n * });\n *\n * // (B) Web.\n * await compressTexture(texture, {\n * \ttargetFormat: 'webp',\n * \tresize: [1024, 1024]\n * });\n * ```\n */\nexport async function compressTexture(texture: Texture, _options: CompressTextureOptions): Promise<void> {\n\tconst options = { ...TEXTURE_COMPRESS_DEFAULTS, ..._options } as Required<CompressTextureOptions>;\n\tconst encoder = options.encoder as typeof sharp | null;\n\n\tconst srcURI = texture.getURI();\n\tconst srcFormat = getFormat(texture);\n\tconst dstFormat = options.targetFormat || srcFormat;\n\tconst srcMimeType = texture.getMimeType();\n\tconst dstMimeType = `image/${dstFormat}`;\n\n\tconst srcImage = texture.getImage()!;\n\tconst dstImage = encoder\n\t\t? await _encodeWithSharp(srcImage, srcMimeType, dstMimeType, options)\n\t\t: await _encodeWithNdarrayPixels(srcImage, srcMimeType, dstMimeType, options);\n\n\tconst srcByteLength = srcImage.byteLength;\n\tconst dstByteLength = dstImage.byteLength;\n\n\tif (srcMimeType === dstMimeType && dstByteLength >= srcByteLength && !options.resize) {\n\t\t// Skip if src/dst formats match and dst is larger than the original.\n\t\treturn;\n\t} else if (srcMimeType === dstMimeType) {\n\t\t// Overwrite if src/dst formats match and dst is smaller than the original.\n\t\ttexture.setImage(dstImage);\n\t} else {\n\t\t// Overwrite, then update path and MIME type if src/dst formats differ.\n\t\tconst srcExtension = srcURI ? FileUtils.extension(srcURI) : ImageUtils.mimeTypeToExtension(srcMimeType);\n\t\tconst dstExtension = ImageUtils.mimeTypeToExtension(dstMimeType);\n\t\tconst dstURI = texture.getURI().replace(new RegExp(`\\\\.${srcExtension}$`), `.${dstExtension}`);\n\t\ttexture.setImage(dstImage).setMimeType(dstMimeType).setURI(dstURI);\n\t}\n}\n\nasync function _encodeWithSharp(\n\tsrcImage: Uint8Array,\n\t_srcMimeType: string,\n\tdstMimeType: string,\n\toptions: Required<CompressTextureOptions>,\n): Promise<Uint8Array> {\n\tconst encoder = options.encoder as typeof sharp;\n\tlet encoderOptions: sharp.JpegOptions | sharp.PngOptions | sharp.WebpOptions | sharp.AvifOptions = {};\n\n\tconst dstFormat = getFormatFromMimeType(dstMimeType);\n\n\tswitch (dstFormat) {\n\t\tcase 'jpeg':\n\t\t\tencoderOptions = { quality: options.quality } as sharp.JpegOptions;\n\t\t\tbreak;\n\t\tcase 'png':\n\t\t\tencoderOptions = {\n\t\t\t\tquality: options.quality,\n\t\t\t\teffort: remap(options.effort, 100, 10),\n\t\t\t} as sharp.PngOptions;\n\t\t\tbreak;\n\t\tcase 'webp':\n\t\t\tencoderOptions = {\n\t\t\t\tquality: options.quality,\n\t\t\t\teffort: remap(options.effort, 100, 6),\n\t\t\t\tlossless: options.lossless,\n\t\t\t\tnearLossless: options.nearLossless,\n\t\t\t} as sharp.WebpOptions;\n\t\t\tbreak;\n\t\tcase 'avif':\n\t\t\tencoderOptions = {\n\t\t\t\tquality: options.quality,\n\t\t\t\teffort: remap(options.effort, 100, 9),\n\t\t\t\tlossless: options.lossless,\n\t\t\t} as sharp.AvifOptions;\n\t\t\tbreak;\n\t}\n\n\tconst limitInputPixels = options.limitInputPixels;\n\tconst instance = encoder(srcImage, { limitInputPixels }).toFormat(dstFormat, encoderOptions);\n\n\tif (options.resize) {\n\t\tconst srcSize = ImageUtils.getSize(srcImage, _srcMimeType)!;\n\t\tconst dstSize = Array.isArray(options.resize)\n\t\t\t? fitWithin(srcSize, options.resize)\n\t\t\t: fitPowerOfTwo(srcSize, options.resize);\n\t\tinstance.resize(dstSize[0], dstSize[1], { fit: 'fill', kernel: options.resizeFilter });\n\t}\n\n\treturn BufferUtils.toView(await instance.toBuffer());\n}\n\nasync function _encodeWithNdarrayPixels(\n\tsrcImage: Uint8Array,\n\tsrcMimeType: string,\n\tdstMimeType: string,\n\toptions: Required<CompressTextureOptions>,\n): Promise<Uint8Array> {\n\tconst srcPixels = (await getPixels(srcImage, srcMimeType)) as ndarray.NdArray<Uint8Array>;\n\n\tif (options.resize) {\n\t\tconst [w, h] = srcPixels.shape;\n\t\tconst dstSize = Array.isArray(options.resize)\n\t\t\t? fitWithin([w, h], options.resize)\n\t\t\t: fitPowerOfTwo([w, h], options.resize);\n\t\tconst dstPixels = ndarray(new Uint8Array(dstSize[0] * dstSize[1] * 4), [...dstSize, 4]);\n\t\toptions.resizeFilter === TextureResizeFilter.LANCZOS3\n\t\t\t? lanczos3(srcPixels, dstPixels)\n\t\t\t: lanczos2(srcPixels, dstPixels);\n\t\treturn savePixels(dstPixels, dstMimeType);\n\t}\n\n\treturn savePixels(srcPixels, dstMimeType);\n}\n\nfunction getFormat(texture: Texture): Format {\n\treturn getFormatFromMimeType(texture.getMimeType());\n}\n\nfunction getFormatFromMimeType(mimeType: string): Format {\n\tconst format = mimeType.split('/').pop() as Format | undefined;\n\tif (!format || !TEXTURE_COMPRESS_SUPPORTED_FORMATS.includes(format)) {\n\t\tthrow new Error(`Unknown MIME type \"${mimeType}\".`);\n\t}\n\treturn format;\n}\n\nfunction remap(value: number | null | undefined, srcMax: number, dstMax: number): number | undefined {\n\tif (value == null) return undefined;\n\treturn Math.round((value / srcMax) * dstMax);\n}\n", "import { type Accessor, Document, type Node, type Transform } from '@gltf-transform/core';\nimport { EXTMeshGPUInstancing, type InstancedMesh } from '@gltf-transform/extensions';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'uninstance';\n\nexport interface UninstanceOptions {}\nconst UNINSTANCE_DEFAULTS: Required<UninstanceOptions> = {};\n\n/**\n * Removes extension {@link EXTMeshGPUInstancing}, reversing the effects of the\n * {@link instance} transform or similar instancing operations. For each {@link Node}\n * associated with an {@link InstancedMesh}, the Node's {@link Mesh} and InstancedMesh will\n * be detached. In their place, one Node per instance will be attached to the original\n * Node as children, associated with the same Mesh. The extension, `EXT_mesh_gpu_instancing`,\n * will be removed from the {@link Document}.\n *\n * In applications that support `EXT_mesh_gpu_instancing`, removing the extension\n * is likely to substantially increase draw calls and reduce performance. Removing\n * the extension may be helpful for compatibility in applications without such support.\n *\n * Example:\n *\n * ```ts\n * import { uninstance } from '@gltf-transform/functions';\n *\n * document.getRoot().listNodes(); //  [ Node x 10 ]\n *\n * await document.transform(uninstance());\n *\n * document.getRoot().listNodes(); //  [ Node x 1000 ]\n * ```\n *\n * @category Transforms\n */\nexport function uninstance(_options: UninstanceOptions = UNINSTANCE_DEFAULTS): Transform {\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst root = document.getRoot();\n\n\t\tconst instanceAttributes = new Set<Accessor>();\n\n\t\tfor (const srcNode of document.getRoot().listNodes()) {\n\t\t\tconst batch = srcNode.getExtension<InstancedMesh>('EXT_mesh_gpu_instancing');\n\t\t\tif (!batch) continue;\n\n\t\t\t// For each instance, attach a new Node under the source Node.\n\t\t\tfor (const instanceNode of createInstanceNodes(srcNode)) {\n\t\t\t\tsrcNode.addChild(instanceNode);\n\t\t\t}\n\n\t\t\tfor (const instanceAttribute of batch.listAttributes()) {\n\t\t\t\tinstanceAttributes.add(instanceAttribute);\n\t\t\t}\n\n\t\t\tsrcNode.setMesh(null);\n\t\t\tbatch.dispose();\n\t\t}\n\n\t\t// Clean up unused instance attributes.\n\t\tfor (const attribute of instanceAttributes) {\n\t\t\tif (attribute.listParents().every((parent) => parent === root)) {\n\t\t\t\tattribute.dispose();\n\t\t\t}\n\t\t}\n\n\t\t// Remove Extension from Document.\n\t\tdocument.createExtension(EXTMeshGPUInstancing).dispose();\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Given a {@link Node} with an {@link InstancedMesh} extension, returns a list\n * containing one Node per instance in the InstancedMesh. Each Node will have\n * the transform (translation/rotation/scale) of the corresponding instance,\n * and will be assigned to the same {@link Mesh}.\n *\n * May be used to unpack instancing previously applied with {@link instance}\n * and {@link EXTMeshGPUInstancing}. For a transform that applies this operation\n * to the entire {@link Document}, see {@link uninstance}.\n *\n * Example:\n * ```javascript\n * import { createInstanceNodes } from '@gltf-transform/functions';\n *\n * for (const instanceNode of createInstanceNodes(batchNode)) {\n *  batchNode.addChild(instanceNode);\n * }\n *\n * batchNode.setMesh(null).setExtension('EXTMeshGPUInstancing', null);\n * ```\n */\nexport function createInstanceNodes(batchNode: Node): Node[] {\n\tconst batch = batchNode.getExtension<InstancedMesh>('EXT_mesh_gpu_instancing');\n\tif (!batch) return [];\n\n\tconst semantics = batch.listSemantics();\n\tif (semantics.length === 0) return [];\n\n\tconst document = Document.fromGraph(batchNode.getGraph())!;\n\tconst instanceCount = batch.listAttributes()[0].getCount();\n\tconst instanceCountDigits = String(instanceCount).length;\n\tconst mesh = batchNode.getMesh();\n\tconst batchName = batchNode.getName();\n\n\tconst instanceNodes = [];\n\n\t// For each instance construct a Node, assign attributes, and push to list.\n\tfor (let i = 0; i < instanceCount; i++) {\n\t\tconst instanceNode = document.createNode().setMesh(mesh);\n\n\t\t// MyNode_001, MyNode_002, ...\n\t\tif (batchName) {\n\t\t\tconst paddedIndex = String(i).padStart(instanceCountDigits, '0');\n\t\t\tinstanceNode.setName(`${batchName}_${paddedIndex}`);\n\t\t}\n\n\t\t// TRS attributes are applied to node transform; all other attributes are extras.\n\t\tfor (const semantic of semantics) {\n\t\t\tconst attribute = batch.getAttribute(semantic)!;\n\t\t\tswitch (semantic) {\n\t\t\t\tcase 'TRANSLATION':\n\t\t\t\t\tinstanceNode.setTranslation(attribute.getElement(i, [0, 0, 0]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ROTATION':\n\t\t\t\t\tinstanceNode.setRotation(attribute.getElement(i, [0, 0, 0, 1]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SCALE':\n\t\t\t\t\tinstanceNode.setScale(attribute.getElement(i, [1, 1, 1]));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_setInstanceExtras(instanceNode, semantic, attribute, i);\n\t\t\t}\n\t\t}\n\n\t\tinstanceNodes.push(instanceNode);\n\t}\n\n\treturn instanceNodes;\n}\n\nfunction _setInstanceExtras(node: Node, semantic: string, attribute: Accessor, index: number): void {\n\tconst value = attribute.getType() === 'SCALAR' ? attribute.getScalar(index) : attribute.getElement(index, []);\n\tnode.setExtras({ ...node.getExtras(), [semantic]: value });\n}\n", "import type { Document, Transform } from '@gltf-transform/core';\nimport { KHRMaterialsUnlit } from '@gltf-transform/extensions';\n\n/**\n * @category Transforms\n */\nexport function unlit(): Transform {\n\treturn (doc: Document): void => {\n\t\tconst unlitExtension = doc.createExtension(KHRMaterialsUnlit) as KHRMaterialsUnlit;\n\t\tconst unlit = unlitExtension.createUnlit();\n\t\tdoc.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tmaterial.setExtension('KHR_materials_unlit', unlit);\n\t\t\t});\n\t};\n}\n", "import type { Document, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'unpartition';\n\nexport interface UnpartitionOptions {}\nconst UNPARTITION_DEFAULTS: Required<UnpartitionOptions> = {};\n\n/**\n * Removes partitions from the binary payload of a glTF file, so that the asset\n * contains at most one (1) `.bin` {@link Buffer}. This process reverses the\n * changes from a {@link partition} transform.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); //  [Buffer, Buffer, ...]\n *\n * await document.transform(unpartition());\n *\n * document.getRoot().listBuffers(); //  [Buffer]\n * ```\n *\n * @category Transforms\n */\nexport function unpartition(_options: UnpartitionOptions = UNPARTITION_DEFAULTS): Transform {\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tconst buffer = document.getRoot().listBuffers()[0];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listAccessors()\n\t\t\t.forEach((a) => a.setBuffer(buffer));\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.forEach((b, index) => (index > 0 ? b.dispose() : null));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import {\n\tAccessor,\n\tDocument,\n\ttype Mesh,\n\tNode,\n\ttype Primitive,\n\ttype Transform,\n\ttype TypedArrayConstructor,\n\ttype vec2,\n} from '@gltf-transform/core';\nimport type * as watlas from 'watlas';\nimport { compactPrimitive } from './compact-primitive.js';\nimport { dequantizeAttributeArray } from './dequantize.js';\nimport { createTransform, isUsed, shallowCloneAccessor } from './utils.js';\n\nconst NAME = 'unwrap';\n\ninterface IWatlas {\n\tInitialize(): Promise<void>;\n\tAtlas: {\n\t\tnew (): watlas.Atlas;\n\t};\n}\n\n/** Options for the {@link unwrap} transform. */\nexport interface UnwrapOptions {\n\t/** watlas instance. */\n\twatlas: unknown;\n\t/**\n\t * Target texture coordinate index (0, 1, 2, ...) for generated unwrapping.\n\t * Default: 0.\n\t */\n\ttexcoord?: number;\n\t/**\n\t * Whether to overwrite existing attributes at the target texCoord index, if\n\t * any. Default: false.\n\t */\n\toverwrite?: boolean;\n\t/**\n\t * Methods of grouping texcoords with the {@link unwrap} function.\n\t * Default: 'mesh'.\n\t */\n\tgroupBy?: 'primitive' | 'mesh' | 'scene';\n}\n\n/** Options for the {@link unwrapPrimitives} function. */\nexport interface UnwrapPrimitivesOptions {\n\t/** watlas instance. */\n\twatlas: unknown;\n\t/**\n\t * Target texture coordinate index (0, 1, 2, ...) for generated unwrapping.\n\t * Default: 0.\n\t */\n\ttexcoord?: number;\n\t/**\n\t * Whether to overwrite existing attributes at the target texCoord index, if\n\t * any. Default: false.\n\t */\n\toverwrite?: boolean;\n\t/**\n\t * Per-primitive texel density weights. Texel space in the atlas is allocated\n\t * proportionally with geometry dimensions in local space. If specified,\n\t * weights scale the allocation. Default: [1, 1, 1, ...].\n\t */\n\tweights?: number[];\n}\n\nexport const UNWRAP_DEFAULTS: Required<Omit<UnwrapOptions, 'watlas'>> = {\n\ttexcoord: 0,\n\toverwrite: false,\n\tgroupBy: 'mesh',\n};\n\n/**\n * Generate new texture coordinates (UV mappings) for {@link Primitive Primitives}.\n * Useful for adding texture coordinates in scenes without existing UVs, or for\n * creating a second set of texture coordinates for baked textures such as ambient\n * occlusion maps and lightmaps. Operation may increase vertex count to\n * accommodate UV seams.\n *\n * UV layouts may be grouped, reducing the number of textures required. Available\n * groupings:\n *\n * - `\"primitive\"`: Each primitive is given it's own texcoord atlas.\n * - `\"mesh\"`: All primitives in a mesh share a texcoord atlas. (default)\n * - `\"scene\"`: All primitives in the scene share a texcoord atlas.\n *\n * Example:\n *\n * ```ts\n * import * as watlas from 'watlas';\n * import { unwrap } from '@gltf-transform/functions';\n *\n * // Generate a TEXCOORD_1 attribute for all primitives.\n * await document.transform(\n *   unwrap({ watlas, texcoord: 1, overwrite: true, groupBy: 'scene' })\n * );\n * ```\n *\n * For more control and customization, see {@link unwrapPrimitives}.\n *\n * @experimental\n * @category Transforms\n */\nexport function unwrap(_options: UnwrapOptions): Transform {\n\tconst options = { ...UNWRAP_DEFAULTS, ..._options } as Required<UnwrapOptions>;\n\n\tconst watlas = options.watlas as IWatlas | undefined;\n\n\tif (!watlas) {\n\t\tthrow new Error(`${NAME}: dependency required  install \"watlas\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tawait watlas!.Initialize();\n\n\t\tswitch (options.groupBy) {\n\t\t\tcase 'primitive': {\n\t\t\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\t\t\tunwrapPrimitives([prim], options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'mesh': {\n\t\t\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\t\t\tunwrapPrimitives(mesh.listPrimitives(), options);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'scene': {\n\t\t\t\tconst prims: Primitive[] = [];\n\t\t\t\tconst weights: number[] = [];\n\t\t\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\t\t\tconst weight = getNodeScaleMax(mesh);\n\t\t\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\t\t\tprims.push(prim);\n\t\t\t\t\t\tweights.push(weight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tunwrapPrimitives(prims, { ...options, weights });\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst logger = document.getLogger();\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Generate new texture coordinates (UV mappings) for {@link Primitive Primitives}.\n * Useful for adding texture coordinates in scenes without existing UVs, or for\n * creating a second set of texture coordinates for baked textures such as ambient\n * occlusion maps and lightmaps. Operation may increase vertex count to\n * accommodate UV seams.\n *\n * UV layouts may be grouped, reducing the number of textures required. Available\n * groupings:\n *\n * - `\"primitive\"`: Each primitive is given it's own texcoord atlas.\n * - `\"mesh\"`: All primitives in a mesh share a texcoord atlas. (default)\n * - `\"scene\"`: All primitives in the scene share a texcoord atlas.\n *\n * watlas must be initialized before calling this function.\n *\n * Example:\n *\n * ```ts\n * import * as watlas from 'watlas';\n * import { unwrapPrimitives } from '@gltf-transform/functions';\n *\n * // Initialize watlas.\n * await watlas.Initialize();\n *\n * // Generate a TEXCOORD_1 attribute for the specified primitives.\n * unwrapPrimitives(mesh.listPrimitives(), {\n *   watlas,\n *   texcoord: 1,\n *   overwrite: true\n * });\n * ```\n *\n * To create texture coordinates for an entire Document, see {@link unwrap}.\n *\n * @experimental\n */\nexport function unwrapPrimitives(primitives: Primitive[], options: UnwrapPrimitivesOptions): void {\n\tconst document = Document.fromGraph(primitives[0].getGraph())!;\n\tconst watlas = options.watlas as IWatlas | undefined;\n\tconst dstTexCoordIndex = options.texcoord ?? 0;\n\tconst dstSemantic = `TEXCOORD_${dstTexCoordIndex}`;\n\n\tif (!watlas) {\n\t\tthrow new Error(`${NAME}: dependency required  install \"watlas\".`);\n\t}\n\n\tconst atlas = new watlas.Atlas();\n\n\tconst unwrapPrims = [];\n\tfor (let i = 0; i < primitives.length; i++) {\n\t\tconst prim = primitives[i];\n\t\tconst primWeight = options.weights ? options.weights[i] : 1;\n\n\t\t// Don't process primitives that already have the desired TEXCOORD index\n\t\t// if overwrite is false.\n\t\tif (!options.overwrite && prim.getAttribute(dstSemantic)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst unwrapPrim = compactPrimitive(prim);\n\n\t\t// Always pass vertex position data\n\t\tconst position = unwrapPrim.getAttribute('POSITION')!;\n\n\t\tconst meshDecl: watlas.MeshDecl = {\n\t\t\tvertexCount: position.getCount(),\n\t\t\tvertexPositionData: getScaledAttributeFloat32Array(position, primWeight),\n\t\t\tvertexPositionStride: position.getElementSize() * Float32Array.BYTES_PER_ELEMENT,\n\t\t};\n\n\t\t// Pass normal data if available to improve unwrapping\n\t\tconst normal = unwrapPrim.getAttribute('NORMAL');\n\t\tif (normal) {\n\t\t\tmeshDecl.vertexNormalData = getAttributeFloat32Array(normal);\n\t\t\tmeshDecl.vertexNormalStride = normal.getElementSize() * Float32Array.BYTES_PER_ELEMENT;\n\t\t}\n\n\t\t// Pass texcoord data from set 0 if it's available and not the set that\n\t\t// is being generated.\n\t\tif (options.texcoord !== 0) {\n\t\t\tconst texcoord = unwrapPrim.getAttribute('TEXCOORD_0');\n\t\t\tif (texcoord) {\n\t\t\t\tmeshDecl.vertexUvData = getAttributeFloat32Array(texcoord);\n\t\t\t\tmeshDecl.vertexUvStride = texcoord.getElementSize() * Float32Array.BYTES_PER_ELEMENT;\n\t\t\t}\n\t\t}\n\n\t\t// Pass indices if available\n\t\tconst indices = unwrapPrim.getIndices();\n\t\tif (indices) {\n\t\t\tconst indicesArray = indices.getArray()!;\n\t\t\tmeshDecl.indexCount = indices.getCount();\n\t\t\tmeshDecl.indexData =\n\t\t\t\tindicesArray instanceof Uint8Array\n\t\t\t\t\t? new Uint16Array(indicesArray)\n\t\t\t\t\t: (indicesArray as Uint16Array | Uint32Array);\n\t\t}\n\n\t\tunwrapPrims.push(unwrapPrim);\n\t\tatlas.addMesh(meshDecl);\n\t}\n\n\t// Don't proceed if we skipped every primitive in this group.\n\tif (unwrapPrims.length === 0) {\n\t\treturn;\n\t}\n\n\tatlas.generate();\n\n\tif (atlas.meshCount !== unwrapPrims.length) {\n\t\tthrow new Error(\n\t\t\t`${NAME}: Generated an unexpected number of atlas meshes. (got: ${atlas.meshCount}, expected: ${unwrapPrims.length})`,\n\t\t);\n\t}\n\n\t// xatlas UVs are in texels, so they need to be normalized before saving to\n\t// the glTF attribute.\n\tconst scale: vec2 = [1 / atlas.width, 1 / atlas.height];\n\n\tfor (let i = 0; i < atlas.meshCount; i++) {\n\t\tconst prim = unwrapPrims[i];\n\t\tconst atlasMesh = atlas.getMesh(i);\n\n\t\t// Clean up previous TEXCOORD_* attribute, if there was any.\n\t\tconst srcTexCoord = prim.getAttribute(dstSemantic);\n\t\tif (srcTexCoord) {\n\t\t\tprim.setAttribute(dstSemantic, null);\n\t\t\tif (!isUsed(srcTexCoord)) srcTexCoord.dispose();\n\t\t}\n\n\t\t// Remap Vertex attributes.\n\t\tfor (const srcAttribute of prim.listAttributes()) {\n\t\t\tprim.swap(srcAttribute, remapAttribute(document, srcAttribute, atlasMesh));\n\n\t\t\t// Clean up.\n\t\t\tif (!isUsed(srcAttribute)) srcAttribute.dispose();\n\t\t}\n\n\t\t// Remap morph target vertex attributes.\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tfor (const srcAttribute of target.listAttributes()) {\n\t\t\t\ttarget.swap(srcAttribute, remapAttribute(document, srcAttribute, atlasMesh));\n\n\t\t\t\t// Clean up.\n\t\t\t\tif (!isUsed(srcAttribute)) srcAttribute.dispose();\n\t\t\t}\n\t\t}\n\n\t\t// Add new TEXCOORD_* attribute.\n\t\tconst dstTexCoord = document\n\t\t\t.createAccessor()\n\t\t\t.setArray(new Float32Array(atlasMesh.vertexCount * 2))\n\t\t\t.setType('VEC2');\n\t\tfor (let j = 0; j < atlasMesh.vertexCount; j++) {\n\t\t\tconst vertex = atlasMesh.getVertex(j);\n\t\t\tdstTexCoord.setElement(j, [vertex.uv[0] * scale[0], vertex.uv[1] * scale[1]]);\n\t\t}\n\t\tprim.setAttribute(dstSemantic, dstTexCoord);\n\n\t\t// The glTF spec says that if TEXCOORD_N (where N > 0) exists then\n\t\t// TEXCOORD_N-1...TEXCOORD_0 must also exist. If any prior TEXCOORD\n\t\t// attributes are missing, copy this attribute to satisfy that requirement.\n\t\tfor (let j = dstTexCoordIndex - 1; j >= 0; j--) {\n\t\t\tconst semantic = `TEXCOORD_${j}`;\n\t\t\tif (!prim.getAttribute(semantic)) {\n\t\t\t\tprim.setAttribute(semantic, dstTexCoord);\n\t\t\t}\n\t\t}\n\n\t\t// Update Indices.\n\t\tconst dstIndicesArray = new Uint32Array(atlasMesh.indexCount);\n\t\tatlasMesh.getIndexArray(dstIndicesArray);\n\n\t\tconst dstIndices = document.createAccessor().setArray(dstIndicesArray).setType('SCALAR');\n\t\tconst srcIndices = prim.getIndices();\n\t\tprim.setIndices(dstIndices);\n\t\tif (srcIndices && !isUsed(srcIndices)) {\n\t\t\tsrcIndices.dispose();\n\t\t}\n\t}\n\n\tatlas.delete();\n}\n\n// Returns a new attribute with the same values at as source attribute, but\n// re-ordered according to the vertex order output by xatlas to account for\n// vertex splitting.\nfunction remapAttribute(document: Document, srcAttribute: Accessor, atlasMesh: watlas.Mesh): Accessor {\n\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute);\n\tconst ArrayCtor = srcAttribute.getArray()!.constructor as TypedArrayConstructor;\n\tdstAttribute.setArray(new ArrayCtor(atlasMesh.vertexCount * srcAttribute.getElementSize()));\n\n\tconst el: number[] = [];\n\tfor (let i = 0; i < atlasMesh.vertexCount; i++) {\n\t\tconst vertex = atlasMesh.getVertex(i);\n\t\tdstAttribute.setElement(i, srcAttribute.getElement(vertex.xref, el));\n\t}\n\n\treturn dstAttribute;\n}\n\n// Returns the values of the given attribute as a Float32Array.\nfunction getAttributeFloat32Array(attribute: Accessor): Float32Array {\n\tif (attribute.getComponentType() === Accessor.ComponentType.FLOAT) {\n\t\treturn attribute.getArray() as Float32Array;\n\t}\n\treturn dequantizeAttributeArray(attribute.getArray()!, attribute.getComponentType(), attribute.getNormalized());\n}\n\n// Returns scaled values of the given attribute as a Float32Array.\nfunction getScaledAttributeFloat32Array(attribute: Accessor, scale: number): Float32Array {\n\tconst array = dequantizeAttributeArray(\n\t\tattribute.getArray()!,\n\t\tattribute.getComponentType(),\n\t\tattribute.getNormalized(),\n\t);\n\n\tfor (let i = 0; i < array.length; i++) {\n\t\tarray[i] *= scale;\n\t}\n\n\treturn array;\n}\n\nfunction getNodeScaleMax(mesh: Mesh): number {\n\tlet scale = -Infinity;\n\n\tfor (const parent of mesh.listParents()) {\n\t\tif (parent instanceof Node) {\n\t\t\tconst s = parent.getWorldScale();\n\t\t\tscale = Number.isFinite(s[0]) ? Math.max(scale, Math.abs(s[0])) : scale;\n\t\t\tscale = Number.isFinite(s[1]) ? Math.max(scale, Math.abs(s[1])) : scale;\n\t\t\tscale = Number.isFinite(s[2]) ? Math.max(scale, Math.abs(s[2])) : scale;\n\t\t}\n\t}\n\n\treturn scale > 0 && Number.isFinite(scale) ? scale : 1;\n}\n", "import type { Accessor, Document, Primitive, Transform, vec3 } from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'vertexColorSpace';\n\n/** Options for the {@link vertexColorSpace} function. */\nexport interface ColorSpaceOptions {\n\t/** Input color space of vertex colors, to be converted to \"srgb-linear\". Required. */\n\tinputColorSpace: 'srgb' | 'srgb-linear';\n}\n\n/**\n * Vertex color color space correction. The glTF format requires vertex colors to be stored\n * in Linear Rec. 709 D65 color space, and this function provides a way to correct vertex\n * colors that are (incorrectly) stored in sRGB.\n *\n * Example:\n *\n * ```typescript\n * import { vertexColorSpace } from '@gltf-transform/functions';\n *\n * await document.transform(\n *   vertexColorSpace({ inputColorSpace: 'srgb' })\n * );\n * ```\n *\n * @category Transforms\n */\nexport function vertexColorSpace(options: ColorSpaceOptions): Transform {\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tconst inputColorSpace = (options.inputColorSpace || '').toLowerCase();\n\n\t\tif (inputColorSpace === 'srgb-linear') {\n\t\t\tlogger.info(`${NAME}: Vertex colors already linear. Skipping conversion.`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (inputColorSpace !== 'srgb') {\n\t\t\tlogger.error(\n\t\t\t\t`${NAME}: Unknown input color space \"${inputColorSpace}\"  should be \"srgb\" or ` +\n\t\t\t\t\t'\"srgb-linear\". Skipping conversion.',\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst converted = new Set<Accessor>();\n\n\t\t// Source: THREE.Color\n\t\tfunction sRGBToLinear(c: number): number {\n\t\t\treturn c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n\t\t}\n\n\t\tfunction updatePrimitive(primitive: Primitive): void {\n\t\t\tconst color = [0, 0, 0] as vec3;\n\t\t\tlet attribute: Accessor | null;\n\t\t\tfor (let i = 0; (attribute = primitive.getAttribute(`COLOR_${i}`)); i++) {\n\t\t\t\tif (converted.has(attribute)) continue;\n\n\t\t\t\tfor (let j = 0; j < attribute.getCount(); j++) {\n\t\t\t\t\tattribute.getElement(j, color);\n\t\t\t\t\tcolor[0] = sRGBToLinear(color[0]);\n\t\t\t\t\tcolor[1] = sRGBToLinear(color[1]);\n\t\t\t\t\tcolor[2] = sRGBToLinear(color[2]);\n\t\t\t\t\tattribute.setElement(j, color);\n\t\t\t\t}\n\n\t\t\t\tconverted.add(attribute);\n\t\t\t}\n\t\t}\n\n\t\tdoc.getRoot()\n\t\t\t.listMeshes()\n\t\t\t.forEach((mesh) => mesh.listPrimitives().forEach(updatePrimitive));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n"],
  "mappings": "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",
  "names": ["n", "a", "i", "n", "len", "a", "t", "a", "getPixelsInternal", "buffer", "mimeType", "Uint8Array", "Error", "blob", "Blob", "type", "createImageBitmap", "premultiplyAlpha", "colorSpaceConversion", "then", "img", "canvas", "OffscreenCanvas", "width", "height", "context", "getContext", "drawImage", "pixels", "getImageData", "ndarray", "data", "putPixelData", "array", "frame", "shape", "length", "pick", "ops", "assign", "assigns", "stride", "offset", "savePixelsInternal", "options", "imageData", "putImageData", "streamCanvas", "convertToBlob", "ab", "arrayBuffer", "getPixels", "savePixels", "typeOrOptions", "quality", "undefined", "filterValue", "x", "a", "xPi", "Math", "PI", "sin", "filters", "srcSize", "destSize", "scale", "offset", "use2", "floatType", "intType", "fixedFracBits", "mul", "toFixedPoint", "value", "round", "scaleInverted", "scaleClamped", "min", "srcWindow", "packedFilter", "floor", "packedFilterPtr", "destPixel", "sourcePixel", "sourceFirst", "max", "sourceLast", "ceil", "filterElementSize", "floatFilter", "fxpFilter", "total", "index", "pixel", "floatValue", "filterTotal", "length", "leftNotEmpty", "rightNotEmpty", "filterSize", "set", "subarray", "convolve", "src", "dst", "_", "srcHeight", "shape", "dstWidth", "maxValue", "data", "BYTES_PER_ELEMENT", "clamp", "v", "fixedFracMul", "fixedFracMul2", "srcY", "dstY", "filterPtr", "dstX", "srcX", "r", "g", "b", "get", "Method", "resize", "method", "TypeError", "srcWidth", "dstHeight", "ratioX", "ratioY", "dtype", "Float32Array", "Int16Array", "Float64Array", "Int32Array", "filtersX", "LANCZOS_2", "filtersY", "tmp", "ndarray", "constructor", "tmpTranspose", "transpose", "dstTranspose", "lanczos3", "LANCZOS_3", "lanczos2", "POINTS", "LINES", "LINE_STRIP", "LINE_LOOP", "TRIANGLES", "TRIANGLE_STRIP", "TRIANGLE_FAN", "Primitive", "Mode", "createTransform", "name", "fn", "Object", "defineProperty", "value", "isTransformPending", "context", "initial", "pending", "initialIndex", "stack", "lastIndexOf", "pendingIndex", "assignDefaults", "defaults", "options", "result", "_extends", "key", "undefined", "rewriteTexture", "source", "target", "srcImage", "getImage", "pixels", "getPixels", "getMimeType", "i", "shape", "j", "dstImage", "savePixels", "setImage", "setMimeType", "getGLPrimitiveCount", "prim", "indices", "getIndices", "position", "getAttribute", "getMode", "getCount", "Error", "SetMap", "constructor", "_map", "Map", "size", "has", "k", "add", "v", "entry", "get", "Set", "set", "keys", "formatBytes", "bytes", "decimals", "dm", "sizes", "Math", "floor", "log", "parseFloat", "pow", "toFixed", "_longFormatter", "Intl", "NumberFormat", "maximumFractionDigits", "formatLong", "x", "format", "formatDelta", "a", "b", "prefix", "suffix", "abs", "formatDeltaOp", "deepListAttributes", "accessors", "attribute", "listAttributes", "push", "listTargets", "Array", "from", "deepSwapAttribute", "src", "dst", "swap", "deepDisposePrimitive", "attributes", "dispose", "isUsed", "shallowEqualsArray", "length", "shallowCloneAccessor", "document", "accessor", "createAccessor", "getName", "setArray", "getArray", "setType", "getType", "setBuffer", "getBuffer", "setNormalized", "getNormalized", "setSparse", "getSparse", "createIndices", "count", "maxIndex", "array", "createIndicesEmpty", "Uint16Array", "Uint32Array", "prop", "listParents", "some", "parent", "propertyType", "PropertyType", "ROOT", "isEmptyObject", "object", "_key", "createPrimGroupKey", "Document", "fromGraph", "getGraph", "material", "getMaterial", "materialIndex", "getRoot", "listMaterials", "indexOf", "mode", "BASIC_MODE_MAPPING", "listSemantics", "sort", "map", "semantic", "elementSize", "getElementSize", "componentType", "getComponentType", "join", "targets", "fitWithin", "limit", "maxWidth", "maxHeight", "srcWidth", "srcHeight", "dstWidth", "dstHeight", "fitPowerOfTwo", "method", "isPowerOfTwo", "nearestPowerOfTwo", "ceilPowerOfTwo", "floorPowerOfTwo", "lo", "hi", "LN2", "ceil", "NAME", "CENTER_DEFAULTS", "pivot", "center", "_options", "doc", "logger", "getLogger", "root", "isAnimated", "listAnimations", "listSkins", "listScenes", "forEach", "scene", "index", "debug", "bbox", "getBounds", "max", "min", "offset", "offsetNode", "createNode", "setTranslation", "listChildren", "child", "addChild", "t", "getTranslation", "listNodeScenes", "node", "visited", "getParentNode", "filter", "Scene", "clearNodeParent", "scenes", "setMatrix", "getWorldMatrix", "removeChild", "invert", "multiply", "s", "VertexCountMethod", "getSceneVertexCount", "_getSubtreeVertexCount", "getNodeVertexCount", "instancedMeshes", "nonInstancedMeshes", "meshes", "traverse", "mesh", "getMesh", "batch", "getExtension", "prims", "flatMap", "listPrimitives", "positions", "uniquePositions", "uniqueMeshes", "uniquePrims", "RENDER", "RENDER_CACHED", "_sum", "getMeshVertexCount", "UPLOAD_NAIVE", "UPLOAD", "DISTINCT", "DISTINCT_POSITION", "_assertNotImplemented", "UNUSED", "_sumUnused", "_assertUnreachable", "getPrimitiveVertexCount", "values", "total", "attributeIndexMap", "indicesSet", "unused", "usedIndices", "Uint8Array", "indicesArray", "il", "EMPTY_U32", "VertexStream", "u8", "u32", "byteStride", "_initAttribute", "buffer", "byteOffset", "byteLength", "getComponentSize", "paddedByteStride", "BufferUtils", "padNumber", "hash", "murmurHash2", "equal", "h", "m", "r", "imul", "hashLookup", "table", "buckets", "stream", "empty", "hashmod", "hashval", "bucket", "probe", "item", "compactPrimitive", "remap", "dstVertexCount", "createCompactPlan", "srcIndices", "srcIndicesArray", "srcIndicesCount", "dstIndices", "dstIndicesCount", "dstIndicesArray", "setIndices", "srcAttributesPrev", "srcAttribute", "dstAttribute", "compactAttribute", "srcArray", "dstArray", "dstDone", "srcIndex", "dstIndex", "srcVertexCount", "fill", "create", "glMatrix.ARRAY_TYPE", "scale", "len", "mul", "WELD_DEFAULTS", "overwrite", "weld", "listMeshes", "weldPrimitive", "graph", "tableSize", "writeMap", "hashIndex", "FLOAT", "Accessor", "ComponentType", "transformPrimitive", "matrix", "applyMatrix", "normal", "applyNormalMatrix", "tangent", "applyTangentMatrix", "determinant", "reversePrimitiveWindingOrder", "normalized", "Float32Array", "vector", "createVec3", "MathUtils", "decodeNormalizedInt", "transformMat4", "normalMatrix", "createMat3", "fromMat4", "transpose", "transformMat3", "normalizeVec3", "v3", "getScalar", "c", "setScalar", "transformMesh", "srcPrim", "dstPrim", "shallowClonePrimitive", "removePrimitive", "addPrimitive", "parentMesh", "isSharedPrimitive", "Mesh", "clone", "isSharedTarget", "removeTarget", "addTarget", "IDENTITY", "clearNodeTransform", "localMatrix", "getMatrix", "eq", "multiplyMat4", "convertPrimitiveToLines", "dstGLPrimitiveCount", "IndicesArray", "ComponentTypeToTypedArray", "srcMode", "setMode", "convertPrimitiveToTriangles", "DEDUP_DEFAULTS", "keepUniqueNames", "propertyTypes", "ACCESSOR", "MESH", "TEXTURE", "MATERIAL", "SKIN", "dedup", "includes", "dedupAccessors", "dedupImages", "dedupMaterials", "dedupMeshes", "dedupSkins", "indicesMap", "attributeMap", "inputMap", "outputMap", "primitive", "hashAccessor", "animation", "sampler", "listSamplers", "getInput", "getOutput", "group", "hashSet", "detectDuplicates", "duplicates", "aData", "toView", "equals", "hashGroup", "input", "output", "refs", "listAccessors", "numMeshes", "srcKeyItems", "createPrimitiveKey", "meshKey", "targetMesh", "textures", "listTextures", "bData", "aSize", "getSize", "bSize", "entries", "property", "Root", "materials", "modifierCache", "skip", "hasModifier", "skins", "listJoints", "primKeyItems", "cache", "visitedNodes", "edgeQueue", "listParentEdges", "edge", "pop", "getAttributes", "modifyChild", "getChild", "childEdge", "listChildEdges", "DEQUANTIZE_DEFAULTS", "pattern", "dequantize", "dequantizePrimitive", "createExtension", "KHRMeshQuantization", "test", "dequantizeAttribute", "dequantizeAttributeArray", "TEXTURE_INFO", "NO_TRANSFER_TYPES", "cloneDocument", "setLogger", "resolve", "createDefaultPropertyResolver", "mergeDocuments", "copy", "sourceExtension", "listExtensionsUsed", "targetExtension", "isRequired", "setRequired", "_copyToDocument", "listNonRootProperties", "moveToDocument", "sourceProperties", "targetProperties", "copyToDocument", "sourcePropertyDependencies", "listPropertyDependencies", "propertyMap", "sourceProp", "targetProp", "PropertyClass", "queue", "next", "listEdges", "DRACO_DEFAULTS", "encodeSpeed", "decodeSpeed", "quantizePosition", "quantizeNormal", "quantizeColor", "quantizeTexcoord", "quantizeGeneric", "quantizationVolume", "draco", "transform", "KHRDracoMeshCompression", "setEncoderOptions", "EncoderMethod", "EDGEBREAKER", "SEQUENTIAL", "quantizationBits", "POSITION", "NORMAL", "COLOR", "TEX_COORD", "GENERIC", "SRGB_PATTERN", "getTextureColorSpace", "texture", "edges", "isSRGB", "isColor", "listTextureInfo", "results", "textureEdge", "getParent", "TextureInfo", "listTextureInfoByMaterial", "textureInfoNames", "Texture", "ExtensionProperty", "listTextureSlots", "slots", "EPS", "PRUNE_DEFAULTS", "NODE", "CAMERA", "PRIMITIVE", "PRIMITIVE_TARGET", "ANIMATION", "BUFFER", "keepLeaves", "keepAttributes", "keepIndices", "keepSolidTextures", "keepExtras", "prune", "counter", "DisposeCounter", "onDispose", "event", "addEventListener", "nodeTreeShake", "listNodes", "treeShake", "skin", "camera", "listCameras", "indirectTreeShake", "materialPrims", "required", "listRequiredSemantics", "listUnusedSemantics", "pruneAttributes", "shiftTexCoords", "anim", "channel", "listChannels", "getTargetNode", "samplers", "pruneSolidTextures", "listBuffers", "removeEventListener", "str", "type", "info", "disposed", "parents", "p", "AnimationChannel", "needsExtras", "getExtras", "e", "ptype", "SCENE", "isEmpty", "setAttribute", "startsWith", "semantics", "textureNames", "replace", "getTexCoord", "match", "isLit", "Material", "isPoints", "textureInfoList", "texCoordSet", "texCoordList", "texCoordMap", "texCoord", "semanticMap", "textureInfo", "setTexCoord", "updatePrim", "srcSemantics", "srcSemantic", "uv", "dstSemantic", "_texture$getSize", "factor", "getTextureFactor", "ColorUtils", "convertSRGBToLinear", "getURI", "applyMaterialFactor", "Promise", "all", "slot", "setBaseColorFactor", "getBaseColorFactor", "setEmissiveFactor", "mulVec3", "slice", "getEmissiveFactor", "setRoughnessFactor", "getRoughnessFactor", "setMetallicFactor", "getMetallicFactor", "sub", "warn", "maybeGetPixels", "Infinity", "width", "height", "_unused", "FLATTEN_DEFAULTS", "cleanup", "flatten", "joints", "joint", "animated", "getTargetPath", "hasJointParent", "hasAnimatedParent", "_getBounds", "inspect", "animations", "sceneBounds", "rootName", "bboxMin", "toPrecision", "bboxMax", "renderVertexCount", "uploadVertexCount", "uploadNaiveVertexCount", "properties", "instances", "glPrimitives", "meshIndices", "meshAccessors", "attr", "accessorToTypeLabel", "targ", "modes", "MeshPrimitiveModeLabels", "meshPrimitives", "vertices", "extensions", "listExtensions", "ref", "alphaMode", "getAlphaMode", "doubleSided", "getDoubleSided", "resolution", "ImageUtils", "compression", "container", "readKTX", "dfd", "dataFormatDescriptor", "colorModel", "KHR_DF_MODEL_ETC1S", "KHR_DF_MODEL_UASTC", "uri", "mimeType", "gpuSize", "getVRAMByteLength", "minTime", "maxTime", "getMin", "getMax", "keyframes", "channels", "duration", "round", "NumericTypeLabels", "Int32Array", "Int16Array", "Int8Array", "Number", "base", "INSTANCE_DEFAULTS", "instance", "batchExtension", "EXTMeshGPUInstancing", "numBatches", "numInstances", "meshInstances", "modifiedNodes", "nodes", "getSkin", "hasVolume", "hasScale", "createBatch", "batchTranslation", "batchRotation", "batchScale", "batchNode", "setMesh", "setExtension", "needsTranslation", "needsRotation", "needsScale", "setElement", "getWorldTranslation", "getWorldRotation", "getWorldScale", "pruneUnusedNodes", "listProperties", "unusedNodes", "getCamera", "nodeParent", "createInstancedMesh", "JOIN_PRIMITIVE_DEFAULTS", "skipValidation", "joinPrimitives", "templatePrim", "primRemaps", "primVertexCounts", "primIndex", "createPrimitive", "setMaterial", "tplAttribute", "AttributeArray", "tplIndices", "dstIndicesOffset", "remapIndices", "remapAttribute", "done", "dstOffset", "srcCount", "_matrix", "JOIN_DEFAULTS", "keepMeshes", "keepNamed", "_joinLevel", "groups", "children", "nodeIndex", "dequantizeTransformableAttributes", "isNamed", "primMeshes", "primNodes", "dstNode", "dstMesh", "joinGroups", "srcNodes", "isSharedMesh", "dstMatrix", "primNode", "primMesh", "_deepClonePrimitive", "listTextureChannels", "mask", "getTextureChannelMask", "TextureChannel", "R", "G", "B", "A", "AlphaMode", "OPAQUE", "sortPrimitiveWeights", "isFinite", "vertexCount", "setCount", "srcWeights", "dstWeights", "srcJoints", "dstJoints", "getVertexArray", "setVertexArray", "weights", "normalizePrimitiveWeights", "isNormalizeSafe", "templateAttribute", "templateArray", "normalizedComponentType", "delta", "EPSILON", "weightsSum", "sum", "floatValue", "encodeNormalizedInt", "sign", "vertexIndex", "el", "getElement", "normList", "typeList", "SIGNED_INT", "TRANSLATION", "ROTATION", "SCALE", "WEIGHTS", "TargetPath", "TRS_CHANNELS", "QUANTIZE_DEFAULTS", "quantizeWeight", "normalizeWeights", "quantize", "patternTargets", "nodeTransform", "getNodeTransform", "expandBounds", "getPositionQuantizationVolume", "transformMeshParents", "transformMeshMaterials", "renderCount", "uploadCount", "quantizePrimitive", "needsExtension", "isQuantizedPrimitive", "isTarget", "PrimitiveTarget", "bits", "ctor", "getQuantizationSettings", "fromTransform", "fromScaling", "quantizeAttribute", "volume", "transformMatrix", "Node", "animChannels", "isParentNode", "setSkin", "transformSkin", "transformBatch", "targetNode", "setTargetNode", "nodeMatrix", "inverseBindMatrices", "getInverseBindMatrices", "ibm", "setInverseBindMatrices", "_batch$getAttribute", "_batch$getAttribute2", "_batch$getAttribute3", "instanceTranslation", "instanceRotation", "instanceScale", "tpl", "T_IDENTITY", "R_IDENTITY", "S_IDENTITY", "makeArray", "instanceMatrix", "compose", "decompose", "getThicknessFactor", "setThicknessFactor", "signBits", "quantBits", "storageBits", "BYTES_PER_ELEMENT", "range", "di", "clamp", "getMinNormalized", "getMaxNormalized", "relativePositions", "flatBounds", "relMin", "relMax", "isQuantizedAttribute", "componentSize", "UNSIGNED_BYTE", "UNSIGNED_SHORT", "tmpMin", "tmpMax", "bboxes", "fromRotationTranslationScale", "elementCount", "initialElement", "REORDER_DEFAULTS", "reorder", "encoder", "ready", "plan", "createLayoutPlan", "indicesToAttributes", "unique", "reorderMesh", "indicesToMode", "indicesToPrimitives", "attributesToPrimitives", "MESHOPT_DEFAULTS", "level", "meshopt", "EXTMeshoptCompression", "QUANTIZE", "FILTER", "METALROUGH_DEFAULTS", "metalRough", "extensionsUsed", "ext", "extensionName", "iorExtension", "KHRMaterialsIOR", "specExtension", "KHRMaterialsSpecular", "specGlossExtension", "KHRMaterialsPBRSpecularGlossiness", "inputTextures", "specGloss", "specular", "createSpecular", "setSpecularFactor", "setSpecularColorFactor", "getSpecularFactor", "getSpecularGlossinessTexture", "getBaseColorTexture", "getMetallicRoughnessTexture", "getDiffuseFactor", "createIOR", "setIOR", "diffuseTexture", "getDiffuseTexture", "setBaseColorTexture", "getBaseColorTextureInfo", "getDiffuseTextureInfo", "sgTexture", "sgTextureInfo", "getSpecularGlossinessTextureInfo", "specularTexture", "createTexture", "setSpecularTexture", "setSpecularColorTexture", "getSpecularTextureInfo", "getSpecularColorTextureInfo", "glossinessFactor", "getGlossinessFactor", "metalRoughTexture", "roughness", "setMetallicRoughnessTexture", "getMetallicRoughnessTextureInfo", "tex", "UNWELD_DEFAULTS", "unweld", "unweldPrimitive", "unweldAttribute", "TypedArray", "NORMALS_DEFAULTS", "normals", "modified", "faceNormal", "computeNormal", "n", "normalize", "PALETTE_DEFAULTS", "blockSize", "palette", "materialKeys", "materialKeyMap", "materialProps", "baseColor", "emissive", "metallicRoughness", "encodeRGBA", "encodeFloat", "metallic", "keyCount", "w", "padWidth", "paletteTexturePixels", "skipProps", "props", "baseColorTexture", "emissiveTexture", "metallicRoughnessTexture", "setURI", "ndarray", "visitedKeys", "materialIndices", "paletteMaterials", "nextIndex", "convertLinearToSRGB", "writeBlock", "image", "nextPaletteMaterialIndex", "srcMaterial", "blockIndex", "baseUV", "padUV", "dstMaterial", "toString", "padStart", "setName", "setMinFilter", "MinFilter", "NEAREST", "setMagFilter", "MagFilter", "setEmissiveTexture", "getEmissiveTextureInfo", "hex", "PARTITION_DEFAULTS", "partition", "partitionMeshes", "partitionAnimations", "existingURIs", "meshIndex", "isArray", "createBuffer", "createBufferURI", "primTarget", "animIndex", "SANITIZE_BASENAME_RE", "basename", "existing", "InterpolationInternal", "EMPTY_ARRAY", "RESAMPLE_DEFAULTS", "resample", "resampleDebug", "tolerance", "accessorsVisited", "srcAccessorCount", "samplerTargetPaths", "getSampler", "samplerInterpolation", "getInterpolation", "tmpTimes", "toFloat32Array", "tmpValues", "dstCount", "srcTimes", "srcValues", "dstTimes", "fromFloat32Array", "dstValues", "setInput", "setOutput", "used", "dstAccessorCount", "SEQUENCE_DEFAULTS", "fps", "sequence", "sequenceNodes", "createAnimation", "animBuffer", "inputArray", "outputArray", "Type", "VEC3", "createAnimationSampler", "setInterpolation", "AnimationSampler", "Interpolation", "STEP", "createAnimationChannel", "setTargetPath", "setSampler", "addSampler", "addChannel", "SIMPLIFY_DEFAULTS", "ratio", "error", "lockBorder", "simplify", "simplifier", "numUnsupported", "simplifyPrimitive", "_simplifyPoints", "srcIndexCount", "positionArray", "targetCount", "flags", "color", "colorArray", "colorStride", "simplifyPoints", "compactMesh", "SPARSE_DEFAULTS", "sparse", "modifiedCount", "nonZeroCount", "TANGENTS_DEFAULTS", "tangents", "generateTangents", "attributeIDs", "tangentCache", "meshName", "filterPrimitive", "texcoordSemantic", "getNormalTexcoord", "texcoord", "positionID", "uuid", "normalID", "texcoordID", "prevTangent", "attributeHash", "tangentBuffer", "tangentArray", "normalTextureInfo", "getNormalTextureInfo", "TEXTURE_COMPRESS_SUPPORTED_FORMATS", "SUPPORTED_MIME_TYPES", "TextureResizeFilter", "TEXTURE_COMPRESS_DEFAULTS", "resizeFilter", "LANCZOS3", "formats", "quality", "effort", "lossless", "nearLossless", "limitInputPixels", "textureCompress", "targetFormat", "patternRe", "formatsRe", "slotsRe", "textureIndex", "textureLabel", "srcFormat", "getFormat", "dstFormat", "srcByteLength", "compressTexture", "dstByteLength", "flag", "webpExtension", "EXTTextureWebP", "avifExtension", "EXTTextureAVIF", "srcURI", "srcMimeType", "dstMimeType", "_encodeWithSharp", "_encodeWithNdarrayPixels", "resize", "srcExtension", "FileUtils", "extension", "mimeTypeToExtension", "dstExtension", "dstURI", "RegExp", "_srcMimeType", "encoderOptions", "getFormatFromMimeType", "toFormat", "srcSize", "dstSize", "fit", "kernel", "toBuffer", "srcPixels", "dstPixels", "lanczos3", "lanczos2", "split", "srcMax", "dstMax", "UNINSTANCE_DEFAULTS", "uninstance", "instanceAttributes", "srcNode", "instanceNode", "createInstanceNodes", "instanceAttribute", "every", "instanceCount", "instanceCountDigits", "String", "batchName", "instanceNodes", "paddedIndex", "setRotation", "setScale", "_setInstanceExtras", "setExtras", "unlit", "unlitExtension", "KHRMaterialsUnlit", "createUnlit", "UNPARTITION_DEFAULTS", "unpartition", "UNWRAP_DEFAULTS", "groupBy", "unwrap", "watlas", "Initialize", "unwrapPrimitives", "weight", "getNodeScaleMax", "primitives", "_options$texcoord", "dstTexCoordIndex", "atlas", "Atlas", "unwrapPrims", "primWeight", "unwrapPrim", "meshDecl", "vertexPositionData", "getScaledAttributeFloat32Array", "vertexPositionStride", "vertexNormalData", "getAttributeFloat32Array", "vertexNormalStride", "vertexUvData", "vertexUvStride", "indexCount", "indexData", "addMesh", "generate", "meshCount", "atlasMesh", "srcTexCoord", "dstTexCoord", "vertex", "getVertex", "getIndexArray", "delete", "ArrayCtor", "xref", "vertexColorSpace", "inputColorSpace", "toLowerCase", "converted", "sRGBToLinear", "updatePrimitive"]
}
